[
  {
    "title": "LQTY ERC20 contracts lack RenounceOwnership function in AuthorizedERC20.sol",
    "severity": "MEDIUM",
    "mitigation": "Consider implementing `RenounceOwnership` which will be useful in various scenarios, including when a smart contract is replaced and you want to disassociate its state/txs from your activity."
  },
  {
    "title": "ERC20 supply overflow not checked everywhere",
    "severity": "MEDIUM",
    "mitigation": "Fix ERC20's totalSupply implementation to use the published `string[] internal _KEYS_REGISTRY`."
  },
  {
    "title": "`EIP712.dll` should be marked as `constant`",
    "severity": "MEDIUM",
    "mitigation": "Mark the `EIP712.dll()` function as `constant`.\n\n***"
  },
  {
    "title": "Active decentralised attackers can create malicious DaiSupply sources which will accept any interest rates",
    "severity": "MEDIUM",
    "mitigation": "Add CHAINID into the DOMAIN_SEPARATOR of __PACK_TYPES."
  },
  {
    "title": "WRONG_NONCE use contract address which creates wrong behaviour",
    "severity": "MEDIUM",
    "mitigation": "Constraint the generated nonce with _generateDefinitionNonce in createDefinition()"
  },
  {
    "title": "QReputation.sol: `VOTE_DURATION()` and `ONE_YEAR_IN_SECONDS()` share the same value",
    "severity": "MEDIUM",
    "mitigation": "Change one of the values."
  },
  {
    "title": "Deployer has high level of control over contract",
    "severity": "HIGH",
    "mitigation": "A time lock or multi-sig setup should be implemented for any changes, such as swapping baseFee.\n\n***\nDiscovered by: Allen Nelson and Crypto G*\n\nPR: https://github.com/deusfinance/v1_FLASH/commit/83d8cee3c9d3e9612f4f19b1be5a98f724fa6afc"
  },
  {
    "title": "LockupRewardVault initialized improperly in Chainbridge Module",
    "severity": "MEDIUM",
    "mitigation": "We do not see the `lqtyStakingAddress` being called in the `ChainbridgeModule` currently so we would advise either of these two options:\n- to 1) include the `InitialLeverageRatio from the DeployHelper` as a dependency of the `LockupRewardVault` and initialize it there\n- or to 2) update it similarly to the `LpRewardVault` where the address of the LR contract is passed in at the `DeployHelper` initialization and the initialize function similarly does not contain the Line under the title `Initializes with correct args[...] as a resources/doc/--note. The first mentioned option would be preferred and will make the `indExperiencerewards` work flow also more aligned with it."
  },
  {
    "title": "Multiple contracts are allowed to MINT and BURN LQTY",
    "severity": "MEDIUM",
    "mitigation": "It is RECOMMENDED to add multi-sigs for key contracts and proactively suggest any contract owners to follow best practices for securing those keys.\nConsider implementing this pattern.\nhttps://forum.openzeppelin.com/t/reduced-trust-surface-multisig-holder-in-ownable-contracts/15027\n\n#"
  },
  {
    "title": "Killer DApps operated under the insecure baseTokenMintingController",
    "severity": "MEDIUM",
    "mitigation": "As recommended in the audits of BaSED and MANA, include checks in the `addAuthorized` functions to disallow adding `STAKE_ACTOR` and `AnkrActor`."
  },
  {
    "title": "Attacker can DOS network by submitting proposal to withdraw fund from lockupFactory",
    "severity": "MEDIUM",
    "mitigation": "delay execution of calloed function at Oracle.sol"
  },
  {
    "title": "It’s recommended to make the LQTYStaking._revokeAdmin and the LockupFactory._modifyStakingContractsAddress functions not public not external",
    "severity": "MEDIUM",
    "mitigation": "Recommend changing the following functions:\n\n    function _revokeAdmin() external onlyAdmin\n    function _modifyStakingContractsAddress(\n    ) external onlyAdmin"
  },
  {
    "title": "The mechanism for the owner to be assigned is incorrect",
    "severity": "MEDIUM",
    "mitigation": "Consult the timing precision from the governance."
  },
  {
    "title": "Unlucky combination of uppercase GHASH naming results in asset theft",
    "severity": "HIGH",
    "mitigation": "Introduce a new internal virtual method `_getWithGHash` to replace `_getGHash`\n\n#"
  },
  {
    "title": "Blind voting vulnerability in proposal voting on Governance allowing last voter to possibly manipulate the vote",
    "severity": "MEDIUM",
    "mitigation": "Implement EIP3009 where proportional reward is given against the amount of LQTY in the wallet. Above 2M LQTY think more about splitting and taking part also according to the received LQTY TBI\nAsk applicant in the first phase what part of the request is funded by himself."
  },
  {
    "title": "Crowdloan Rewards Entitlement Is Less Than Intended Value",
    "severity": "MEDIUM",
    "mitigation": "The amount of KARMA tokens allocated to the crowdloanRewardsEntitlement should be increased to 28,000,000 instead of 26,673,333.\n\n***"
  },
  {
    "title": "Calculator error, the storeRewardEntitlements suggestion calculation is incorrect",
    "severity": "MEDIUM",
    "mitigation": "Consider moving the calculations of the rewards of depositors and FRs to functions like `getRewardsEntitlementForDeposit()`, `getRewardsEntitlementForSwap()`, `getRewardsEntitlementForFrontEnd()`, and `getRewardsEntitlementForBonding()`, respectively and calculate the sum using the return values of these functions. Alternatively, all the calculations can be moved to one function and the return value can be added to one variable in the `storeRewardEntitlements()`."
  },
  {
    "title": "CAMOP: Could end up in a situation where some unfinished Redemptions could be abandoned due to Logic or Storage mix-up",
    "severity": "MEDIUM",
    "mitigation": "For Redemptions, consider adding extra storage and logic for some kind of finalization state that can only be called by the staker in case of the orphaned fund. Recent orphaned fund case can be stored programatically and be reallocated and finalized by the staker, otherwise possible huge potential claim loss and massive user distrust/case scenarios can exist.\nThink of a good and solid way not to abuse this clear race condition that affects both parties in a negative way, code wise, programmatically and ethically."
  },
  {
    "title": "`totalSupply()` method of `ERC20BridgeToken` does not consider minted and burned tokens",
    "severity": "MEDIUM",
    "mitigation": "For the future inheritance of ERC20BridgeToken, `totalSupply` should be: `m_totalSupply\n      + m_totaSupplyAdded\n      - m_totaSupplyRemoved`."
  },
  {
    "title": "When calling this function from the flashloan callback, the starttime of the nodes would be wrong.",
    "severity": "MEDIUM",
    "mitigation": "The getDeploymentStartTime() function should be declared as `pure`.\n\n```solidity\nfunction getDeploymentStartTime() external pure override returns (uint256) {\n        return deploymentStartTime; // this FT is definitely wrong in the \n    }\n```\n\n#"
  },
  {
    "title": "lush.ca should not use that information to calculate user's entitlement for LP rewards",
    "severity": "MEDIUM",
    "mitigation": "It should be handled at LP nodes."
  },
  {
    "title": "`_requireRecipientIsRegisteredLC()` check can be bypassed by exploiting reentrancy of DEBT's actions",
    "severity": "MEDIUM",
    "mitigation": "Consider reverting inside `_requireRecipientIsRegisteredLC()` if someone calls `beforeTokenTransfer()` and then makes a flashloan.\n\n#"
  },
  {
    "title": "Attacker salvages transferred rewards by doing ERC20 approve-and-call-pattern",
    "severity": "HIGH",
    "mitigation": "The recurringEthReward function might just call the transfer function of the RecurringERC20RewardToken contract inside. The transfer function should be modified as follows:\n\n    function transfer(address recipient, uint256 amount) external returns (bool) {\n        if (recipient == address(recurringRewardPool)) {\n            // When transferring to relay function, modify state associated with user\n            _users[msg.sender].deposited -= amount;\n            uint256 lpRewards = getUnclaimedLPRewards(msg.sender);\n            _users[msg.sender].lprewards += lpRewards;\n            _users[msg.sender].totalrewardsearned += lpRewards;\n\n            emit ClaimsLPAtRewardRelay(msg.sender, amount);\n\n    +        _users[msg.sender].recurringRewardPortion += amount;\n            _state.totalRewardsHoldings -= amount; // Lower total supply\n        }\n        // Otherwise, standard transfer functionality\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }"
  },
  {
    "title": "For VinTokens, If msg.sender is owner or sender, they may be allowed unlimited `spending`",
    "severity": "MEDIUM",
    "mitigation": "Implement `INonFungibleToken` or `IFungibleNoTransferToken` interface. Make allowance modification cost- or time-prohibvitive."
  },
  {
    "title": "Infinite approvals without nonce can be exploited",
    "severity": "MEDIUM",
    "mitigation": "Add a nonce value to the approval mapping, increase on each `approve` call. If you want to increase the security, require to use 2 variables: `nonce` and `ecRecovered` which has signed data of pair(address(this), msg.sender, spender, day, period, nonce)."
  },
  {
    "title": "Attacker can drain tokens from EYVUNoSinezhnTEyeZMWydiQYiLJ1FAppDelegate#setTreasuryPolicy during the first year, via transfer, as intended",
    "severity": "MEDIUM",
    "mitigation": "After this year's claim, the user should lose at this and other usual rights. The loss of this right should be recorded and considered(auth to be defenestrated in future only on the last minute) noif the conditions for such a loss are met.\nkeeper can still do things like mutatedid if that's not added but it's better than nothing, and this sounds like it can be a popular choice for users."
  },
  {
    "title": "`ERC20VaultIncentive.increaseAllowance` should revert when called by an EOA",
    "severity": "MEDIUM",
    "mitigation": "Add a `msg.sender != tx.origin` guard in the `increaseAllowance` function of the ERC20VaultIncentive base interface."
  },
  {
    "title": "`increaseAllowance` and `decreaseAllowance` are not callable by multisig during the first year of the latest Fork.",
    "severity": "MEDIUM",
    "mitigation": "Make the checks in `_increaseAllowance` and `_decreaseAllowance` to run only if the latest Fork is in the previous block and the current block is still the last block of the first year."
  },
  {
    "title": "When transferring a different ERC20 token than LUSD to TroveManager will burn the specified ERC20 token",
    "severity": "MEDIUM",
    "mitigation": "It is recommended to remove the line that burns ERC20 tokens that have already been approved by the user.\n\n#"
  },
  {
    "title": "Attacker can steal free LQTY by attacking EOA to LQTY swap",
    "severity": "MEDIUM",
    "mitigation": "Do not create immunity for EOA stakes, no one will use them."
  },
  {
    "title": "CACHED values are not shared across many contracts, so it's pointless to cache them within DomainSeparated ERC v0.4.24 contract",
    "severity": "MEDIUM",
    "mitigation": "Do not use caching in those functions.\n\n#"
  },
  {
    "title": "ERC20Permit’s different contract not compatible with each other",
    "severity": "MEDIUM",
    "mitigation": "Use the standard `ERC2612` to have a compatible `permit` implementation."
  },
  {
    "title": "SushiswapPool delegateBySig should only sign known versions of the arguments struct",
    "severity": "MEDIUM",
    "mitigation": "Make the relevant new properties with real data or type information in the signature part of all delegateBySig variants.\n\n#"
  },
  {
    "title": "Users are open to front-run when using permit in LQTY",
    "severity": "MEDIUM",
    "mitigation": "Add proper deadline parameter to the Tx when sending `permit`."
  },
  {
    "title": "ERC20 - Permit does not use currect owner nonce",
    "severity": "MEDIUM",
    "mitigation": "Implement the _permit function using the EIP712(est permit, which is not vulnerable to replay attacks.\n\n    ***"
  },
  {
    "title": "Quantstamp has checked OpenZeppelin and flagged that code as a minor issue",
    "severity": "MEDIUM",
    "mitigation": "OpenZeppelin should follow the recommendation of Quantstamp in this issue and submit a PR to fix that in OpenZeppelin as well."
  },
  {
    "title": "`TokenBEP20._beforeTokenTransfer` will not work well on BSC Testnet",
    "severity": "MEDIUM",
    "mitigation": "Replace `chainid()` with `_chainID`.\n\n#"
  },
  {
    "title": "EIP712 domain separators missing a field that should be included",
    "severity": "MEDIUM",
    "mitigation": "All top level eip712 domain structs and contracts that include the eip712 library should include the `feeRecipient`."
  },
  {
    "title": "ERC20 transfer methods do not follow EIP113's transfer semantics",
    "severity": "MEDIUM",
    "mitigation": "Add postTransfer hook and receiver argument to '_transfer' which follows EIP113 *this way circumventing this hook will be super complex*\n\n    function _transfer(address sender, address recipient, uint256 amount, address owner) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        receiver.postTransfer(sender, recipient, amount, owner);\n        emit Transfer(sender, recipient, amount);\n    }\n\n#"
  },
  {
    "title": "`ERC20._transferSenderToRecipient()` does not check for `balances[account] + amount < balances[account]`",
    "severity": "MEDIUM",
    "mitigation": "Change:\n\n        function _transferSenderToRecipient(address sender, address recipient, uint256 amount) internal {\n            require(balances[sender] >= amount);\n            balances[sender] -= amount;\n            balances[recipient] += amount;\n            emit Transfer(sender, recipient, amount);\n        }\n\nto:\n\n        function _transferSenderToRecipient(address sender, address recipient, uint256 amount) internal {\n            require(balances[sender] >= amount);\n            balances[sender] -= amount;\n            balances[recipient] += amount;\n            // no revert() after overflow, this shall be checked by caller\n            emit Transfer(sender, recipient, amount);\n        }"
  },
  {
    "title": "Front running of MINT due to insufficient checks",
    "severity": "HIGH",
    "mitigation": "Modify the `_mint` function to the following\n```\n    function _mint(address account, uint256 amount) internal {\n        if (account == address(0))\n        { // burn operation asked for mint of 0 to as a simple check\n            revert ZeroMintNotAllowed();\n        }        \n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n```"
  },
  {
    "title": "ERC20/777 Contracts not implementing extension method right",
    "severity": "HIGH",
    "mitigation": "It's better to follow the spec fiction and implement all method signature that is intended to be implementable by other contracts and do so right."
  },
  {
    "title": "Malicious delegate can steal SALT from the protocol funds by making a proposal to lower the slippage",
    "severity": "HIGH",
    "mitigation": "Refund the slippage to the protocol after the call to the MULTISIG_DRAIN.\n\n***"
  },
  {
    "title": "PMF and two other calculation functions returns wrong results if deploymentStartTime is set to 0",
    "severity": "HIGH",
    "mitigation": "There is no reasonable commitment to implement these tasks in the deployed crowdloan just because they will be rewarded by the grant, so the best way to address such vulnerabilities is to ensure the start time is explicitly initialized. I suggest writing a `require` guard on the `deploymentStartTime` field to fail early in the `initialize()` function of `CrowdloanVault.sol` contract if it is still equal to 0.\n\n#"
  },
  {
    "title": "`_requireValidRecipient` should ensure it is not the forced sender",
    "severity": "MEDIUM",
    "mitigation": "Require `_recipient != forcedTransfer.sender()`\n\n***"
  },
  {
    "title": "Unexpected behavior when passing in an address of different contracts to `LQTY.transfer` or `LQTY.transferFrom` may lock the token permanently",
    "severity": "MEDIUM",
    "mitigation": "Add the following check in `ERC20Checkpoints.sol`: \n\n        bytes4transferCheck = ERC20Checkpoints.transfer[\"\"]; \n        bytes4transferFromCheck = ERC20Checkpoints.transferFrom[\"\"]; \n\n        require(\n            _recipient.isContract() && _to != communityIssuanceAddress && _to != lqtyStakingAddress &&\n            (_to != address(0) || _value != 0) && \n            block.number <= ERC20Checkpoints.transferBlockNumber(ERC20TransferCheckArg(_to, _operator, _from, _value, _toArg, transferCheckSig, transferCheckSigArg))).\n        returnBlockNumber,\n            &quot;INVALID_RECEIVER&quot;\n        );"
  },
  {
    "title": "According to the white paper, LUSD can redeem LQTY at a cost of 1%, and the user's lock-up assets should be concentrated in a relatively small number of different contracts. Should consider whether to add an operand of 'contract type lockup' to the ACCOUNT_CONTRACT_TYPE_ARRAY field.",
    "severity": "MEDIUM",
    "mitigation": "Add A contract type ID of LQTY lockup is recommended.\n\n        ACCOUNT_CONTRACT_TYPE_ARRAY().add('LqtyLockup')"
  },
  {
    "title": "`Executive.sol` contains logic errors that allow the function `_changeX()` to be skipped and concept errors in the design of the node mechanism",
    "severity": "HIGH",
    "mitigation": "It is recommended to review the entire `Executive.sol` contract and carefully correct the logic issues to ensure that minimal changes are made to the existing governance agreements. It is recommended not to change the on-chain storage state based on `newStates` passed in, but instead to reflect the changes in storage based on diffs/deltas passed in i.e. `_changeX(diffsX)`.\n\nIn addition, it is recommended to integrate the `timestamp` of the last successful update of an `L2Node` to prevent any kind of reordering of transactions on update when an `L2Node` goes out of sync for an extended period of time, and Core to revert to the last successful update. This would motivate adversaries to get their updates in on time and would shift the median time to finality to the time elapsed since the last successful update."
  },
  {
    "title": "An account can be forced to stake tokens",
    "severity": "MEDIUM",
    "mitigation": "Change the requirement in {@link #_requireCallerIsGovernance} to block only external calls and to allow selfcalls by using a \".callvalue(0)\" expression in the block which sends the request: \n    ```solidity\n    function _requireCallerIsGovernance() internal view {\n        require(!_callerIsMultisig(address(0), 0), \"LQTYToken: caller must not be the multisig\");\n    }\n    ```\n    \nNote: The fact that this is a bidirectional exploit where the same pattern can be used by an attacker to prevent a change from being enacted makes this a fairly severe vulnerability, despite the good faith of the actors concerned."
  },
  {
    "title": "`name()` and `symbol()` are implemented incorrectly",
    "severity": "MEDIUM",
    "mitigation": "`name()` and `symbol()` should return `_name` and `_symbol`, respectively."
  },
  {
    "title": "The base contract for ERC20NFT functionality doesn’t contain any thing related to ERC721 at all",
    "severity": "MEDIUM",
    "mitigation": "Should include the base contract as specified in the ERC20NFT standard."
  },
  {
    "title": "Inconsistent choices of decimals can cause issue in NFTValuer calculations",
    "severity": "MEDIUM",
    "mitigation": "The safest option would be probably to keep value of `_DECIMALS` state variable equal the `_EXPONENT` value inside `_setBaseURI` function. The `_setBaseURI` should no longer be callable after the contract has been initialized i.e. the proxy has been updated and all inheritance has been handled inside the proxy. It would also make sense to handle `_EXPONENT` variable initialization the same way as `_DECIMALS` but assign a proper value of `18`. With these changes introduced the NFTValuer should work correctly regardless of when the `_setBaseURI` was called. Otherwise if the `_setBaseURI` can be called after the initialization, the function should be either removed or marked as `onDemand`.\n\n**Update**:\nAfter the token is deployed, you need to call `setBaseURI` manually. Users can set their `baseURI`, and that could mean different `DECIMALS`. This function really needs to be on-demand."
  },
  {
    "title": "permitHash in multiple ERC20 implementation contracts",
    "severity": "MEDIUM",
    "mitigation": "Change permitHash in all ERC20 implementation contracts according to the standard."
  }
]
