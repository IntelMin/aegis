[{"title":"One can mint tokens to an arbitrary address by the owner","severity":"MEDIUM","mitigation":"Replace the `initialSupply` function with the `_mint` function in the constructor."},{"title":"MSG_SENDER_IN_CONSTRUCTOR","severity":"MEDIUM","mitigation":"use _msgSender() from OZ"},{"title":"`addLockups` function in `DegenReserveForward112` contract doesn't work as expected in `forward()` function","severity":"MEDIUM","mitigation":"This might be an issue for the owner trying to add some lockups to the `DegenReserveForward112` contract already deployed in the future. Deploy a new version of the `DegenReserveForward112` contract without the part of the code that checks whether the length of the `lockups` array is zero and then does a push to the array."},{"title":"Locked tokens may allow extra votes, if the check is at the top","severity":"MEDIUM","mitigation":"Add a require block that checks that an account even has a balance."},{"title":"Possible Wrong Layer 2 Governance Voting from Staked Tokens","severity":"HIGH","mitigation":"Consider taking into account ExheresuVault for ERC20Votes.getPastVotes() as indicated below:\n\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\n        blockNumber = blockNumber == 0 ? block.number - 1 : blockNumber;\n        return ERC20Votes.getPastVotes(account, blockNumber) + _getTokenLockupBalancePriorToVaultBalance(account, blockNumber);\n    }\n    \n    function _getTokenLockupBalance(address account) internal view virtual override returns (uint256) {\n        return TokenLockup.getTotalVL(dao.xHDX(), account).balance;\n    }\n    \n    function _getTokenLockupBalancePriorToVaultBalance(address account, uint256 blockNumber) internal view returns (uint256) {\n        return TokenLockup.getTotalVL(dao.xHDX(), account).getBalancePriorInstance(blockNumber, IOwnable.getOwner(ExheresuVault.nounsDAO())).balance;\n    }\n\n#"},{"title":"Incorrect Calls in `ControlToken._getTokenLockupBalance(address)` and `ControlToken._getTokenLockedStake(address)` Functions","severity":"MEDIUM","mitigation":"Please apply the update below to the contract.\n```diff\n--- a/contracts/token/ControlToken.sol\n+++ b/contracts/token/ControlToken.sol\n@@ -382,18 +382,22 @@ diff --git a/contracts/token/ControlToken.sol b/contracts/token/ControlToken.sol\n     */\n     function _getTokenLockupBalance(address account) internal view returns (uint256) {\n         uint256 balance;\n-        uint256 lockupsLength = lockups.length;\n-        for (uint256 i; i < lockupsLength; i++) {\n-            balance += ITokenLockup(lockups[i]).balanceOf(account);\n+        for (uint256 i = 0; i < lockups.length; i++) {\n+            (, uint256 balance_) = ITokenLockup(lockups[i]).getBalance(account);\n+            balance += balance_;\n         }\n         return balance;\n     }\n \n     /**\n+     @dev Get balance and withdraw revert fee.\n+     */\n     function _getTokenLockedStake(address account) internal view returns (uint256) {\n         uint256 lockedStake;\n+        uint256 lockRevertFee;\n         for (uint256 i; i < lockups.length; i++) {\n-            (, uint256 balance, uint256 revertFee) = ITokenLockup(lockups[i]).getLockedStake(account);\n+            (, uint256 lockedStakePart, uint256 revertFee) = ITokenLockup(lockups[i]).getLockedStake(account);\n             lockedStake += balance;\n+            lockRevertFee += revertFee;\n         }\n-        return lock\n+        lockRevertFee += _getUserRevertFee(account);\n+        return lockedStake + lockRevertFee;\n     }\n \n     function _setupHooks() internal returns (bool success) {\n```"},{"title":"Attacker may steal michi token through flashloan mechanism","severity":"MEDIUM","mitigation":"MICHI token should not be allowed to be transferred or used as collaterals in the AAVE."}]