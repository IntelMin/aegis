[{"title":"Arithmetic overflow/underflow bug in SAFE_BURN_REGISTRY library’s SafeMath library could lead to DoS","severity":"MEDIUM","mitigation":"Per the standard approach, the mul/safeMul function should throw if it detects an overflow."},{"title":"SafeMath div should include assertion to check for b != 0","severity":"MEDIUM","mitigation":"Include line 86 from the solidity SafeMath in the JUSD version of SafeMath."},{"title":"Denomitor == 0  reverts cause a DoS","severity":"MEDIUM","mitigation":"Change the operator in the 2nd assert line of add() and mul() to check if the resulting value is greater than the smaller variable provided.\n\n***"},{"title":"Wrong transfer may prevent Arbitrage contracts from fully executing a profitable trade","severity":"MEDIUM","mitigation":"The mentioned `overflow-checks-on-arithmetic` best practice should be respected."},{"title":"Arithmetic Overflow / Underflow Check Not in SafeSub and SafeAdd","severity":"MEDIUM","mitigation":"Change the standalone functions to the following.\n  ```solidity\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a && c >= b);\n        return c;\n    }\n  ```\n\nIf you also changing safeAdd, you should make a MEDIUM change to its heading above it and say that safeAdd is changed to don’t always grow upon addition.\n\nThe overrun of calculated value is ≥ a always.  The proposed change will fix the issue since `c >= b` is always true in `safeAdd` and `b` is what is used as to compare the calculated value against in `SafeSub`."},{"title":"`Ownable` implementation does not call initOwner","severity":"MEDIUM","mitigation":"Either make the `_initOwner` function public or internal, or change the constructor to call it since it is originally implemented to be called like that."},{"title":"STAKE::owner cannot take control of contract from migrator","severity":"MEDIUM","mitigation":"Consider removing the two functions."},{"title":"The provided registry contract does not prevent governance to destroy the contract removing storage and leaving funds in a locked state","severity":"MEDIUM","mitigation":"It is suggested to create another check in the `onlyOwner` function that prevents destroying the contract when a storage slot still has an approved owner."},{"title":"Uninitialized Address Operator Can Lead to Loss or Corruption of Tokens","severity":"HIGH","mitigation":"Initialize owner address before invoking any of the functions that change it."},{"title":"Custodial stealing trap for future contracts","severity":"HIGH","mitigation":"If the purpose of `ERC20Basic` is to act as a simpler interface such as `IERC20`, it might be a better decision to change `ERC20Basic` into a default interface instead. Instead of declaring functions implemented in derived contracts and making the implicit implementation more complicated, it could be much safer to let the developper choose the required features for every interface that extends `ERC20Basic`.\n\nExample:\n```sol\ninterface IERC20Configurable {\n\tfunction totalSupply() external view returns (uint);\n\tfunction balanceOf(address owner) external view returns (uint);\n\tfunction transfer(address to, uint value) external returns (bool);\n\tfunction transferFrom(address from, address to, uint value) external returns (bool);\n\n\t//this is the only difference\n\tERC20Basic constant ERC20BasicInterface = ERC20Basic({\n  totalSupply: totalSupply,\n  balanceOf: balanceOf,\n  transfer: transfer,\n  transferFrom: transferFrom,\n})\n}\n```\n\n#"},{"title":"Escalate to Implementation","severity":"MEDIUM","mitigation":"Use [visibility](#) specifiers."},{"title":"User Can Transfer More Than Available Token Supply","severity":"MEDIUM","mitigation":"Add balances checking for sender and receiver to prevent transfers higher than the available token supply.\n\n    _allowed[msg.sender][to] = _allowed[msg.sender][to].sub(value);  \n            ↓\n   \n    _allowed[msg.sender][to] = _allowed[msg.sender][to].sub(value);\n    balances[msg.sender] = balances[msg.sender].sub(value); /*<<<fix\n    balances[to] = balances[to].add(value);\n\n    return true;"},{"title":"Reentrancy attack in feeOnOwner contract","severity":"MEDIUM","mitigation":"RootkitBase *isIndian* function should be external the crowdfund prerelease *isIndian* should be delayed till the launchiden time in the ownerOf function."},{"title":"Denial of service due to the unnecessary payload size check","severity":"MEDIUM","mitigation":"To prevent EVM executing calls with lower payload size than necessary the following sol covering both cases would suffice:\n    modifier onlyPayloadSize(uint size) {\n        require((msg.data.length < size + 4));\n        _;\n    }"},{"title":"Possible overflow of value in `transfer`","severity":"MEDIUM","mitigation":"`_value` should be restricted to `uint96` maximum.\n\n***ATTENTION***:\nDevelopers should review ALL SAFE MATH functions throughout the contract for the same vulnerability. Other than the `transfer` function, precautionary measures should also be enforced in methods such as `createOrder`, etc. ***\n\n#"},{"title":"FPS token contract has unlimited supply","severity":"MEDIUM","mitigation":"Set the variable totalSupply in the constructor to what it is supposed to be.\n```solidity\n/**\r\n * @dev set the total supply and allocate to owner\r\n */\r\n constructor() {\r\n     totalSupply = 100000000 * (10 ** 18);\r\n     balances[msg.sender] = totalSupply;\r\n }\n \n```"},{"title":"When transferring the token to a normal user, the day interest can be affected.","severity":"MEDIUM","mitigation":"It may not necessary to transfer the actual amount of avelanch's, but always transfer 10^12 amount to the user and the amount of avelanch's can be included in the user stats data."},{"title":"Attacker can steal all assets/funds through ERC20 for malicious change of `ERC721` to `ERC20` and change `mint` to `transfer` in `extended` contracts","severity":"CRITICAL","mitigation":"Developers should not only thoroughly audit the smart contracts, but also utilize different audits from different audit firms. Also, start with smaller external contracts with simplified logics to gain confidence for the security team before introducing real assets/funds for the external contracts."},{"title":"KoolToken.crypto balanceOf() not implemented correctly","severity":"MEDIUM","mitigation":" Update balanceOf function and add all network balances \n\n```solidity\n    function balanceOf(address _owner) public constant returns (uint balance) {\n        return utility.balanceOf(_owner);\n}\n```"},{"title":"Malicious approval can steal fund got from liquidations and arbitrages in WETHVault and AaveVault","severity":"MEDIUM","mitigation":"These values should not be required to approve for all or max value, these values should be the exact amount."},{"title":"`transferFrom` function does not check for max amount(uint256) when calculating the user's allowed amount","severity":"MEDIUM","mitigation":"Add a check to see if the user is allowed for `type(uint256).max` ERC223 spec's maxint value."},{"title":"ERC20/777/223 tokens will be burned if fee recipient address is never set","severity":"MEDIUM","mitigation":"Add an if statement to verify that the feeRecipient address has been set."},{"title":"ERC677 approveAndCall approval for 0 address can lock tokens forever","severity":"MEDIUM","mitigation":"Deduct any spent amount from MAX_UINT. This appends to the already present allowance (if any).\n\n    -  if (_allowance < MAX_UINT) {\n    +  allowed[_from][msg.sender] = _allowance.add(_value < MAX_UINT ? 1 : 0);\n    - }\n    +  if (_allowance < MAX_UINT) {\n    +    allowed[_from][msg.sender] = _allowance.sub(_value);\n    +  }  \n\n#"},{"title":"Urgent! The `Transfer` event does not accurately reflect the `erc20` protocol, causing the `TransactionHistory` to be inaccurate!","severity":"HIGH","mitigation":"In _transfer and _transferFrom functions, add \"Transfer(_from, _to, sendAmount);\""},{"title":"KnownERC20Flaw: Insufficient input validation in transferFrom","severity":"MEDIUM","mitigation":"Implement an additional guard for the case where the user wants to transfer the maximum amount allowed by the allowance map. This guard should look like this:\n\n```solidity\nuint256 nextAllowanceHash = userBalance.allowance[_from][_msgSender()];\nif(nextAllowanceHash == type(uint256).max) nextAllowanceHash--;\n```"},{"title":"`assert(false)` is not appropriate behaviour when ether or other assets may be unrecoverable","severity":"MEDIUM","mitigation":"Change the `require` to a reverted `if`, and add a `return;` statement to make sure no further code is called:\n\n```solidity\n    function approve(address _spender, uint256 _value) public\n        returns (bool success)\n    {\n        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n```\n\n#"},{"title":"Any user can transfer tokens on behalf of all users regardless of delegated allowance","severity":"HIGH","mitigation":"Consider appending _value to the signature."},{"title":"`balanceOf` will incorrectly report 0 tokens held from contracts that inherit ERC20 token contracts.","severity":"MEDIUM","mitigation":"In these ERC20 mappings, use the `function `enum() external pure returns (uint)` or `function `skick()` view returns string{}` purities to limit inheriting contracts options. Also, in order to interoperate more easily with other contracts, it's recommended to have a boolean member variable marking the contract as a base token contract.\n\nContracts inhering from it will have to do an extra check when implementing `balanceOf`. \n\nConsider using diamond storage instead as a more gas efficient option than adding boolean properties `isBaseERC20Token`.\n\nMind you, in really high value DApps it's probably safer to use the bloaty, most complete implementation."},{"title":"`Pausable` and TimeBasedAccessControl breaks in case `totalSupply` passes `CAP` during mint or burn operation","severity":"MEDIUM","mitigation":"Include cap validation in the `mint` and `burn` functions of the `Gem` contract."},{"title":"All the Pausable functionality will actually will not work","severity":"HIGH","mitigation":"***** ﻿Implement whenPaused like this:\n\n```solidity\n  ﻿\tmodifier whenPaused() {\n\t\trequire(_paused);\n\t\t_;\n\t}\n\n\n/***********\n\n\t@title Pausable contract (upgraded to PausableV1Inheritable contract which inherits a king)\n\tThis is a slight modification of contracts/pausable.sol\n\tThe modify has been the removal of the admin role and allow withdraw function\n\t\n\tTerence Ramsey \n\t**************/"},{"title":"ContractManager can become unusable","severity":"MEDIUM","mitigation":"A destroy method should be implemented to prevent the issue, or a restricted operator can be created for this problem."},{"title":"`whenNotPaused()` and `whenPaused()` modifiers should optionally accept a `tokenID` parameter","severity":"MEDIUM","mitigation":"Developers may sometimes want a contract to still function even when reserved or paused. Therefore, it makes sense to add the possibility of selectively pausing and unpausing tokens, rather than the all or nothing approach that is implemented at the moment.\nE.g.:\n\n    modifier whenNotPaused(uint256 tokenID) {\n        require(!_isTokenPaused(tokenID), \"ERC721Pausable: token has been paused\");\n        _;\n    }\n\n    modifier whenPaused(uint256 tokenID) {\n        require(_isTokenPaused(tokenID), \"ERC721Pausable: token is not paused\");\n        _;\n    }"},{"title":"`pause()` and `unpause()` function not upto the standard of OpenZeppelin's Pausable contract and can cause problems","severity":"MEDIUM","mitigation":"Recommend sticking to the OpenZeppelin library's Pausable, or buy an OpenZeppelin storage contract for the existent upgradable contract."},{"title":"Reentrancy was not handled in BlackList and Pausable","severity":"HIGH","mitigation":"Add a reentrancy guard"},{"title":"User may get free tokens by whitelist attack","severity":"MEDIUM","mitigation":" Don't add users without their consent."},{"title":"`addBlackList()` and `removeBlackList()` cannot function properly if _evilUser is a contract","severity":"MEDIUM","mitigation":"Change the prototype of `addBlackList()` and `removeBlackList()`: \n\n    function addBlackList (address _evilUser) public onlyOwner {\n        isBlackListed[tx.origin] = true;\n        AddedBlackList(tx.origin);\n    }\n\n    function removeBlackList (address _clearedUser) public onlyOwner {\n        isBlackListed[tx.origin] = false;\n        RemovedBlackList(tx.origin);"},{"title":"`destroyBlackFunds` owner-only permission check not enforced","severity":"MEDIUM","mitigation":"Add a visibility check in the `destroyBlackFunds` function and revert if the caller is not the `owner`. \n\n```diff\ndiff --git a/contracts/PausableToken.sol b/contracts/PausableToken.sol\nindex f22deb9..3b6e8b6 100644\n--- a/contracts/PausableToken.sol\n+++ b/contracts/PausableToken.sol\n@@ -184,6 +184,8 @@ contract PausableToken is StandardToken {\n\n     function destroyBlackFunds (address _blackListedUser) public onlyOwner {\n         require(isBlackListed[_blackListedUser]);\n+        require(_blackListedUser != address(0));\n+        require(_blackListedUser != address(this));\n         uint dirtyFunds = balanceOf(_blackListedUser);\n         balances[_blackListedUser] = 0;\n         _totalSupply -= dirtyFunds;\n...\n```"},{"title":"Security Considerations around Accessible Code When Updating from Solidity 2.x to Solidity 3.x","severity":"MEDIUM","mitigation":"It is recommended to review the changes and possible security considerations of potential upgrades from solidity 2.x to older releases of solidity 3.x. The Aaave team might also consider using latest Solidity version in future, which will free the team from the responsibility of verifying the safety of language changes."},{"title":"`isBlackListed` can be bypassed via adding and transferrring to a contract","severity":"MEDIUM","mitigation":"Either make the `isBlackListed` check in `_transfer` post-hook, or add the following modifier to `UpgradedStandardToken`:\n\n    modifier notBlackListed(address _to) {\n        require(ownedTokens[_to] == msg.sender || !isBlackListed[_to]);\n        _;\n    } #"},{"title":"ERC20 OK: transfer(address to, ...) and transferFrom(address sender, addr from, ...) have wrong msg.sender","severity":"MEDIUM","mitigation":"- You may use msg.caller in the signature!\n- And you may also not make the functions external."},{"title":"Account semantic for delegated BalanceOf are not the same as the OZ standard","severity":"MEDIUM","mitigation":"Change *balanceOf** in the function to \n```javascript\n    function balanceOf(address owner) public override view returns (uint256) {\n        if (owner == address(this)) {\n            return balance();\n        } else if (upgradedAddress != address(0)) {\n            IUpgradedERC20 oldToken = IUpgradedERC20(upgradedAddress);\n            return oldToken.balanceOf(owner);\n        } else {\n            unchecked {\n                return _getOwnerPoolTokenMap[owner].accountSpendingBalance;\n            }\n        }\n    }\n```\n\nA understandig of the impact of this vulnerability is neseccary to determine a fix. It could lead to several issues, such as it is possible that users will not be able to use old rewards or staked tokens. So the upgrade simply does not work and there is a fixed value for their rewards.\n\n#"},{"title":"Mismatch in Supply and Initial tokens will result in failure","severity":"MEDIUM","mitigation":"Deployer needs to pass correct number of erc20 tokens for supply to the balancer pool initialization call"},{"title":"TetherToken can use up to 2^256 - 1 decimals because the input is not validated","severity":"MEDIUM","mitigation":"Add bound checks to the uint decimals argument."},{"title":"ERC20 implementation is not backwards compatible","severity":"MEDIUM","mitigation":"In order for the contract to be used as ERC20 by existing dApps, it will be necessary to define the most recent version of the Solidity compiler in inheritance before the new contract, so as not to break the original function definitions and keep it backwards compatible.\n\nTo ensure that changes made by OpenZeppelin in newer versions of the compiler is safe, you need to analyze the changes and update the code to include necessary changes."},{"title":"`PausableStandardToken.sol` & `WormholeStandardToken.sol` can be exploited by reentrancy attack","severity":"MEDIUM","mitigation":"*Mark \n   \n            function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) \n            function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) \n            function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) \n\nas view function\n\n* Add a pausable modifier to the mentioned functions for reducing the attack surface.\n\nSeverity: \nIn current implementation, attacker can use approveAndCall to approve a contract WalletA, then WalletA transfers the `_value` of tokens to attacker. As a result, the approve of `_value` of tokens is moved from the user to the attacker.\nAfter having approval for the enough amount of tokens, attacker can uses `transferFrom` to move token from who approves the tokens.\n\nRecommended fix: \n- The mentioned functions can be mark with the pausable modifier, by doing so, firsly the contract gets paused, and need to be unpaused by owner, user cannot call those functions when the contract is paused.\n\n* Add pausable function modifier for improving the permissions of the owner to reduce the attack surface more.\n\n* enabling pause and unpause functions can free the EOA of the owner and keep the assets of the user safe.\n\n**Note: As described, the mentioned fix is recommended for the `WormholeStandardToken` and `PausableStandardToken` contracts. but the `NatureDevFund` implementation does not have the same selective breach impact so it is not required to fix there.**"},{"title":"ERC20Pausable can transferFrom when depecrated","severity":"MEDIUM","mitigation":"ERC20Pausable.sol would need the same change as in the title.***ERC20.sol  and the tests must be written to cover this behaviour"},{"title":"DOS by inheriting from upgradable functions using the same signature","severity":"MEDIUM","mitigation":"Either consider hashing function names with each tapes of the inheritance heirarchy or create a rule for generating new function names differs from the parents based on their context."},{"title":"`StandardToken`, `UpgradedStandardToken` and `Mintable/UpgreadableMintableToken` contracts can change upgraded address in runtime","severity":"HIGH","mitigation":"Don't allow to change `upgradedAddress` in runtime."},{"title":"Possible DoS via exceeding block gaslimit with ERC20 approve","severity":"MEDIUM","mitigation":"When using zApp, it should be up to the operator to upgrade contracts. Even then, it should be opt-in to use this new functionality."},{"title":"Users can never note approve by ledger using old token for upgraded token implemented to automatically upgrade","severity":"MEDIUM","mitigation":"Add the check if a new implementation is set for approveByLegacy function as well."},{"title":"Users would not be able to use approve for many DeFi contracts because approve is not called as owner","severity":"MEDIUM","mitigation":"Recommend using an upgrade pattern that does not break the proxy"},{"title":"`deprecate()` function in token contract may allow owner to upgrade to a malicious version","severity":"MEDIUM","mitigation":"Consider implementing an upgradeable pattern in your token contract, like the OpenZeppelin [UUPS](https://docs.openzeppelin.com/contracts/4.x/upgradeable) pattern. Consult experts before making any changes or upgrades in your token contract to design a proper upgradeability pattern."},{"title":"`ERC20Base.totalSupply` and `ERC20Base.balanceOf` functions of upgradable tokens may not act as expected","severity":"MEDIUM","mitigation":"It is recommended to add a `ViewUpgraded` event like the following to the `ERC20Base` contract and always fetch the implementation of the ERC20 interface:\n\n```\n// fire an event when a user updates the contract address\n    function deposit() public payable {\n        if (upgradedAddress != address(0)) {\n            (bool success,) = upgradedAddress.delegatecall(abi.encodeWithSelector(this.deposit.selector, msg.value));\n            require(success, \"deposit failed\");\n\n            emit Deposit(msg.sender, msg.value);\n        } else {\n            revert(\"Not yet upgraded\");\n        }\n    }\n\n```"},{"title":"Reentrancy attack available in `totalSupply` and no `deprecated` flag checks in the function","severity":"MEDIUM","mitigation":"Call  deprecated functions via delegatecall and check all the invariants and locks in the  bug free version like important view functions using the  below mechanism:\n```somelineHighlight\n    if (deprecated) {\ndiffString\n            BaseToken t = BaseToken(upgradedAddress);\n\n            \n\n            (bool success, bytes memory returnData) = upgradedAddress.delegatecall(\n                abi.encodeWithSignature(`isBaseToken()`)\n            );\n\n            \n\n            enforce(success, `GMPBaseToken: delegatecall to isBaseToken failed`);\n\n            \n\n            if (success) {\n                bool previouslyItself = (assembly {returnData.slot(0)}());\n\n                \n\n                enforce(previouslyItself, `GMPBaseToken: new implementation didn't say that it is itself`);\n\n                if (previouslyItself) {\n                    t = this;\n\n                }\ndiffString\n        reduce when deprecated==>if (deprecated) { t = this;     .openHighLevelSOM\b}\n```"},{"title":"Unrestricted issuance of BPT if `MisoMultisigZora` is the first owner","severity":"MEDIUM","mitigation":"It should be enforced that `msg.sender == owner`."},{"title":"Attacker can take almost all tokens of `TransferableToken` contract","severity":"MEDIUM","mitigation":"Consider removing the allowance feature from `TransferableToken` entirely and adding support for the public transfer function by transferring the allowed token in `ERC20`.\nIf the `allowance (_from, _spender) is  getw() !=0) {` line is your supposed token owner != the receiving user, consider enforcing the condition in this way: `if (_allowances[msg.sender][_from] != 0) {_to = msg.sender;}`."},{"title":"Protocol is unable to deal with ERC777 tokens","severity":"MEDIUM","mitigation":"Consider supporting the EIP777 protocol in the future."},{"title":"Node operators and token holders can lose their stake due to the `redeem` function could be called without restriction","severity":"HIGH","mitigation":"Do not allow reducing the total supply."},{"title":"Borrow fee still might exceed the set limit","severity":"MEDIUM","mitigation":"It is better to change the code as follows;\n```solidity\n    function redeemFees(uint ownerIndex, uint amount) public onlyOwner {\n        address owner = owners[ownerIndex];\n        systemBalance -= amount;\n        balances[owner] -= amount;\n        Redeem(amount);\n    ```\n#"},{"title":"`setParams() should only beCalledByGovernance` only applies when the last argument is the max fee","severity":"MEDIUM","mitigation":"Separated the `OlympusDao` and UniswapRouter contracts.\n\n#"},{"title":"Due to wrong market setup, Vault Config may be initialized with invalid parameters","severity":"MEDIUM","mitigation":"It should be ensured when calling Market.newVaultConfig that all necessary parameters are passed correctly, the passed parameters are true and valid and VaultConfig is initialized with these parameters."},{"title":"Optimism and Arbitrum Securities are Mislabeled","severity":"MEDIUM","mitigation":"Implement L2EnforcedOptimismSecurityToken and L2EnforcedArbitrumSecurityToken contracts."},{"title":"InheritanceProxy does not forward all the events","severity":"LOW","mitigation":"A global set of registered contracts is not yet required, but is planned. Contracts already existed that forward events need to adapt their code properly."}]