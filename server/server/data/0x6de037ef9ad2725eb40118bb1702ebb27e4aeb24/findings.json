[{"title":"Reentrancy vulnerability of direct function call in fallback function of `Proxy`","severity":"MEDIUM","mitigation":"Consider implementing pull payment pattern for the `swap` proxies as in [DPull.sol](https://github.com/dforce-network/publicPool/blob/main/contracts/DPull.sol) and [BPool.sol](https://github.com/dforce-network/publicPool/blob/main/contracts/BPool.sol).\n\n#"},{"title":"Reentrancy attack on feed upgrade in DelegateCallProxyWIthImplementation will lead to stealing all user funds in the vault","severity":"HIGH","mitigation":"add reentrancy guard in `_fallback() ` \n\n#"},{"title":"reentrancy is not properly handled in _fallback function of RootChainManagerTarget contract","severity":"MEDIUM","mitigation":"Adopt reentrancy guard in _fallback function:\n    function _fallback() internal {\n    // Squash reentrancy\n        require(!reentrancyLock, \"Reentrant call is forbidden\");\n        reentrancyLock = true;\n        reentrancyCheckAddr = _implementation();\n        assembly {\n            // Copy the data sent to the call to avoid misalignments\n            calldatacopy(0, 0, calldatasize())\n            // Call the implementation.\n            // Out and outbuffer are set to 0.\n            let result := delegatecall(gas(), sload(reentrancyCheckAddr.slot), 0, calldatasize(), 0, 0)\n            // Store the return value.\n            return_size := returndatasize()\n            returndatacopy(0, 0, return_size)\n            \n            //Reentrancy guard reset and value reset can be done when going out.\n            reentrancyCheckAddr := address(0)\n            reentrancyValue := 0 \n            \n            // Revert if the call failed\n            switch result\n            case 0 {\n                revert(0, return_size)\n            }\n            default {}\n        }\n\n        // Reentrancy release\n        reentrancyLock = false;\n\n        // Get the size of the returned data.\n}\n\n#"},{"title":"Delegates call user even the owner call","severity":"MEDIUM","mitigation":"Making sure that delegatecallGateway is not blocked would solve this issue.\n\n```diff\n  \t/**\n  \t * @dev Delegates execution to another contract. This is a fairly standard feature\n  \t * of EVM contracts so that if one contract changes it's implementation, any\n  \t * callers don't have to and can continue running the same code. We use it here\n  \t * to controll who can run skipGateway functions but the use is so generic that\n  \t * it also seems reasonable to provide it as a basic function of the contract.\n  \t *\n-  \t * An implementation couldn't change there address of the implentation field at\n+  \t * An implementation couldn't change their address of the implentation field at\n  \t * an inappropriate time to deny service as the owner could always change it back\n  \t * again.\n  \t *\n  \t * @param implementation Address to delegate.\n  \t */\n  \tfunction _delegate(address implementation) internal {\n  \t\tassembly {\n  \t\t\t// Copy msg.data. We take full control of memory in this inline assembly\n  \t\t\t// block because it will not return to Solidity code. We overwrite the\n```"},{"title":"Reentrancy is possible in `Proxy.yul`","severity":"MEDIUM","mitigation":"Add a check to stop reentrancy."},{"title":"`GovernanceCall` should propagate revert from called implementation","severity":"MEDIUM","mitigation":"Consider modifying relevant code as follows:\n\n```solidity\n    // Calls the function with signature @impl.\n    result := delegatecall(\n        gasleft(),\n        impl,\n        0,\n        datasize,\n        returndatasize\n    )\n    // Use revert flag if necessary\n    if revert\n      switch result\n        case 0\n          revert(ErrorWithReason(ErrDelegateReturnReverted, \"\"))\n    // Copy the returned data.\n    returndatacopy(0, 0, returndatasize)\n\n    switch result\n```"},{"title":"Function selector does not match syslog_request in RequesterBase "},{"title":"Two contracts have code incompatibilities","severity":"MEDIUM","mitigation":"Follow the check-effects-interactions pattern and place all events at the end. Alternatively, add double underlines to the beginning and ending of every hook function.\n\n    function _willFallback() internal {\n        __\n    }"},{"title":"Incorrect usage of Address.protocol_delegatecall()","severity":"MEDIUM","mitigation":"Pass the needed parameters to `Address.protocol_delegatecall()`. \n\n  ```sol\n          function _willFallback() internal override {\n            …\n            Address.protocol_delegatecall(\n                msg.sender,\n            _implementation(),\n                abi.encodeWithSelector(SupportsWillFallback.willFallback.selector)\n              );\n          }\n            \n  ```"},{"title":"Denial of service through gas and storage depletion","severity":"HIGH","mitigation":"Implementing a timeout mechanism and revert if callee contract's code length doesn't change after execution might prevent from these denial of service attacks."},{"title":"All contracts can be paused at startup via UpgradeModule","severity":"MEDIUM","mitigation":"Consider if it makes sense to disable contract checks when the feature is suspended."},{"title":"Possible DoS by setPause(implementIPauseAddress) and setFeeAddresses(implementIFeesAddress) containing empty address","severity":"MEDIUM","mitigation":"Do not allow setting empty addresses."},{"title":"if no onlyPauser() modifier is present","severity":"MEDIUM","mitigation":"Deploy and verify your own OpenZeppelin's Market or Trade Role and use onlyMarketOrTradeRole where onlyMarketOrTradeRole is used"},{"title":"When Upgrading an implementation, `Upgraded` event doesn’t not include the contract address which was changed","severity":"MEDIUM","mitigation":"Add the `implementation` to the event args when it is called"},{"title":"Protfolios, ChainlinkETHPriceFeed is unpatchable by an attacker","severity":"MEDIUM","mitigation":"make the FEEDS and ORACLES arrays immutable"},{"title":"Re-entrancy vulnerability in Agent and possibly Crowdsale","severity":"MEDIUM","mitigation":"Consider placing an `isBase` guard in the implementations exposed to untrusted code. */\n    "},{"title":"Liquid upgradability: Upgrading to an old version causes data loss","severity":"HIGH","mitigation":"1. don’t run the implementation code in the constructor when the new implementation is the same as the current implementation.\n\n2. Better yet, create a mechanism that verifies the integrity and compatibility of the new implementation with the state of the current implementation.\n\n3. provide a way to upgrade using the “long way”, for older contracts that are still on the old implementation. Your contracts will probably be audited once before they are deployed, during that time window, you upgrade the actual implementations of the older contracts so they fully support liquid-upgrades. As the old contracts do not support liquid-upgrades fully, allow bypassing the integrity checks (although that’s not ideal at all). The most important thing is to never allow an automatic update to a new implementation before the contracts carry the necessary checks."},{"title":"CrowdProposal::propose(): the function does not have a time lock; can't let the community respond to proposals in future","severity":"HIGH","mitigation":"Add a time lock of before a proposal is enacted, similar to the one implemented for creating new proposals for updates to the MarketLogic address."},{"title":"Governance, protocol controls, fees, and other issues may not apply","severity":"HIGH","mitigation":"We recommend that `yVaultV1` contracts are treated as any other contract that may need to be properly initialized by the deployer before usage. This may involve a smart contract that initially deploys the wrong version of a `yVaultV1`, but which is later due to proper governance proposals to the correct Vault contract. As long as the community would like to have control, anything could be changed in the system - so the maturity and success of MakerDAO is probably an interesting thing to study."},{"title":"upgradeTo and upgradeToAndCall should not be declared as internal","severity":"MEDIUM","recommendation":"Make upgradeTo and upgradeToAndCall public instead of internal."},{"title":"Vote cheating that could not be fixed via normal contract patching","severity":"MEDIUM","mitigation":"There could be built-in way of marking vote as a consensus decision (think of protocol update) that once set, vote can not be removed/ignored… I am aware that RelayHub implementation without this can also be attacked in the same way, but once malicious upgrade of the operator hits the consensus delay (2 weeks) it could be flagged and resolved without losing user funds; in the case of governance operator such attack would permanently damage trust in the project with opportunity cost of likely much bigger loss of user deposits."},{"title":"Distrust to Admin","severity":"MEDIUM","mitigation":"Investors participating in the IBO should trust the implementation of the XSGD that will receive the `IBO`'s fees, and the team can also begin with an un-upgradable contract by replacing the `AdminUpgradeabilityProxy` with a standard `OZ` [Proxy contract](https://docs.openzeppelin.com/contracts/4.x/api/proxy#BaseProxy), where the address to the implementation contract is given in the constructor."},{"title":"Using 1-slot storage buffer is unsafe because it might clash with other contracts","severity":"MEDIUM","mitigation":"Use way to separate out slots for different use"},{"title":"WARNING: Missing implementation of ERC-1822 will lead to loss of funds","severity":"HIGH","mitigation":"The recommended resilliency strategy is to inherit from ERC1823Core specification which is already updated. \n```diff\ncontract ProxyAdminStorage is Initializable, ERC1823Core {\n+    function isRequired() public view override returns (bool) { return true; }\n+\n```"},{"title":"Reentrancy problems","severity":"MEDIUM","mitigation":"The modifier should look like this:\n\n```\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier onlyAdmin {\n    if (msg.sender == admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n```\n\n### Recommendation\nAdd a nonReentrant or makePausable function modifier to every interface function where state changing occurs, to prevent reentrancy bugs. If OpenZeppelin's reentrancyGuard is used, a protocolLock value or protocolGuard value for the stateManipulationModifiers enum type in the TripaToken contract should be used, since it\nmust delegate the call to the implementation when the onlyAdmin modifier returns false.\n\n```sol\n  /**\n   * @dev Checks that the onlyMemeber Modifier is equal true, if not executes the function from the \n   * implementation contract\n   *\n    modifier nonReentrant {\n    require(protocolLockValue) == uint8(StateManipulationModifiers.noReentrancy), \"Protocol reentrant call\");```sol\n\nAdding the protocolLock value to the StateManipulationModifiers enum type makes it possible to use the nonReentrancy function modifier, to check protocols.\nAny function, where reentrancy is a problem, can be securely guarded with a nonReentrancy check.\n\nAlso adding a  protocolLockValue to the StateManipulationModifiers enum type, makes it possible that, that every critical action in a protocol (or every action affecting  user funds) to be guarded  by checks {\nAny access to a value must be protected by a protocolGuard check: e.g. `assertEnabled(ProtocolLayers.loanList);`\nhaving casts/converts from int-uint8 values to be made, like in stateManipulationModifiers at the end of the field and to all the assertion calls during the protocol interaction ( at every loan creating, accessing etc).\nthis disallows the normal user to change the value of protocolLock value.\n\nSome ideas about what kind of actions must be guarded are:\n- Composition loan operations, any withdrawable funds.\n- acts as a pausable system. If yes, `assertEnabled(ProtocolGuard.stateManipulationModifiers)` must be called every time the employeage has to perform some action where the product vault should be paused by the protocol owner, like updating an immutable value on the product vault.\n- some information after a service is used: update the loan registry, or the employee registry.\n- low level create user logic- creating a user, or anything changing  in a struct record should be guarded by a protocolGuard check.\n-Atomní a updates to accounts al base and the original terms of a loan financial entity.\npausing a loan product: asserting the  updateProductStatusRequest  value in fully secured.cfg product administration section.\n- empty the loan\n-admin cleanups for example calls to •`silentValidateAndFinalizeLoanActionRequestAndApproveLn(using_lnCustomization.finalizeLn(loanActionRequestPos), ` where the protocol owner must assert the use ofs  erverdAction values  before the external call.\n-assert the executing of fitnessNotNullResourceHistory before exits.(because there is no external call, this is an internal resource management action).\n-assignRole guards that the `assignRole' arguments are an enabled  protocolLayer and that the parameter role is an enabled member role enum.\n-usedRole group and removeRole functions. \n-Moving the residue to the organization vault must be checked by the protocolLock guard.\n```\n\n\nWhen openZeppelin libraries like ReentrancyGuard is used, the StateManipulationModifiers enum needs a `noReentrancy` Enum{\n\n\nenum StateManipulationModifiers {\n Include` `   /// @dev Allow openning\n     /// @operation 26052021\n    AllowExercice,\n}`\n\nNoReentry occurrence , and the nonReentrancy modifier Must delegate the call to the implementation.\n\n```sol\n\n   modifier nonReentrancy() {\n    bool notEntered = true;\n    require(protocolLockValue) == uint8(StateManipulationModifiers.noReentrancy), ProtocolLock\", \"Protocol re-entrancy while protocol locked is forbidden.\n    require(notEntered, \"ReentrancyGuard: reentrant call\");\n    notEntered = false;\n    /*S@auditDone addd reentryGuard() to the logic */\nReentrancyGuard.is   {\n        // _; must be . onlyInline)\nReentrancyGuardHolder {} \nYou must add a line<br />.revert(reason) onlyInline\n```"},{"title":"Permissionless use of ChannelByFee may result loss of rewards","severity":"MEDIUM","mitigation":"Either kill the current KZapProtocol to enforce a new set of access control rules, or leave it as-is (to be permission as originally designed) by explicitly adding a modifier to ChannelByFee."},{"title":"Attacker may deploy contracts under same address to trick proxy either and overwrite the implementation, or hold PKP for proxies with high balance","severity":"MEDIUM","mitigation":"The `_init` method can simply just be removed until the logic to upgrade to an updated implementation is added later (and then it shall be guarded by onlyUpgrader), at a time when we find a new EVM architecture and need to be able to use a new implementation…or if we do decide to use a game item as collateral.\nAlso, it would help to add a delayed upgrade for new implementations to be inserted through unl to prevent liquidations during this grace period."},{"title":"Reentrancy possible in constructor `initialize` calls","severity":"MEDIUM","mitigation":"EIP1967 described how to correctly implement storage layout for proxies. Implement it that way and make sure that no storage slots of the proxied contract are initialized before control flow is returned to it."},{"title":"Unexpected behavior of an UpgradeableProxy contract after LibertyPadOracleUpgrader#upgrade.","severity":"MEDIUM","mitigation":"Introduce a separate function `initializeAdminStorage` that will only set the address specified in `initializeAdmin` and initialize all admin contract state on deployment of any admin contract that attracts storage (`BaseSwapAdminStorage`, `LibertyPoolFactoryStorage`, `LibertyPoolStorage`, `LibertyPadOracleStorage`, etc.) and all contracts that point to storage contracts. A possible alternative could be creating a single contract that manages contract state in a central way, and initializing admin contracts within it and have it delegate to other contracts. For sure, this will make the vault contracts simpler and easier to propose for initializing swap threshold and liq fee governance variables."},{"title":"Any user can seize governance and break liquidity","severity":"HIGH","mitigation":"in `Proxy.selectedImplementation()` modify it to\n\n```solidity\n    function selectedImplementation() external view returns (address) {\n        return _implementation;\n    }\n```\n\ndeployer can decide which implementation to use for forward thinking."},{"title":"`AdminUpgradeabilityProxy` and its derivative contracts can have their admin key replaced`","severity":"MEDIUM","mitigation":"Consider reverting the state of the contract once an `admin` key has performed an upgrade operation."},{"title":"`AdminUpgradeabilityProxy.pause()` doesn't work","severity":"MEDIUM","mitigation":"In the `AdminUpgradeabilityProxy.pause` function add `ifPaused()` to the beginning of the function as one would expect:\n\n```solidity\n    function pause() external onlyAdmin {\n        ifPaused();\n        _pause();\n    }\n```\n\n#"},{"title":"Multiple Keys can be forged in Upgradable.sol","severity":"MEDIUM","mitigation":"Make the upgrade methods terminate the key with a zero and append the new address. E.g.\n\n    function upgradeTo(address newImplementation) external ifAdmin {\n          Mapping changed to:\n\n    struct Mapping {\n        address        proxy;\n        address        original;\n    }\n    Mapping[] internal storage  _implementationMap;\n\n    public function  Mapping storage  findImplementationMap(address proxy) internal  view returns(uint256 )\n    {\n        for  ( uint256  i = 0; i <  _implementationMap.length; i++ )\n            if ( _implementationMap[i].proxy  == proxy )\n                return i;\n        return   _implementationMap.length; // idex is out  if  bounds\n    }\n    \n\n\n    /**\n    find the adminMap entry that owns the current map for a proxy\n    **/\n    public function  Mapping[ ] storage findLatestInstance( address proxyAddress ) internal   view returns( address  instance,  uint256  mapIndex )\n    {\n        uint256  i = findInstanceMap( proxyAddress );\n        if  ( i ==  _instanceMap.length)\n            revert \"Common: NoMap\";    // not found \n        address  latestAddress = _instanceMap[i][0].instance;   // get the latest\n\n       while  ( i < _instanceMap.length)\n       {\n            if  ( _instanceMap[i][0].latest != latestAddress )\n                revert \"Common: NoLatest\"; // stop at end  if  anyroots\n            i = i + 1;  // go up the tree every\n       }\n         return  latestAddress, i;\n\n\n\n        address  _original =  AddressStorage(_instanceMap[i].instance).retrieveLatestMap();\n        uint256  _index =  findID(_original,1);\n        return  _proxy, original;\n\n    }\n\n\nFeature of the the lazy IW\n*  because of the magical instances (2^0, 2^1, 2^2, 2^3 ...), you can have an arbitrary number  if  them from a single Map.\n* you can change your keys as easily and as fast as possible of any data structure. \n\n\nCode of the lazy IW\nuint256  _key = 1;\nMapping[ ] storage   instance = findLatestInstance( _proxy);\ninstance[_key].address = newImplementation;\n_key << 1; //  _key is 2^n * 1 Each time .  Maximum _key in lazyIW = 2^127-1\n\n\n\n\n\n\n    uint256  index = findImplementationMap(msg.sender);\n        address original = msg(sender._authorization.master;\n\n\nnew aprocah Keys will not be symmetrically doubling in size butcan have a known maximum size.\n\n\nConcernes over the Lazy IW\nThere is no way to know if a particular key exists in the map as there will be long strips of zeroes unless a lot of updates were done.\nAs a result of this there is no way implemented to delete a key.\nHowever, it will be possible to update a key and marking it as unused.\nNote I haven't gotten the permission to make these changes as it's only available under the GNU license. If you have permission I can help to add/improve the documentation."},{"title":"UpgradableProxy can be reentrancy attacked when upgradeTo is called","severity":"MEDIUM","mitigation":"Adding a reentrancy guard to the upgradeTo function."},{"title":"All Direct Function Calls Emitted via Bridge Not Relayable","severity":"MEDIUM","mitigation":"Replace the EIP2771 function signature (including any `value` or `gas` at the end of the input) with its respective keccak256 hash, **and** use 120000 gas for any external calls made using `functionCall`."},{"title":"Reentrancy in `ProxyAdmin` can drain the forwarding address","severity":"MEDIUM","mitigation":"Always allocate enough gas for calls made from `upgradeToAndCall`."},{"title":"P3: External admin is still able to do stuff in injectiveDax even in circuit breaker","severity":"MEDIUM","mitigation":"Change _admin function to Other: @none and Other: @nothidden\n\n#"},{"title":"`EtherTulipsDiamondProxy` should have the same `setMax` checks as `EtherTulipsBaseDiamond`","severity":"MEDIUM","mitigation":"Think about the checks on `setMax`."},{"title":"Unachievable recovery of bugs","severity":"MEDIUM","mitigation":"OpenZeppelin suggests setting the `owner` and `admin` roles with create2, but that's not unachievable and may significantly increase the cost of the exploit chain, hence reducing the attack surface by default."},{"title":"Admin can be bruteforced to death, killing the user and himself","severity":"MEDIUM","mitigation":"The recommended approach is to still differentiate the fallback function behaviour based on the sender first and then domain separator when `msg.value` is zero.\n\n***"},{"title":" Admin control is not suffieciently protected against usage from the contract itself and its progeny","severity":"MEDIUM","mitigation":"Even better than using msg.sender and blockhash, is to use Create2 to launch the contract to a non-deterministic address with a predictable overhead, and a time delay (or a block delay worth of block seals) to commit the contract creation, and trustee signatures.\n\n#"}]