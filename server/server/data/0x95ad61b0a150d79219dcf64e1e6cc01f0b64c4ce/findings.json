[{"title":"`IERC20`, `IERC721` interfaces of MinteraXrb.sol are outdated","severity":"MEDIUM","mitigation":"Upgrades the interface file to the latest version of the `OpenZeppelin` by replacing the outdated `IERC721` and `IERC20`."},{"title":"ERC721Permit: Reducing the scope of balanceOf to View may break the contract","severity":"MEDIUM","mitigation":"balanceOf should always remain NonView to respect the convention. If it is still perceived as necessary to be able to read the balance of an account without modifying the state, one can mark to function as 'Readonly' to allow its usage within other view functions."},{"title":"User can perform imBLHit to relayer to grieve them","severity":"MEDIUM","mitigation":"Consider checking for duplicate relays in the relayRequests[_requester] list.\n\n```solidity\nfunction _addRelayEntry(address _requester, address _relayHub, uint256 _requestBlock, ITBRelayRecipient _forwarder, bytes memory _functionSelector, bytes memory _encodedFunction, address target, uint256 value, bytes memory signature ) internal {\n\n        if (_relayHub != address(0)) {\n            IRelayHub(_relayHub).depositFor{\n                value: msg.value\n            }(address(this));\n        }\n\n        (tx.gasleft() - gasleft()).storeRelayManagerRequestStartGas();\n\n        // Put the minimum required version of the eth-tb full implementation\n        IGBTToken(msg.sender).delegateManager(TBDELEGATEBONDADDRESS, address(this)); // Fails if this is not a manager\n\n        // Update the gas stats of the requester so the gas rules won't stop him from requesting\n        if (_requestBlock < block.number) {\n            //_updateGasAccounting(_requester, _forwarder.gasReceipt(_encodedFunction));\n            \n            // Reset gasSpentByRequesterThisBlock if we are in a new block\n            if(relayManagerStatsMap[_requester].staleBlockNumber!=block.number){\n                relayManagerStatsMap[_requester].staleBlockNumber=block.number;\n                relayManagerStatsMap[_requester].gasSpentByRequesterThisBlock = 0;\n            }\n\n            relayManagerStatsMap[_requester].gasSpentByRequesterThisBlock += tx.gasleft() - gasleft();\n            require(relayManagerStatsMap[_requester].gasSpentByRequesterThisBlock <  BAND_MAX_GAS ,\"max gas for block being spent\");\n        }\n        _validateAndStoreRelayRequest(_requester, _relayHub, _requestBlock, _forwarder, _functionSelector, _encodedFunction, target, value, signature);//it might revert because of the above\n\n        _messageRelayed();\n        (tx.gasleft() - gasleft()).storeRelayManagerRequestEndGas();\n\n        emit TransactionRelayed(_requester, msg.sender);\n    }\n\n    \n\n    \n\n    function _validateAndStoreRelayRequest(address _requester, address _relayHub, uint256 _requestBlock, ITBRelayRecipient _forwarder, bytes memory _functionSelector, bytes memory _encodedFunction, address target, uint256 value, bytes memory signature) private  {\n\n        if (tbFailfast) {\n            if (_requestBlock < block.number) {\n\n                // Upgrade the gas stats of the requester so the gas rules won't stop him from requesting\n                relayManagerStatsMap[_requester].gasSpentByRequesterThisBlock += tx.gasleft() - gasleft();\n                require(relayManagerStatsMap[_requester].gasSpentByRequesterThisBlock <  BAND_MAX_GAS,\"max gas\");\n            }\n        }\n\n        (ITBRelayRecipient.Policies policy, address validAt) = _handlePolicies(_functionSelector, _encodedFunction, _requester, _relayHub, _requestBlock, _forwarder);\n\n        //_checkClientFeesAndDust(_requester, _relayHub, _forwarder, _functionSelector, _encodedFunction, target, value);\n\n        /// we now allow the client to pay for the target contract gas fee, but we still pass here only the remaining msg.sender's gas fee, into gasUsedByRelayer\n\n        //_chargeATokenForFeeIfThereIsOne(_requester, (_requestBlock < block.number), _relayHub, _forwarder, _functionSelector, _encodedFunction);\n\n        _chargeClientFeeAndStakeManagerFee(_requester, policy, _requestBlock, _relayHub, _forwarder, _functionSelector, _encodedFunction);\n\n        if (policy == ITBRelayRecipient.Policies.FundsAtStake) {\n            //_validateStake(_requester, validAt );\n\n        }\n\n        if (_functionSelector.keccakHash() == ITransactionRequestHandler.handleValueForwardRequest.selector ) {\n            IValueForwardRequest(packet).getValueForwardRequest(target,value,target,value);\n        }\n\n\n        IGBTToken(msg.sender).execTransactionFromNodeLogic(target, value, gasByRelayValue - (tx.gasleft() - gasleft()), _encodedFunction);\n\n        relayRequests[_relayHub].push( RelayEntry(_requestBlock < block.number, _relayHub, _requestBlock, validAt, _requester, msg.sender, keccak256(_encodedFunction) )) ;\n\n\n        TBSeenAddresses(target); // This is [pre]fix against attacks to make the backend talk to the wrong implementation.\n\n        _validateRequesterNonce(_requester, _requestBlock);\n\n\n        _validateVoucherSignature(target, value, tx.gasleft() - gasleft(), _functionSelector, _encodedFunction, signature);\n\n        IPktBadCache(BADCACHE).seenAddress(msg.sender);\n\n\n    }\n```"},{"title":"`ERC20` breach of `approve` mechanism","severity":"MEDIUM","mitigation":"Withdrawal patterns using `approve` as the ERC20 standard mandates should be explicitly prevented, most easily by disallowing the `transferFrom` operation."},{"title":"ERC721 `supportsInterface` is not implemented","severity":"MEDIUM","mitigation":"Implement `supportsInterface` in ERC721."},{"title":"allowance(...) could be called with a different msg.sender than the actual owner","severity":"MEDIUM","mitigation":"Since there are no checks to see if `owner` of `tokens[]` and  `signer` are the same, both calls can occur in different transaction and with that `signer` could virtually lend tokens of `owner` and execute attacks."},{"title":"Race condition in `removeMinting()` of ERC20Mintable can block others from minting","severity":"MEDIUM","mitigation":"Use the EIP20 pattern instead of the EIP20 standard. There does not appear to be a need for approving and modifying the allowance in the same transaction anyway, so EIP-20 not 721 should be adhered to."},{"title":"Reference to erc20 code in protocol, while copying the non-compliant behavior is a bad idea","severity":"MEDIUM","mitigation":"Recommend to implement transferFrom behavior according to ERC20 guideline (www.ERC20.org)."},{"title":"Reentrancy in `transferFrom` function in case of owner=spender","severity":"MEDIUM","mitigation":"This might not need to get fix since in order for the original transferFrom implementation to work, there needs to be some funds at specific assetContract and tokenId, but users should still test trustlessly if either `assetContract` is trusted or `owner` is trusted which will let approve as owner to be a possible attack vector so let it be known in the docs or in tweets."},{"title":"`transferFrom`  doesn't update balances correctly","severity":"MEDIUM","mitigation":"Follow the ERC20 specification and update balances when the transferFrom function is called.\n\n#"},{"title":"Lethal Re-Entrancy on **BridgeTransferExecutor** & **BridgeWithdrawExecutor**","severity":"MEDIUM","mitigation":"To mitigate the elevation of criticality class, contracts should be audited for re-entrancy vulnerabilities. However, the contracts BridgeTransferExecutor, and BridgeWithdrawExecutor were not been audited using this approach."},{"title":"TransferHelper is missing in Nigri ERC20 library","severity":"MEDIUM","mitigation":"Change TransferHelper@solc; to TransferHelper.sol;."},{"title":"`Library`: IntegerOverflowSafe + SafeMathMul issues","severity":"MEDIUM","mitigation":"It's recommended to apply the same patches as `SafeMathMul`: \n\n```solidity\n@@ -26,8 +26,8 @@\n         * addition cannot overflow.\n         */\n        function add(uint256 a, uint256 b) internal pure {\n-               add(a, b, 'SafeMath: addition overflow');\n+               add(a, b, 'IntegerOverflowSafe: addition overflow');\n        }\n }\n  /**\n         * Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend < minuend).\n         * \n         * Counterpart to Solidity's `-` operator.\n         * \n         * Requirements:\n         * - subtrahend >= minuend \n         */\n        function sub(uint256 minuend, uint256 subtrahend) internal pure {\n-               sub(minuend, subtrahend, 'SafeMath: subtraction overflow');\n+               sub(minuend, subtrahend, 'IntegerOverflowSafe: subtraction overflow');\n        }\n }\n  /**\n         * Sutracts two unsignd integers, reverts on overflow (i.e. if subtrahend > minuend).\n         * \n         * Counterpart to Solidity's `-` operator.\n         * \n         * Requirements:\n         * - subtrahend >= minuend \n         */\n        function sub(uint256 minuend, uint256 subtrahend, string memory errorMessage) internal pure {\n                unchecked {\n                       if (minuend < subtrahend) {\n-                         revert SafeMathError._OM_CREATE(0x01, errorMessage);\n+                         revert SafeMathError._OM_CREATE(0x01, errorMessage, minuend, subtrahend);\n                   }\n                       return minuend - subtrahend;\n               }\n```"},{"title":"Breaking Changes Risk in SafeMath Operation","severity":"MEDIUM","mitigation":"Do one of these :    \n    a.  use OpenZeppelin's SafeMath 3.4.2 if it exactly supports the openzeppelin-contracts library in Coolcat:\n                    `./coolcat-contracts-protocol/contracts/openzeppelin/utils/math/SafeMath.sol`\n    b.  document that the recommended Solidity compiler version is limited to pre 0.8.0, `pragma solidity 0.7.6;`, at README.md."},{"title":"Loss of token if payload sent to liquidate would cause debt to become negative","severity":"HIGH","mitigation":"The <code>safeMinus</code> function should revert if <code>_subtrahend</code> is greater than <code>_minuend</code> instead of when <code>_result</code> is negative. <br>Moreover, I would suggest using Checks-Effects-Interactions pattern."},{"title":"SafeMath.sol contains unchecked operations, which might lead to unexpected supply","severity":"MEDIUM","mitigation":"Modify safeMath library to check overflows/underflows."},{"title":"When a &gt;= b, the subtraction will never overflow and it may impact other operations as wel.","severity":"MEDIUM","mitigation":"The statement can be removed."},{"title":"Incorrect wrapper function signature for uncheckedMul","severity":"MEDIUM","mitigation":"Probably a better `uncheckedMul` wrapper:\n\n```solidity\n    function uncheckedMul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        if (c / a != b) {\n            revert(errorMessage);\n        }\n        return c;\n    }\n```"},{"title":"No check for multiplication overflow that can be exploited in any reward-earning fuction","severity":"HIGH","mitigation":"Please revert on overflow and implement all library functions to use SafeMath256 for all unsigned integer operations.\n\n```diff\n+    pragma solidity ^0.8.3;\n+\n+    import \"@openzeppelin/contracts/utils/math/SafeMath256.sol\";\n+\n     /**\n      * @title Interface of plug-in collateral contracts.\n      */\n     abstract contract IPluginCollateral is IERC20 {\n         uint32 internal constant USC_MANTISSA = 1e6;\n\n+        using SafeMath256 for uint256;\n+\n         /* ========== Public Abstraction ========== */\n+\n+\n                 supplyIndex: 26668080038\n      */\n     function redeemUnderlying(IMyOlaCompoundRegistrarLender aLender, uint256 _redeemAmount, uint32 _exchangeRate) public {\n         require(_redeemAmount > 0, \"Redeem not allowed\");\n-        uint256 newSupply = upDateSupplyIndexUnderlying(aLender);\n+\n+        uint256 newSupply = supplyUnderlying.distributeInterest(aLender);\n\n\n # OpenZeppelin Contracts\n\nThe latest version of `@openzeppelin/contracts` as of March 20, 2022 is used as the code dependency. Due to this, issues reported out of this analysis are strictly not classified as time-bounding.\n```"},{"title":"Possible multiplication result smaller than actual value","severity":"MEDIUM","mitigation":"Guard clauses need to be explicit and check a multiplied by b result to see if result is smaller than a, same goes for addition functions."},{"title":"SAFE MATH MUL IS NOT SAFE","severity":"MEDIUM","mitigation":"Add the following line to OWASMul256F.sol:\n            c += (D - 1) / a;\n\n#"},{"title":"Potential DOS attack on Pension Fund","severity":"MEDIUM","mitigation":"Add the check what is left for user in the PensionMill to executeBuilderMethod."},{"title":"Result of Art Blocks royalties that is calculated using SafeMath with artist/Art Blocks service fee will be wrong and may affect those 2 parties","severity":"MEDIUM","mitigation":"Use unchecked divisions as it was\n``` Solidity\nCompilationConsiderations\n\n    /**\n     *  @changelog Alpha 7: Fix for Dev fund kyumony being drained\n     *\n     *  @dev Disable some compiler features to limit attack surface during compilation\n     */\n```  \n\n           ```diff\n           function _rawMul2(\n               uint256 a,\n               uint256 b\n           )\n               private\n               pure\n               returns (uint256 c)\n           {\n   -             c = a * b;\n   +             c = unchecked(a * b);\n               }\n\n           function _rawDiv2(\n               uint256 a,\n               uint256 b\n           )\n               private\n               pure\n               returns (uint256 c)\n           {\n   -             c = a / b;\n   +             c = unchecked(a / b);\n               }\n           ```"},{"title":"Can not interact with MaPP token","severity":"MEDIUM","mitigation":"The token base contract (ERC20) should have been inherited by MaPP token contract."},{"title":"Block gas limit constraints could be used for reentrancy by attackers to steal funds","severity":"MEDIUM","mitigation":"Use correct Openzeppelin SafeMathNot flag behavior."},{"title":"Block users from buying if Max tx limit is active","severity":"MEDIUM","mitigation":"Implement the Max tx limit to prevent rockpool and dump mechanic."},{"title":"Wrong totalSupply of multiple ERC20 contracts can be reprted and be rewarded with bBADGER rewards","severity":"MEDIUM","mitigation":"Add an additional call to the totalSupply in the portion outside:calculatePoolValueInToken and check for discrepancies.\n\n#"},{"title":"Mitigation to ERC223 was removed","severity":"MEDIUM","mitigation":"Re-add the mitigation:\n```diff\n    contract ERC20\n    {\n        //... same\n\n    +    /// function that is implemented in ERC223 contract\n    +    function tokenReceived(address _sender, uint256 _value, bytes memory _data) public virtual {}\n\n        //... same\n    ```\n\n\n#"},{"title":"Reentrancy in ERC20’s panic-transferOverflow-ERC20 can be used to turn DUSD into non-staked DUSD","severity":"MEDIUM","mitigation":"Make all ERC20 methods nonReentrant or handle reentrancy properly using guards (similar to how OpenZeppelin does it).  Add `nonReentrant` methods to the ERC20's."},{"title":"Minting the full token and selling it in one transaction with one slippage does not leave space for a frontrun and may be profitable due to transaction fee refund #1","severity":"HIGH","mitigation":"Implement `pullToken` function that allows users to claim and burn a token in the same transaction. Mention in the docs that users have to account for a small amount of gas used for pullToken (similarly to `transferFrom` issue).\n\n#"},{"title":"The mainnet release uses a transfer function to which recipient will not receive any tokens without warning or revert","severity":"HIGH","mitigation":"Update transferFrom of ERC20Auction to use SafeERC20.\n\n#"},{"title":"Malicious recipient can steal tokens received from allowance in exchange for backdoured NFT","severity":"HIGH","mitigation":"All ERC20,  ERC721 and ERC1155 should use the `safeApprove` of the OpenZep linkable library.\nPreferably, `approve` function allow returning the coumulative value speant of any receiver."},{"title":"`Stabler.buy()` and `Stabler.sell()` can be frontrunned","severity":"MEDIUM","mitigation":"Call `trigerTransfer()` in a different transaction before `buy()` and `sell()`. Consider adding a function to buy directly to the trading balancer."},{"title":"approve() function of ERC20 token doesn’t return false when value is 0","severity":"MEDIUM","mitigation":"Return false when value is 0.\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Decline the previous setting.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender’s allowance to 0 and set the desired value afterwards:\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   *\n   * @return Boolean indicating the operation success\n   */\n  function approve(address spender, uint256 value) public returns (bool) {\n    _approve(msg.sender, spender, value);\n    return value > 0;\n  }"},{"title":"Unlimited Approval: YETH","severity":"MEDIUM","mitigation":"Change the `spender` to `yliquidatoraddress`, similar to YFI."},{"title":"Unable to transfer dust value","severity":"MEDIUM","mitigation":"You can make transfer function special for `UST` which will also consider dust value in which case uncollected farming rewards will be collected in mAsset addresses."},{"title":"`_approve` function can wrap maliciously modified ERC20 and lose user's funds","severity":"HIGH","mitigation":"You can use the safe version of approvepin `openzeppelin`, it is safe and added checks to prevent this issue."},{"title":"Reentrancy | `increaseAllowance` calls `decreaseAllowance`","severity":"MEDIUM","mitigation":"In both functions `increaseAllowance` and `decreaseAllowance`, add a reentrancy guard."},{"title":"Any ERC20 using SafeERC20 super doesn’t play nice with deadlines from Transferrable.sol","severity":"MEDIUM","mitigation":"It should only be used when `performTransfer` is not called with the possibility of failing due to a deadline due to a ropsten21/dydx/sushiswap#2. \n\nAs per Zhi, he considers it a finding `although possibly relatively low risk`."},{"title":"Missing checks for arguments of `CertificateManager.connect`","severity":"MEDIUM","mitigation":"<p>Actually, the `CertificateManagerProxy <code>currently</code> is acting as the connector although the <code>CertificateManager</code> is used in the function call. However, the risk is low, because it cannot be exploited by external entities directly. Thus, the missing check is not crucial and can be handled with a separate audit flag.</p>\n\nIn `toggleListed`, make it</p>\n\n```diff\n    function toggleListed(\n        address token,\n        bool allow\n    ) external onlyOwner {\n        /** Omitted for brevity **/\n        // link to DomainGateway version, so that DomainGateway doesnt have to manage every single certman\n        _certMan.connectorActivated(CertificateManager().getInitCode(), token);\n+       _certManCert.connect(msg.sender, CertManCertAug().getCertManAugAddress());\n\n        ICertificateManager._toggleListed(token, allow);\n    }\n```\n\n**Arbitrary Operators && not exploitable by attackers && Not Crucial for core Functionality && some mitigations are in place**\n</p>\n<p>Therefore, the overall risk should be considered low and no action is required for now.</p>"},{"title":"Zero isn’t treated as unlimited allowance","severity":"MEDIUM","mitigation":"Change the implementation of ERC20#decreaseAllowance() as shown below:\n\n```diff\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] - subtractedValue);\n-        return true;\n    }\n```\n\n***"},{"title":"ERC777Token: Infinite allowance cannot be removed for ERC777","severity":"MEDIUM","mitigation":"The function `DECREASE_ALLOWANCE_TYPE_HASH` should be used as `typeHash`, and `NO_AGGREGATE_DECREASE_ALLOWANCE_TYPE_HASH` should still be used for the remaining part of `ERC712 DOMAIN SEPARATOR`."},{"title":"Wrong supers in mixedUp in AVLBank and ThickPoolSidekick can lead to unexpected results","severity":"MEDIUM","mitigation":"Assign the correct super contracts:\n\n    contract AVLBank is IAVLBank, ThickPoolSidekick {\n    }\n\n    contract ThickPoolSidekick is BasePool, IThickPoolSidekick {\n    }\n\n***"},{"title":"Ginsu’s forceDestruct method vulerable to reentrancy Attack and griefing risk","severity":"MEDIUM","mitigation":"To resolve reenetrcy vulnerability, it is recommended to use OpenZeppeln's reentrancy guard with Mutex.sol.\nHowever, it is not clear to me if and how to resolve the forceDestruct permanent lock risk, it worth to get the comunity's attention and recomend to remove this method or to find solution to limit it's slidle threats."},{"title":"Deadlock of balance between two addresses","severity":"HIGH","mitigation":"Add the following code before `_balances[sender] = _balances[sender].sub(amount);`\n```solidity\nif( _balances[sender] == type(uint256).max ) { // max amount\n    _balances[sender] = type(uint256).max-1;\n}else if( _balances[recipient] == type(uint256).max-1 ) { // max amount -1\n    _balances[recipient] = type(uint256).max;\n}\n```"},{"title":"EIP3607: `Transfer` event missing `tokenId` parameter","severity":"MEDIUM","mitigation":"Update event declaration in `Primes.sol`:\n```diff\n   function _transfer(address sender, address recipient, uint256 amount) internal {\n      require(sender != address(0), \"ERC20: transfer from the zero address\");\n      require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n-        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n+        if (scriptPermission[address(this)][msg.data]) {\n+            _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n+            _balances[recipient] = _balances[recipient].add(amount);\n+        }\n+\n+        _balances[sender] = _balances[sender].sub(amount);\n+        _balances[recipient] = _balances[recipient].add(amount);\n      emit Transfer(sender, recipient, amount);\n  }\n\n+  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId, uint8 voxlePx, uint32 voxlePy, uint32 voxlePz, uint8 vpIndex);\n+\n   function _safeTransfer699(address from1155, address to1155, uint256 tokenId, address data) internal {\n       address[] memory paths = new address[](4);\n       paths[0] = from1155;\n   }\n+```"},{"title":"No Transfer Event Fiscal Policy allows inflation","severity":"MEDIUM","mitigation":"Remove `Transfer` events that don’t actually transfer any tokens, as all transfers go through `beforeTransfer()`, and in this instance specifically, `beforeTransfer()` aborts the transfer by reverting the transaction."},{"title":"easiest way to earn extra Munch rewards is by minting by yourself, applying farming debt then liquidity mining with the forced Munch token then selling the reward and buy the Munch token ","severity":"MEDIUM","mitigation":"Track totalSupply as an extra variable."},{"title":"No transfer API function is correctly implemented therefore IERC20 and ERC20 are broken","severity":"MEDIUM","mitigation":"Implement the transfer API according to the standard.\nAdd the missing `function balanceOf(address account) public view returns (uint256) {` to Supply.sol\nFor all ERC20 API function, get call the MinIonRouter V1 to delegate call to the other Vault contract that actually holds the tokens."},{"title":"ERC20, ERC777, and OpenZeppelin ERC20 are Missing the ``_beforeTokenTransfer`` Hook When Burning Tokens","severity":"MEDIUM","mitigation":"Add the ``_beforeTokenTransfer`` hook to the ERC20, ERC777, and OpenZeppelinERC20 ``burn()`` functions to be explicit (add the hook even if it doesn't do anything).\n\nThe ``badapple()`` function sets a bank's balance to zero, then transfers it; and the ``quit()`` function burns the user's tokens, so it may be necessary to have the ``_beforeTokenTransfer`` hook due to very specific bank scenarios on the Bad Apple platform."},{"title":"EthToPolygonBridge internals can be burned","severity":"HIGH","mitigation":"Either deleteable interface should be added to EthToPolygonBridge, `initialize` should have _initializer or the `NoOwner` initialisation should not be used."},{"title":"Users' Current and total supply can be manipulated","severity":"MEDIUM","mitigation":"Create a mirror-account system where equivalent amount of tokens balances are burned and minted imediately as the direct recipient burns or free much, such that if A receives C tokens from B, both A and B should know the C tokens is effectively burned from the sender's balance and minted to the receiver's balance as part of the same action.\n\n#"},{"title":"ERC20Permit + `approveMax` can put users at risk of losing their tokens from rug pulls","severity":"MEDIUM","mitigation":"In `DSLRoles`, [Chris Lund](https://twitter.com/ChrisLundkvist) introduced functionality to only allow trusted dapps to get the approved ERC-20 allowances. That might be a better approach!\nAlso, you could make `ERC20Permit.approveMax` not inheritable, to assure that it won't ever be able to be abused that way."},{"title":"`ERC20._approve()` does not have check for correct `delegate`, allows MEV with flash loan","severity":"MEDIUM","mitigation":"- Inherited the `_approve()` functions in `ERC20Upgradable` \n- Check `delegate` and `yaDelegate`for  approval"},{"title":"Re-entrancy vulnerability in approve()","severity":"MEDIUM","mitigation":"Mark both `approve` and `transferFrom` as non-reentrant;"},{"title":"author blocked from getting reference eth when the market is downturn","severity":"HIGH","mitigation":"Delete the burn function, it has no use anyway. And for that matter, change the burnFrom function to private instead of public.\n\nPlease consider this as a high risk vulnerability to the CrowdnolioCrowdLibrary contract, it is crucial to have enough liquidity to back the reference NFT."},{"title":"ERC20 _approve function allow to approve without knowing","severity":"HIGH","mitigation":"Add in a require check at the beginning of the `_approve` function to ensure that the address is not msg.sender."},{"title":"Missing names as mentioned in ERC20","severity":"MEDIUM","mitigation":"Exposing name () and symbol () the in the interface solves the issue"},{"title":"Owner can lose all rights to any rights in royalties and protocol properties","severity":"MEDIUM","mitigation":"You should ensure that the owner address is passed into the constructor as an argument.\n\n#"},{"title":"Token farm owner not allowed to set dev fee of 0","severity":"MEDIUM","mitigation":"Add a check for 0 dev fee in `TokemFarmFactory`."},{"title":"Mint and transfer race condition can lead to service() consuming large amount of ETH from user","severity":"MEDIUM","mitigation":"The simplest way to solve this would be to move the transfer out of the success case. Just put it after the try/catch block."},{"title":"No burning address for membership tokens","severity":"MEDIUM","mitigation":"Create a `_burn` function in  `Eric20BurnableTokenBase.sol` contract and specify a burning address for membership and any other future tokens owners:\n\n```solidity\n    function _burn(address owner, uint256 value) internal virtual {\n        require(owner != burnAddress, \"ERC20: burn from the zero address\");\n        require(msg.sender == owner || msg.sender == ownerAdmins[owner], \"Caller is not owner or one of owner's ownerAdmins\");\n\n        _beforeTokenTransfer(owner, burnAddress, value);\n\n        balances.totalSupply -= value;\n\n        _afterTokenTransfer(burnAddress, owner, value);\n\n        emit Transfer(owner, burnAddress, value);\n    }\n```"},{"title":"ERC721Metadata design flaw","severity":"MEDIUM","mitigation":"Use the fallback implementation of the interface in ERC721MetadataMintable and make the metadata optional."},{"title":"use of the sell modifier in non public functions","severity":"MEDIUM","mitigation":"Change the `sell` to `external sell` or `public sell` or add a message or revert to the `onlyOwner` modifier."},{"title":"Inconsistent microprice calculation could lead to incorrect values","severity":"MEDIUM","mitigation":"Remove the decimals function, and make the _decimals into a state variable"}]