[{"title":"Cronus: `SafeMath.mul(uint256 a, uint256 b)` should be be declared as `pure`","severity":"MEDIUM","mitigation":"Declare `SafeMath.mul(uint256 a, uint256 b)` as `pure`:\n\n```diff\n+library SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  ..."},{"title":"All optimsations in SafeMath should be implemented properly since SS_VAR isn’t implemented and in the previous versions certain checks were wrong","severity":"MEDIUM","mitigation":"Implement all optimisations properly."},{"title":"Arithmetic being used without checking for overflow","severity":"MEDIUM","mitigation":"Consider adding overflow checks to this app and fail early if it fails."},{"title":"Differences exist between the internal add and mul vs the external Solidity functions exponentsafeadd and exponentsafemul in AToken and LendingPool. Call relationship is confusing.","severity":"MEDIUM","mitigation":"Update the comments in the add / sub / mul / div functions in AToken and LendingPool."},{"title":"Possible reentrancy in `ERC20` transfer function","severity":"MEDIUM","mitigation":"Add the [ReentrancyGuard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.4.0/contracts/security/ReentrancyGuard.sol) shield to the `ERC20.transfer` function."},{"title":"ERC677 contract does not comply the ERC20 standard","severity":"MEDIUM","mitigation":"Fix the function signature based on the ERC20 recommendation https://eips.ethereum.org/EIPS/eip-20\n\n```solidity\nfunction allowance(address _owner, address _spender) constant returns (uint256);\n```"},{"title":"`Transfer` event in ERC20-compatible BasicToken may be missing `Intended Receiver` field","severity":"MEDIUM","mitigation":"Adapt from EIP-677:\n\n```diff\n  event Transfer(address indexed from, address indexed to, uint value);\n+ event Transfer(address indexed from, address indexed ti, uint value, bytes data);\n\n  function transfer(address _to, uint _value) returns (bool)\n  {\n  //Standard stuff...\n  +  Transfer(msg.sender, _to, _value, \"\");\n  }\n+\n  function transferFrom(address _from, address _to, uint _value)\n  {\n  //Standard stuff...\n  +  Transfer(_from, _to, _value, \"\");\n  }\n+\n  function transferByCode(address _to, uint _value, uint32 _destChainId, address _destContract)\n  {\n  //Standard stuff...\n  +  Transfer(_from, _to, _value, abi.encode(_destChainId, _to, _destContract))); \n  }\n  ```"},{"title":"EIP1132 Takeover Vulnerability","severity":"MEDIUM","mitigation":"Add \no@dev transfer token for a specified address\ndont transfer to `address(0)` and `contract` \n\n```diff\ndiff --git a/src/tokens/EIP1132Token.sol b/src/tokens/EIP1132Token.sol\nindex 703605d..c29ff4a 100644\n--- a/src/tokens/EIP1132Token.sol\n+++ b/src/tokens/EIP1132Token.sol\n@@ -70,7 +70,10 @@ contract EIP1132Token {\n   }\n\n   mapping(address => uint256) balances;\n+    mapping(address => uint256) forzenBalances;\n\n+    \nevent Transfer(address indexed from, address indexed to, uint256 value);\n+    event TransferFrom(address indexed operator,address indexed from, address indexed to, uint256 value);\n\n   /**\n   * @dev transfer token for a specified address\n```"},{"title":"Robustness of mappings required by the ERC721Standard interface","severity":"MEDIUM","mitigation":"Consider returning 0 in case of a non existing token instead of reverting the transaction:\n```\n    function balanceOf(address _owner) external view override returns (uint256) {\n        return _ownedTokensCount[_owner];\n    }\n```\nand similarly, for the function `getApproved`, handling the default value of the mapping.\n\n#"},{"title":"Denial of Service via Token Frontrun to Drain User Funds","severity":"MEDIUM","mitigation":"To prevent frontrun attack it is recommended to the devs to include a `revert` jump in the core of the `transfer` function if the `amount` to be transferred is less than the fee.\n\n#"},{"title":"ERC20.allow() is enforced with `max()` making single call to .allow() a privilage escalation","severity":"HIGH","mitigation":"Don’t use `max()`. You will have to revert when someone tries to approve more than their full balance but less than their previous approval."},{"title":"Reentrancy vulnerability when transferring ERC20 tokens","severity":"HIGH","mitigation":"Add a reentracyGuard in the transferFrom() function of the ERC20 contract as follows. \n\n    function transferFrom (address _from, address _to, uint256 _value)\n      public\n      override\n      returns (bool)\n    {\n      require (_to != address(0));\n      require (_value <= balances[_from]);\n      require (_value <= allowed[_from][msg.sender]);\n\n      balances[_from] = balances[_from].sub(_value);\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n      balances[_to] = balances[_to].add(_value);\n\n      emit Transfer(_from, _to, _value);\n\n      return true;\n    }"},{"title":"Erc20 transfer from() does not check input address properly","severity":"MEDIUM","mitigation":"Delegate to an EIP-717-style function that asks the user for a signature, never use msg.sender for anything important"},{"title":"Current Crowdsale is not ERC223/ERC677 compliant","severity":"MEDIUM","mitigation":"Change the approve signature to follow ERC20 standard and implement the 'transferFromAndCall()' from ERC223."},{"title":"crowdfunding: not inheriting approve() / increaseApproval() / decreaseApproval() from StandardToken as it should","severity":"MEDIUM","mitigation":"Have Crowdfunding inherit all functions that CrowdsaleBase does from StandardToken and ~ProgressiveFundraisingWithSoftcapCrowdsaleBase."},{"title":"Adherence to ERC-20 token standard specification recommendation to implement ERC-165 in future version","severity":"MEDIUM","mitigation":"It is recommended that in future versions `ERC165` should be inherited in `TomatoCoin` and supported for the `ERC20` interface."},{"title":"ERC20 holds low netive balance","severity":"MEDIUM","mitigation":"Just remove the onlyIfAllowed modifier."},{"title":"Delegation to initial zero-address not disallowed.","severity":"MEDIUM","mitigation":"Delegating to address 0 should not be allowed."},{"title":"ERC20DSSafe subtraction overflow checks are not implemented properly","severity":"HIGH","mitigation":"Change function `decreaseAllowance`'s `value` to type `int256` and apply `safeAdd` checks for `_subtractedValue`.\n\n\n        function decreaseAllowance(address _spender, uint value) public\n            returns (bool)\n        {\n            int256 oldValue = allowed[msg.sender][_spender];\n\n            if (int256(value) > oldValue) {\n                allowed[msg.sender][_spender] = 0;\n            } else {\n                allowed[msg.sender][_spender] = oldValue.sub(int256(value));\n            }\n\n            emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\n            return true;\n        }"},{"title":"A spender can take more than 8589934590 tokens by proposing allowance of uint256 max","severity":"MEDIUM","mitigation":"Use `type(uint96).max` as `uint96`'s max value on Rv1 contracts, and `type(uint256).max` for Rv2 contracts."},{"title":"DO NOT USE transferAndCall and onTokenTransfer() to incentivize staking in AVM Ethereum","severity":"MEDIUM","mitigation":"A better fix is:\n```solidity\n    function transferAndCall(address _to, uint _value, bytes _data)\n        public\n        returns (bool success)\n      {\n        super.transfer(_to, _value);\n        TokenReceiver(_to).onTokenTransfer(msg.sender, _value, _data);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n      }\n```"},{"title":"Sending ERC777 to an Externally-Owned Account (EOA) will result in the loss of funds","severity":"HIGH","mitigation":"The transfer itself should be reverted, if `_to` is an EOA."},{"title":"`Token.transfer(..)` must follow ERC777 specification","severity":"MEDIUM","mitigation":"Accept the address param for known ERC677Receiver and call it directly.\n\n```diff\n+  function send(address to, uint256 value, bytes calldata data) public override {\n+    if (!isContract(knownReceivers[address(to)])) return super.send(to, value, data);\n+\n+    ERC677Receiver receiver = ERC677Receiver(knownReceivers[msg.sender]);\n+    receiver.onTokenTransfer(msg.sender, value, data);\n+  }\n\n+  mapping(address => address) knownReceivers;\n+  function registerERC677Receiver(address receiverAddress) external {\n+    knownReceivers[receiverAddress] = address(ERC677Receiver(receiverAddress));\n+  }\n+};\n```\n\n\n***"},{"title":"Reentrancy to a precompiled contract","severity":"MEDIUM","mitigation":"Prevent the Reentrancy to precompiled contracts, for example by adding handling for `CALL` and other methods that permit hopping in and out of the caller contract. This will ensure developers that only the specified methods are being called."},{"title":"Not so much of a critical severity but more recognizable, the LinkToken contract does not adhere to the ERC20 protocol.","severity":"MEDIUM","mitigation":"During the creation of an ERC20 contract spend the end supply to the contract address if you want the mentioned behavior. Most probably, you will not want that behavior but mathematically supply for any token contract will not balanced if you do not do this."},{"title":"`LinkToken`: Deposits for `linkBalance[]` added twice","severity":"MEDIUM","mitigation":"Put the code which credits the user's ``linkBalance[]`` tokens in the end, when balances are already properly recorded."},{"title":"Re-entrancy attack can be performed on transferAndCall()","severity":"MEDIUM","mitigation":"Use `msg.sender.transferFrom(msg.sender, to, value, data);` instead of Solidity's native `call` for the transfer call execution."},{"title":"Functional deficiency for multiSig NFT addresses sending","severity":"MEDIUM","mitigation":"In defining the transferAndCall, set a condition to not call the parent transferAndCall if **_data** length is less than 1."},{"title":"Legacy ERC20 allows transferring 0 tokens","severity":"MEDIUM","mitigation":"The bug can be fixed by add a check of transfer value is larger than 0."},{"title":"Collision on transferAndUpdateFreezeBlock may lead to fund loss","severity":"MEDIUM","mitigation":"At least compiler version check is needed and also possible usage of Pausable._pause() to minimize the window of the potential vulnerability is also a good practice."},{"title":"ERC-20 approve does not have the recommended ERC-20 approve & call function","severity":"MEDIUM","mitigation":"* Deploy the recommended [ERC-20 approve & call interface](https://eips.ethereum.org/EIPS/eip-20)"},{"title":"Bypass of allowlist restrictions in approve/unapprove functions","severity":"HIGH","mitigation":"Add additional validation in `approve` and `unapprove` functions:"},{"title":"ERC20 Token implementation not fully compliant with the standard","severity":"MEDIUM","mitigation":"Make the `_from, _to, _value` parameter variables `internal` which is ERC-20 recommended"},{"title":"OpenZeppelin proposal: do not include `validRecipient` in `ERC20`","severity":"MEDIUM","mitigation":"The `validRecipient` modifier, at least as its behavior is documented today, should not be included in the `ERC20` base class. However, it could still be used in the more permissive `ERC777`, where not as many assumptions are made. The inheriting contract would be responsible for ensuring that the recipient is valid, including any additional checks relevant to the context in order to prevent any security vulnerabilities."},{"title":"RenewableSynth not pausable","severity":"MEDIUM","mitigation":"In current implementation of the smart contract, RenewableSynth itself is not pausable. Pausing does not disable the functionality to update the feed but could be useful to stop issuance, settlement or synthesis allowing of all the Synths backed by the Asset being updated. Consider adding PausableV2 to the RenewableSynth."},{"title":"Owner of the contract is not able to transfer it to a new contract","severity":"MEDIUM","mitigation":"Use the first condition from `_isNotThisNorRecipientYourself()`.\n\n#"}]