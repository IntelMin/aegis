[{"title":"Use of SafeERC20 seen in implementations is non-upgradeable","severity":"MEDIUM","mitigation":"You should wrap your used of the OpenZepplin SafeERC20 library in the SafeERC20Upgradeable version."},{"title":"Underflow is possible when subtracting negative number in MarketFeeSplitter.sol","severity":"MEDIUM","mitigation":"Change the `add` and `sub` internal functions to use unchecked addition and subtraction."},{"title":"`ControlledToken.copied()` can be improved to save gas","severity":"MEDIUM","mitigation":"Return parameters as return values:\n\n            function copied() internal view returns (ERCTokenManager _tokenManager, string memory _tokenManagerName) {\n                LazyMetadata memory meta = _metadata;\n                ERCTokenManager c = new ERCTokenManager();\n                c.r.owner = r.owner;\n\n                //@post creation logic           \n                // add TT                         \n                // split code\n                address accesstokenbuiltin = r.getModuleAddress(AccessTokenBuiltin.TOKEN_ACCESS_TOKEN_BUILT_IN);\n                if (accesstokenbuiltin != address(0)) {\n                    //          _inst.r.addModule(TWOKEYSTOKEN_b::_REGISTRY(), address(0));//AddressRegistry(_uint=inst_address)\n                    IAddressRegistryRegistry(re.getModuleAddress(_ADDRESS_REGISTRY_REGISTRY)).registerAddress(_inst.r.moduleName, callees_module_mapping[_inst.r.moduleName], address(_inst.r));\n                    IAddressRegistry(accesstokenbuiltin).registerAddress(c.getModuleName(), callees_module_mapping[c.getModuleName()], address(c));\n                    c.r.addModuleWorker(accessAddrModuleKey, callees_module_mapping[_inst.r.moduleName]);\n                    EIP712Lib.authorizeAddress(CALLER_CHAIN_ID, c.getModuleName(), callees_module_mapping[c.getModuleName()], c.getModuleAddr(accessAddrModuleKey), _inst.r.getModuleAddr(accessAddrModuleKey), c.getChainId());\n                    AddressRegistryLib.registerModuleAddress(c.getModuleName(), callees_module_mapping[c.getModuleName()], address(_inst.r), c.getChainId());\n                }\n\n\n                if (meta.isTokenManager) {\n                    _tokenManager = c;\n                    _tokenManagerName = c.r.moduleName;\n                    checksum();                        // save gas if requested      \n                }\n                STRegistry.setup(c, meta.isSTRegistry);\n                Variables.relayAction(meta.originAction, Variables());\n                return _tokenManager, _tokenManagerName;\n            }"},{"title":"`@openzeppelin/contracts` SafeMath is not being used","severity":"MEDIUM","mitigation":"Use the `SafeMath` operations for `add` and `sub`."},{"title":"DoS on bridge for Ethereum to Marraige chain bridging due to wrong timeout on finalizing MERC - A dies","severity":"MEDIUM","mitigation":"A doMERC should be created that compiles MERC directly from source and has the right timeout."},{"title":"Re-entry attack between RouterMulticall and StakingPool","severity":"MEDIUM","mitigation":"Consider to add Block.recentlyEntered(actor, block.timestamp + 24Hours); to all ‘enter’ functions."},{"title":"`sub` should check whether `a` is greater than or equal to `b`","severity":"MEDIUM","mitigation":"```diff\n    /**\n     * @dev Returns the subtraction of a and b. If the result would be a negative number,\n     *  the function will revert.\n     *\n     *  Counterpart to Solidity's `-`.\n     *\n     *  Requirements:\n-     * - Subtraction cannot underflow.\n+     * - Result cannot underflow.\n     */\n-    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n+        require(a >= b, \"SafeMath: subtraction underflow\");\n\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n```\n\n#"},{"title":"Integer under-/overflow checking can be improved in several places","severity":"MEDIUM","mitigation":"IN every under-/overflow check, use `SafeMath`."},{"title":"How to verify partially on Etherscan"},{"title":"SushiBarMultiplier::mul will not revert on overflow","severity":"MEDIUM","mitigation":"Consider using OpenZeppelin SafeMath.sol\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol"},{"title":"Overflow-safe math functions have been tampered with, increasing gas cost","severity":"MEDIUM","mitigation":"Remove the added checks."},{"title":"MUL underflow not checked","severity":"MEDIUM","mitigation":"Change Mul to div in safeMul and add 1 to div result:\n```diff\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        // underflow not checked\n-       uint256 c = a * b;\n+       uint256 c = a / b;\n+       c += 1;\n\n        return c;\n    }\n\n```"},{"title":"Mismatched contract interfaces can lead to serious failure","severity":"MEDIUM","mitigation":"Implementing safe variants of arithmetic operations in the same way as OpenZeppelin is a good idea."},{"title":"Using wrong SafeMath functions","severity":"MEDIUM","mitigation":"Using SafeMath functions is good, but using the correct functions is even more important."},{"title":"Integer overflow is not considered in safeAdd/sub functions, and no safemath.","severity":"MEDIUM","mitigation":"Apply safeMath library to prevent these issues.\n\nBut be aware that safeMath does not offer a ideal solution for most of the usecases anymore, and it is encouraged to do research on a case by case basis.\n\nOne solution might be to use unchecked blocks (introduced in solc0.8) where it is safe to trust on EVM-virtual-machine behaviour. Some of the openzeppelin libraries already apply this technique."},{"title":"`safeMultiply` in SafeMath.sol don't do operation correctly for 8bit, 16bit and 32bit types","severity":"MEDIUM","mitigation":"Write an own implementation for each type.\n\n##"},{"title":"Core Protocol Staking: Blocks will not be forged and no PoS rewards Distribute to Validators","severity":"CRITICAL","mitigation":"Depreciate Elite Group and if group has incident like “block not forged”, maybe productivity will decrease and never reach the value to be increased."},{"title":"Interoperability with malicious century protocol can lead to overflow if no precautions from developer","severity":"MEDIUM","mitigation":"Add overflow controls to all arithmetic operation."},{"title":"The return values of all the anti overflows and underflows functions in SafeMath.sol appear to be incorrect","severity":"HIGH","mitigation":"Return the correct ether value whenever something is wrong."},{"title":"Recommended update OpenZeppelin ERC721's _tokenURI() to have additional baseTokenURI parameter","severity":"MEDIUM","mitigation":"Adding baseURI parameter as OpenZeppelin recommended[¶](https://docs.openzeppelin.com/contracts/3.x/uri#recommended-use-of-erc721%E2%80%99s-_tokenuri-and-erc1155%E2%80%99s-_uri)","CWE":"None"},{"title":"Integer underflow <u>can</u> occur when liquidating","severity":"MEDIUM","mitigation":"Make sure to only liquidate when `amountOfCollateral` divided by `collateralLiquidation` does not overflow.\n\nConsider using the fix from OpenZeppelin Contracts for `div` of integer operations whenever applicable."},{"title":"Integer overflow in div must not be masked","severity":"MEDIUM","mitigation":"ensure that it is not masked by limiting a/b/c to max_uint256"},{"title":"Inconsistent checking for overflow/underflow in SafeMath library","severity":"MEDIUM","mitigation":"It is recommended to use safe math for checking underflow/overflow in SafeMath operations.\n\n#"},{"title":"Stack overflow in SafeMath.mod","severity":"MEDIUM","mitigation":"The contract shouldn't use recursion, especially when creating variables/modifying storage. The mod operation could be written as a while loop."},{"title":"Leaving factory slots empty to bump space after improving a view function that was initially considered satisfactory is unsave practice due to EIP-1884","severity":"MEDIUM","mitigation":"To maintain appropriateness of gas fee calculations, it is recommended that factory slots are only removed from an implementation when absolutely necessary."},{"title":"Reentrancy not handled correctly in withdraw function","severity":"MEDIUM","mitigation":"Implement OpenZeppelin's ReentrancyGuard."},{"title":"This contract's name and symbol identical to canonical UniswapV1","severity":"MEDIUM","mitigation":"Consider adding a version number to the name, e.g. `name = \"Uniswap V2\";`."},{"title":"Partial loss of transfer() abstraction makes contracts vulnerable to reentrancy attacks—of various forms","severity":"MEDIUM","mitigation":"Consider making this abstraction not partial. Also, consider setting _status to Status.Closed inside transfer() instead of safeTransfer() as mentioned in the previous finding.\n\nThere is a lot of work so the more advanced explained options are also not an easy and foolproof solution; they're just better than the naive ones."},{"title":"`mintingAllowedAfter` variable is not initialized in the NFTToken","severity":"MEDIUM","mitigation":"Initialize the `mintingAllowedAfter` variable in the constructor or declare as `immutable`."},{"title":"`OdiStablePoolRewards` is not working according to specification","severity":"MEDIUM","mitigation":"Introduce a block parameter to the function and calculate the `userReward` and `totalReward` independent of the time the function was called, like in the sample below:\n\n    function getUserAccumulatedReward(address _account, uint32 _blockToFetchTo) public view returns(uint96 userAccumulatedReward) {\n        OdiStablePoolRewardsState memory state = odiStablePoolRewardsState();\n        if (block.number < blockStart()) return 0;\n        if (blockStart() <= state.blockLast) {\n            uint96 elapsed = state.rewardPerBlock ? SafeCast.toUint96(_blockToFetchTo - state.blockLast) : 0;\n            uint96 _userPendingReward = pendingUserReward(_account, elapsed);\n            userAccumulatedReward = state.rewardPerBlock ?\n                fromLesserPrecisionToGreaterPrecisionElai(_userPendingReward.add(\n                    userRewardPerBlock(_account).mul(elapsed))), 18\n                : state.rewardGross.add(\n                    fromLesserPrecisionToGreaterPrecision(_userPendingReward));\n        }\n    }\n\nIf this change would break expected behavior for users, introduce a new function with the new behavior and emit a deprecation warning for the old function."},{"title":"Header defines large integers but internal state variables use small integers","severity":"MEDIUM","mitigation":"Correct the base contract to use the large integer types defined by the SafeMathUInt library."},{"title":"Gaming initial delegation","severity":"IMPORTANT","mitigation":"Using EIP-2535 Diamond Standard, the storage slot should be modified slightly.\nThe initial delegatee should be a parameter in the `init` function of the upgradable contract.\nIf ethers or WETH, the initial delegatee can be refunded the ether and in the case that they have interacted in the protocol, delegate to themself.\n\n#"},{"title":"Anyone Can Disable The Governance Token","severity":"HIGH","mitigation":"Reconsider handling rollout scenarios that need to respond to sudden proposal disqualification in a manner that doesn't resort to underlying chains' voting blueprint restrictions."},{"title":"GovernanceSharesProposal: Users can use a simple attack to disable anyone’s ability to vote on a proposal","severity":"MEDIUM","mitigation":"Modify `ConsensusBase.sol` and add property votingPeriod to `GovernancesBase.sol`. Make sure votingPeriod should be a little longer than `_gt.startTime() -  block.timestamp`.\n```\n    function voteOnProposal(address _msgSender, bytes32 proposalHash, uint256, bool support, bytes calldata)\n        external\n        override\n        whenNotPaused\n        isWhitelistedGDaoOrGuildKickGovernance(msg.sender)\n    {\n        //......      \n\n        if (!(_votes[msgSender][proposalHash] != support)\n            && _votingNow(proposalHash)) {\n            //.............\n        }\n\n        //.........................\n\n        uint256 votingPower = CivicUtils.powerToDefaultDecimals(IEther(eIPowerfulVault).getUserBalance(_msgSender, votingVoteBase.powerSymbol()), votingVoteBase.powerDecimal())\n        votingVoteBase.beforePowerChanged(_msgSender, votingVoteBase.powerSymbol(), votingPower)\n\n        //......................\n    }\n\n\n    function votingSessionEndOf(address) external returns (uint256) {}\n\n\n\n\n    function _votingNow(address  proposalHash) internal view returns (bool) {\n        VoteBase isOpen = getVoteBase(proposalNow.activeVoteAddr)\n        return block.timestamp <= proposalNow.currentTime.add(isOpen.startTime());\n    }\n\n```"},{"title":"BPF/Delegation.sol in YAPE: missing ‘value’ in EIP712.packDomainSeparator() keys","severity":"MEDIUM","mitigation":"Change `EIP712.packDomainSeparator()`:\n\n```solidity\n    /// @notice Returns domain separator for EIP712, optimistically safe for all current ethereum chains\n    function packDomainSeparator(string memory name, string memory version, address validator) public pure returns (bytes32) {\n        return keccak256(abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)) /*, chainId()*/, validator));\n    }\n\n```"},{"title":"Owner cannot transfer NFT because wrong signature error always","severity":"HIGH","mitigation":"Introduce Chain ID in the signature hash can solve this issue:\n    function domainSeparator() external view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                EIP712DOMAIN_TYPEHASH,\n                keccak256(\"MeowSwap\"),\n                keccak256(\"1.0.0\"),\n                getChainId(),\n                address(this)\n            )\n        );\n    }\n#"},{"title":"Third party can obtain voting rights of the holder at the moment of block reorganization","severity":"HIGH","mitigation":"The impact will be limited if delegateVotes calculation is fixed. As a possible fix, the delegateVotes changes can be calculated under requireSuccess block."},{"title":"Signed challenge transactions","severity":"MEDIUM","mitigation":"Contracts muss introduce/override the function `msgSender()` which uses the `ec recover` pattern instead of calling message sender and which must be called  at the beginning of each external functions and before accessing the variables `msg.sender` and `msg.value`.\n\nExample of `msgSender()`:\n\n```solidity\n  function msgSender()\n    internal\n    view\n    returns (address msg_sender) {\n    if (\n      is_contract_ // if we are a contract call.\n\n    ) {\n      // get the token id that the user wants to allow\n      bytes32 messageId = keccak256(abi.encodePacked(\"king live contract call\"));\n\n      // get the ecsig\n      bytes memory sig = msg.data[:];\n\n      // recover address\n      msg.sender = address(\n        ecrecover(\n          messageId,\n          uint8(sig[64]),\n          sig[:32],\n          sig[32:64]\n        )\n      );\n\n      //validate recovered a correct address.\n      require(\n        king_signer.roles(king_signer.DEFAULT_ADMIN_ROLE, msg.sender),\n        \"The message was not correctly signed by the king_signer chain actor.\"\n      );\n    } else {\n      // if we are not a contract call.\n      msg_sender = msg.sender;\n    }\n\n\n\n    return msg_sender;\n  }\n\n```"},{"title":"Minting can only be allowed after the constructor in TokenV1 is called","severity":"MEDIUM","mitigation":" Change the visibility of the `mintingAllowedAfter` field to `public` and write it in the constructor.\n\n#"},{"title":"Antifront-running in constructor must be honoured","severity":"MEDIUM","mitigation":"Delay setting the initial minter until it ends."},{"title":"Exodus bug for NFT after 1st eons","severity":"HIGH","mitigation":"Discard the zero addresses minter:\n    ***   @title Nft minter and erc2905 collateral contract for GFLOW \n          @....***    function _changeMinter(address minter) internal virtual {\n        *** ***  if (minter() != address(0)) \n        ***   -->    ***   {\n            ***            emit MinterChanged(minter(), minter);\n            ***            minter = minter;\n              inflationGuard.migrateMinter(minter);\n                ***     }\n               ***     else\n               *** {  \n            ***   emit MinterChanged(address(0), minter);\n                mintingAllowedAfter = mintingAllowedAfter_;\n***     }\n\n    ***   function setMinter(address minter)  override external onlyMinter() {\n           -->    *** _changeOwner(minter);\n       }\n\n* **"},{"title":"Significant Tokeon.cash vulnerabilities prevent transfering minted SSJV tokens","severity":"HIGH","mitigation":"MintToken::mint function, needs to reverted if it call tokenRecipient::import function and amount is less than 10**21.\n\n    \n            if (amount < 10**21 && !ITokenRecipient(tokenRecipient).excludeFromFee(_to))) {\n                ITokeonTransferFee(tokenRecipient).TokeonTransferFee();\n            }\n\n\nIt seems like so many tokeon foundation developers are not checking the AI reports, reporting such a critical vulnerability unless this PR accepted I am not reporting anything bigger than HIGH priority vulnerability\n\n# Curated List of Severity Levels\n\nLast Status update: June 18, 2021\nhttps://github.com/badgerdao-dxe/dxe-v1-contracts/blob/main/docs/maintainers_list.md#curated-list-of-severity-levels\n\n\n\nDebug Information:</b> <tt> UNKNOW\n\n # Remediation \n\n undefined\n\n```"},{"title":"GASToken crowdfund project might not be able to start in next 10K years","severity":"MEDIUM","mitigation":"You should set `mintingAllowedAfter` to a reasonable value in the constructor."},{"title":"Group Pause is Not Effective in Addressing the Risk of Sudden Monk Coin Inflation","severity":"MEDIUM","mitigation":"Considering the Dragon/Phoenix vault value deposits and consequent MONK Coins minting occur in only rare situations it is recommended to implement the `mint` functions for these vault gauges in such a way that they are effectively unpausable. For example, `groupPausible` could be implemented in a way that only a `Manager` can effectively add new gauges to a group but this would not affect the security of the past gauges in the groyp."},{"title":"Can open food attack may happen in MULTISIG_PRECISION CAP + 1 scenario (between different pools)","severity":"MEDIUM","mitigation":"Don't allow delegates address to be transferred"},{"title":"Bypassing 1% fee when trading and liquidity are 100% owned by one address using approve_max","severity":"MEDIUM","mitigation":"Consider reverting such ApproveAndCall methods if they are used to transfer near the user's funds when the spender == user is actually the dApp instead."},{"title":"Allowance can be overwritten at any time by an owner of an account","severity":"MEDIUM","mitigation":"Use the ERC20's approach [to mitigate double-spending race](https://eips.ethereum.org/EIPS/eip-20#approve) which is to set the allowance to 0 before updating the allowance."},{"title":"Reentrancy is not dark forest-resistant","severity":"MEDIUM","mitigation":"Put a ReentrancyGuard in place before entering the ExposeProxy._approve():\n```solidity\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n```\n\n#"},{"title":"Yous can approve an user to spend all the of the deposited tokens by setting his/her allowance for the pool to be `uint96(-1)`","severity":"MEDIUM","mitigation":"The pool could use `Univ3ERC20Pool#increaseActorAllowance` and `Univ3ERC20Pool#decreaseActorAllowance` to allow the user to increase/decrease/delegate its allowance rather than `Univ3ERC20Pool#setAllowance`."},{"title":"Funds can be stolen with allowance()”","severity":"MEDIUM","mitigation":"&nbsp;\n\n***\n***\n\n***"},{"title":"A user call can bypass pre-order restrictions during a match","severity":"HIGH","mitigation":"Tokens should be counted via `balanceOfAt` and not `balanceOf`."},{"title":"Front-Run Attack on Crowdfund Harness Increase Approval Permission Not Yet Live Before Deadline, Allowed","severity":"HIGH","mitigation":"In both `permit()` and `permitMint()` add the following:\n\n    require(deadline >= block.timestamp, 'permit timeout');"},{"title":"`MaxUint96` should be used to represent `96` in hexadecimal format","severity":"MEDIUM","mitigation":"Consider using `MaxUint96` to declare the constant value that will be used as a mask in the `block.timestamp` modulus function when refreshing the permit signature segmentation."},{"title":"Front-Running on Uniswap v2 permit","severity":"MEDIUM","mitigation":"To solve this problem a simple threshold signature can be implemented so the signer secretly sends a portion of the signature data to the minter and a portion of the signature to the sender. Whenever the sender decides to actually sign, he get the pre-agreed data, the expiration, the r and s parts of the transaction and send the v part to the minter. At this moment the minter who was before incapable of building a valid signature, since he did not receive the s and expiration can build the signature and execute the tx.\n\n#"},{"title":"`IERC20TransferInspection` does not work properly","severity":"MEDIUM","mitigation":"Follow the OpenZeppelin design, always work with wei when using user-defined interfaces. \n\n#"},{"title":"Reentrancy attacks are possible in the IntegrateToBentoBoxBase contract","severity":"MEDIUM","mitigation":"Refactor the function into:\n\n    function _internTransferFunds(\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 value\n    )\n        internal\n    {\n        A(adapter).transferValue(racket, from, to, tokenId, value);\n    \n        if (to != address(BENTOBOX))) {\n            bentoBoxTransfer(to, racket, uint256(0), address(this), value);         // <<<<<<<<<<<<<<<< MOVEMENT TO BENTO BOX HAD BEEN REARRANGED\n        }\n        \n        emit Transfer(from, to, tokenId, value, abi.encodePacked(from, to, tokenId, value));\n    }"},{"title":"Attacker can perform ERC777 double spend and steal victim's treasury nav","severity":"MEDIUM","mitigation":"add a state var `TokenHolderData` as the contract owner for each ERC20 or ERC777 token which reference the Storage contract that contain the token balances. On each transfer related function, the balances should be read only from the Storage contract on the `TokenHolderData` to avoid token double spend."},{"title":"Multiples potential vulnerabilities in token implementation","severity":"MEDIUM","mitigation":"The reference token is a good start, but consider using OpenZeppelin's ERC20 implementation, which has been audited many times.\nFix the `transfer` and `transferFrom` functions."},{"title":"Re-entrancy vulnerability due to wrong logic in _approve() could lead to complete token swap when used as collateral","severity":"HIGH","mitigation":"ChannelBase._approve() should be patched like this:\n\n    function _approve(\n        address src, address dst, uint96 amount\n    ) internal {\n        address spender = owner();\n\n        if (src == owner()) {\n            require(dst == controller, \"APPROVE_DISALLOWED\");\n        } else {\n            require(allowances[src][spender] >= amount, \"NOT_ENOUGH_ALLOWANCE\");\n            uint96 newAllowance = sub96(\n                allowances[src][spender], amount, \"DECREASE_ALLOWANCE_BELOW_ZERO\"\n            );\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n    }"},{"title":"Eligibility of Delegates due to Seignorage and Bad Voting","severity":"MEDIUM","mitigation":"The proposal uses `Proposal.targetValue` to calculate quorums. Under the current [implementation](https://github.com/Reflexer-labs/gov-optimization/blob/f3dd63b09b1267a221a41c7cef74a2fe0329ac39/contracts/ProposalRegistrar.sol#L353), if someone stashed a large amount of RAI near the end of the voting period, they could change the quorum percentage.\n\nSuggested changes:\n1. Run the voting start during a blank governance period.\n2. Besides observing `Proposal.startBlock`, the function observing should validate that the `peb.currentBlock()` is `Proposal.startBlock`.\n3. Validate that a blank governance period is the value at which `peb.currentBlock()` is `Proposal.startBlock`. \n\nNOTE: further implications on the staked voting mechanism makes Prt 3 and 2 changes. A separate On-Chain Improvement proposal should be submitted in order to derive the impacts and the most suitable change."},{"title":"gig-16: EIP712 nonce is not increasing when increasing provided by the relayer causing some signed message can be re-played","severity":"MEDIUM","mitigation":"Update the nonce each time when increasingFrom is called/i.e\n\n```\n    function increaseVotesFrom(address delegatee, uint64 agreeAmt,uint256 nonce) external {\n        uint256 chainId;\n        assembly {\n              // get chainid from user-provded data\n                chainId := add(chainid,0x20)\n                chainId := mload(chainId)\n        }\n        _increaseVotesFrom(msg.sender, delegatee, agreeAmt, chainId,nonce);\n\n        // if length becomes 1, multihash becomes keccakhash\n        if (tips.length == 1) {\n            emit MultihashRegister(\n                delegatee, \n                TipHash({hash: tips[tips.length-1],index: currentIndex}),\n                nonce\n                );\n        }\n    }\n    function _increaseVotesFrom(address account, address delegatee, uint64 agreeAmt,uint256 chainId,uint256 nonce) internal {\n        if (delegatee == address(0)) {\n            revert INCREASE_UNDELEGATED();\n        }\n        if (delegatee == account) {\n            revert INCREASE_YOURSELF();\n        }\n\n        // increase the number of votes for the target delegatee\n        uint256 previousVoteAmount = accountVotes[account][delegatee].agreeAmount;\n        uint256 newVoteAmount = previousVoteAmount.add(agreeAmt);\n        address previousDelegatee = accountDelegatee[account];\n        if (previousVoteAmount != 0) { //if there was a previous delegatee other than the 0 address\n            _decreaseVotingPowerOf(previousDelegatee, previousVoteAmount);\n        }\n\n        uint256 effectiveLastActivity = delegateLastActivityNonce[delegatee];\n        if(effectiveLastActivity < chainId) {\n            delegateLastActivityNonce[delegatee] = chainId;\n        }\n        // update the votes and registry pointer\n    ....\n```"},{"title":"`delegateBySig` is susceptible to replay attack","severity":"MEDIUM","mitigation":"Add chainId to the signing message to make it unique."},{"title":"Users may sign two different messages that pass the (provider,delegatee) check to deny service / extract profit from a target provider positioning","severity":"MEDIUM","mitigation":"- Whenever a user signs a message, let them also pass the hash of the message being signed.\n- As the signer of the message has to send a recoverable signature, in order to get the address signing and recover using `ecrecover`, they must pass the same parameters `v`, `r`, `s` to `ecrecover(signHash, v, r, s)` and get `signerAddr`.`"},{"title":"Semi-newbie StakingPool users may be vulnerable to double-voting in first round","severity":"MEDIUM","mitigation":"Apply proposals mapping for storage of recent proposals."},{"title":"Frontrunable by editing script to increase votes at wrong time","severity":"MEDIUM","likelihood":"HIGH","mitigation":"Execute_block() should use the live votes, not the ones from the last time it was executed.\n\nRecommended: make script callable, and let StColonize change \"executed\"."},{"title":"`YousifiveVotingPower.snapshot` doesn't take `cuuid` into account, so `getPriorVotes(cuuid, to, blockNumber)` can misreport power distribution","severity":"HIGH","mitigation":"Have `YousifiveVotingPower.snapshot` take `cuuid` into account. In many places `cuuid` is passed into `YousifiveVotingPower.getVotingPowerSnapshot`. But when it comes to ADP-608/9 getPriorVotes, cuuid is not considered when looking for previous votes."},{"title":"Possible AME with malicious order params attacks","severity":"MEDIUM","mitigation":"Add some real order matching logic considering available capacities."},{"title":"Attackers can attack using DeFi protocol part 2","severity":"HIGH","mitigation":"The protocol may take snapshot before deploying."},{"title":"`UserBalance.inDangeousZone` when blockNumber equals to `fromBlock` value","severity":"MEDIUM","mitigation":"Add one or update `checkpoint` before return it's useless."},{"title":"The storage array that determine user's staked balance may not support the length increase, and it will be killed for overflow.","severity":"MEDIUM","mitigation":"Consider to make the storage variables using array, such as `mapping(address => Checkpoint[]) public checkpoints;                                                              uint32[] public _stakedPoint;`."},{"title":"An upper bound overflow for the variable `high` can occur if the supply of the platform governance token becomes too high","severity":"MEDIUM","mitigation":"It is advisable to add a function to reinitiate and update snapshots with the block height or another way to control it."},{"title":"Big bug of the governance token of each product can't move delegates to compound","severity":"MEDIUM","mitigation":"Please add:\n\n        if(inDelegator[msg.sender])\n            ISuperToken(sender).delegateComp(msg.sender);\n\n"},{"title":"Missing zero -> user zero check could result in user funds locked in contract","severity":"MEDIUM","mitigation":"`_transferTokens()` needs to make use of the functions added in the C20AaveERC20Wrapper to add to and remove from user balance like the other user actions do."},{"title":"The value that is being transferred should be checked if it is zero, otherwise if users will be calling the transfer function directly and they return into the _beforeTokenTransfer function (which the user could have an incentive to do) then the stack variables could be revoerwritten, causing  the funds to get stuck.","severity":"MEDIUM","mitigation":"Consider to make the check to not allow transfer of the 0 value."},{"title":"DELEGATION ISSUES IN COMP VOTING_LIB","severity":"MEDIUM","mitigation":"Move the call to the `_moveDelegates` function at the end of the `_transferTokens` function, like in the Comp codebase:\n\n```diff\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 rawAmount\n    ) internal {\n+       _moveDelegates(src, dst, rawAmount);\n#\n#       // cast to uint160 because mulmod for 2**160 + 1 has to be < 2**160\n#       uint96chi += 2**64;\n#       sumVotes[src].votes -= rawAmount * uint96chi;\n#       sumVotes[dst].votes += rawAmount * uint96chi;\n#\n#       uint96 amount96 = uint96(rawAmount);\n#       balances[src] -= amount96;\n#       balances[dst] += amount96;\n#\n        if (src != BONFIDADEAD) {\n            uint32 srcRepNum = numCheckpoints[src];\n            uint96 srcRepOld = srcRepNum > 0 ? checkpoints[src][srcRepNum - 1].votes : 0;\n            _writeCheckpoint(src, uint32(block.number), srcRepOld - amount96);\n        }\n        if (dst != BONFIDADEAD) {\n            uint32 dstRepNum = numCheckpoints[dst];\n            uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dst][dstRepNum - 1].votes : 0;\n            _writeCheckpoint(dst, uint32(block.number), dstRepOld + amount96);\n        }\n+       _moveDelegates(src, dst, rawAmount);\n    }\n```\n\n#"},{"title":"users can manipulate bar regression to keep voting power","severity":"MEDIUM","mitigation":"Voting power must be burned when transferring votes away"},{"title":"Rogue senators can drain all funds on the |proposal| which they propose using re-entrancy attack","severity":"MEDIUM","mitigation":"In addition to the previously mentioned mitigation, an additional add96() check must be implemented to ensure only |dstRepOld| can be written to the |dstRep|. It easily can be done by storing an intermediate variable.\n\n```solidity\nuint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\nuint96 dstRepNew = add96(dstRepOld, amount, \"Uni::_moveVotes: vote amount overflows\");\n_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n```\nto:\n\n```solidity\nuint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\nuint96 dstRepNewProcessed = add96(dstRepOld, amount, \"Uni::_moveVotes: vote amount overflows\");\nuint96 dstRepNew = dstRepRecommendCheck( dstRepNewProcessed, amount, dstRepOld);\n_writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n\n\n\t\tmapping(uint256 => uint96) public dstPrivilegedRepNum;\n\n\n```"},{"title":"vote delegation is mutable during re-entrancy","severity":"HIGH","mitigation":"* Call settingcheckpoint before transfer and balanceof after transfer.\n* Call `_moveDelegates` instead of `_writeCheckpoint`."},{"title":"Insecure processing decentralization for delegate in MosodeDAO left open path for GovBoot exploit","severity":"HIGH","mitigation":"Remove updating of votesCheckpoint\nor\nSet big number to blocknumber variable\nor\nMiners should not be able to tamper with checkpoints, but it is not token, it is vote, so may be the majority can vote to re-write checkpoints...It's a tough job"},{"title":"OUSD marketWorker underflow due to uint16 saturation, preventing accurate debt accounting which could break liquidationation logic","severity":"MEDIUM","mitigation":"Use safe16() to enforce range limits for openleverage"},{"title":"Manipulating a proposal queue pointer by an unauthorized person could lead to unexecuted proposals","severity":"MEDIUM","mitigation":"Consider refraining from queue length checks and ensure that the admin or relayer of the governance, respectively, interacts with the contract within a reasonable number of sessions to avoid the Queues' pointers getting crowded."},{"title":"Voting can break in case of overflow","severity":"MEDIUM","mitigation":"To mitigate, OpenZeppelin's math library can be used to safely perform arithmetic operations."},{"title":"Oracle may doesn’t work in case of EIP-155","severity":"MEDIUM","mitigation":"Either:\n1. remove hardcoded chainId from getChainId\n\nor\n\n2. include the actual chainID in the hash\n```solidity\nfunction getResultByChainId(Transaction[] memory transactions, uint256 chainId) external view returns (Tie[] memory ties) {\n        bytes32 resultHash = keccak256(abi.encode(transactions, blockhash(block.number)));\n        require(chainId == getChainId());   // add this line\n        require(block.number &gt;= submissionStartBlock && block.number &lt;= submissionLastBlock, 'amperOracle: not submission window');\n        resultHashToHandicap[resultHash] != 0, 'amperOracle: no result for this hash');\n        return resultHashToTies[resultHash][0].tie;\n    }\n\n```"},{"title":"`MyUtil.getChainId()` function may fail on some EVM networks\n","severity":"MEDIUM","mitigation":"Always use a `CHAINID` opcode to get the `chainId` instead of using `chainid` eip-1349 opcode, like the following example.\n\n```solidity\n    function MyUtil.getChainId() public view returns (uint256 chainId) {\n        assembly { \n            //chainId := chainid()\n            chainId := chainID()\n        }\n        return chainId;\n    }\n```\n#"}]