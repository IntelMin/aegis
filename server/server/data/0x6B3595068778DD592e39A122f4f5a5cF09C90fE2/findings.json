[{"title":"`_msgxx()` functions in the Context are not extensible","severity":"MEDIUM","mitigation":"remove the `virtual` keyword from both `_msgxx()` functions if it's okay that they cannot be extended"},{"title":"Ether can partely be stuck in this contract by anyone","severity":"MEDIUM","mitigation":"Make CC manage not supported senders."},{"title":"ERC20 totalSupply is open to implementation bugs due to lack of EIP-86 warning to users about possible dilution of their token value","severity":"HIGH","mitigation":"The `totalSupply` should include a EIP86-warning about the dilution risk, like shown in the `_burn` example."},{"title":"The BALToken contract needs to add the returning value annotation or the `balanceOf()` function should be checked for return value","severity":"MEDIUM","mitigation":"Add the returning value annotation of balanceOf() function."},{"title":"No transfer*From (notAllowanceTransferFrom) in DefaultERC20 is implemented","severity":"MEDIUM","mitigation":"Consider adding `transferFrom` function to the interface:\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);"},{"title":"Confusion in NPXT contract documentation could cause wrong implementations and oracle allowance overflow","severity":"MEDIUM","mitigation":"In NPXT documentation, the `name` and `symbol` should be different.\n\n**Recommendations for transcoder applicants:**\n\n* Name: NPXT\n* Symbol: TGTR<dsl_datapath>"},{"title":"ERC20 `allowance()` and `approve()` doesn’t delegate to `value()`","severity":"MEDIUM","mitigation":"User can approve allowed amount in executor contract, directly causing the stuck assets to be transferred buying time and giving user option to terminate the bad strategy contract.\n\n#"},{"title":"ERC20: Allowances can only be changed for the `owner` from `decreaseAllowance`","severity":"MEDIUM","mitigation":"Since this is a tradeoff, the OpenZeppelin team should consider switching to the recommended standard in the OpenZeppelin ERC20 implementation as well and implement the allowance change verification it brings with it."},{"title":"`IERC20.approve` has no `view` or `pure` function specifier","severity":"MEDIUM","mitigation":"Mark the function as `view`.\n\n***"},{"title":"Burning a token with transferFrom is a burnability vulnerability","severity":"MEDIUM","mitigation":"As suggested in the OpenZeppelin documentation, it is recommended that an explicit `transferAndCall` function is used to handle when a users burning tokens."},{"title":"ERC20: Lack of Cross-Tokens Asset Holders Compromise","severity":"MEDIUM","mitigation":"The recommended approach to mitigate this would be to implement the ERC677 standard, in which the  `approveAndCall`/@dev Tokens (`transferAndCall`) contract methods allow for an instantiation of a model in which these allowances contain a pointer to a base `AssetHolder` contract smart contract instead.\n\n#"},{"title":"EIP-2612 and ERC-1155 standard does not define return value as `bool`","severity":"MEDIUM","mitigation":"\n```diff\n   function approve(address spender, uint256 id, uint256 value) external returns (bool success);\n+  function approve(address spender, uint256 id, uint256 value) external returns (bool);\n\n   /**\n       Hook on which you can validate or update the allowances\n```"},{"title":"The subtraction is not protected in SafeMath.sol library","severity":"MEDIUM","mitigation":"Modify the library's SafeMath.sol code as follows:\n\n```solidity\n/* contract SafeMath {\n * @-title Bad coding/overflow ITW Tradefx Protocol Proposal\n */\n\n// ... rest of the content\n\n  function subSO(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(a >= b);\n    return a - b;\n  }\n\n\n```"},{"title":"Arithmetic library has no overflow checks","severity":"MEDIUM","mitigation":"Consider using an arithmetic library like OpenZeppelin's @openzeppelin/contracts/utils/math/SafeMath.sol."},{"title":"WETH contract allows to deposit infinite amount of ETHs that can be locked on it","severity":"HIGH","mitigation":"It is possible to send ETH to it directly or track the WETH contract address and do it. However, to make it technically impossible send value with a 0 value to `Deposit()` instead, so the fallback of the WETH contract will revert."},{"title":"`safeSub` is implemented incorrectly, which results in a pure function not actually being pure.","severity":"MEDIUM","mitigation":"Refactor the `safeSub` function as follows:\n+```solidity\n-    function safeSub(uint256 a, uint256 b) internal pure {\n+    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            unchecked {\n-                if (b > a) {\n-                    revert SafeMath::SubtractionOverflowError();\n-                }\n+                if (b > a) return 0;\n                return a - b;\n            }\n        }\n    }\n  \n```"},{"title":"The SafeMath library is recommended to be used for all arithmetical ops on-chain but it inherits directly from a pre-indexed version of v0.8 so underflows are not protected","severity":"MEDIUM","mitigation":"Incorporate the official PR and follow the latest Solidity 0.8 guidelines."},{"title":"Circuit breaker not implemented correctly to prevent DoS","severity":"MEDIUM","mitigation":"Any solution that inhibits the Add or Remove functions during circuit breaker activation should be used to achieve the intended security benefits. For example, the following changes may help:\n\n```solidity\nfunction Add() external cacheNotPaused returns (address fileAddress)  {...}\n\nfunction Remove() external cacheNotPaused returns (address fileAddress) {...}\n\nbool private _pausedOpenFunction;\n\nmodifier cacheNotPaused() {\n    bool openFunction = msg.sender == address(governance) || _pausedOpenFunction;\n    require(!paused || openFunction, \"Circuit breaker activated\");\n    _;\n}\n\nfunction openFunction(bool _open) external onlyGovernance {\n    _pausedOpenFunction = _open;\n}\n```"},{"title":"Possible underflow in YETI.scoreRecalcStake","severity":"MEDIUM","mitigation":"Pass onlyOldUserDif as a parameter to safeSub. Also, at this point `onlyOldUserDif` and `onlyNewUserDif` will not be more than `totalDif`. So, a better implementation will be to add `onlyOldUserDif` and `onlyNewUserDif` first, then calculate the final rewards accordingly"},{"title":"Multiple Integer Overflows are present in token contracts","severity":"MEDIUM","mitigation":"A protocol should always make sure that all integer calculations are safe or revert on overflow. To mitigate this integer overflow, above cases a simple check is suggested:\n```solidity\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n        \n        if (a < b) { //overflow\n            return 0;\n        }\n\n        return c;\n}\n```"},{"title":"`Math.add`, `Math.sub` and `Math.mul` DoS can be exploited to bleed reserves on exchanges","severity":"HIGH","mitigation":"In general, the answer is to do bounds checking.\n\n***Headline: Always do bounds checking when working with user-supplied integers!***"},{"title":"Operators in TokenMath library assumes all inputs are not so large to avoid overflow","severity":"MEDIUM","mitigation":"Add proper input range check."},{"title":"`safeDivUint` and `safeModUint` functions in SafeMath library does not handle when `b` is 0","severity":"MEDIUM","mitigation":"Return directly when `b` is zero."},{"title":"Add overflow check wrapper cause bricken complience ERC721 function","severity":"MEDIUM","mitigation":"Do not add checks for the view function: safeMul(a, b)."},{"title":"Malicious governance can steal user funds if CCT allowActorRequiesOwner","severity":"HIGH","mitigation":"Either do not make the actor owner capabale, or make sure that modifying the scheduled relayer is majority cartel consensus."},{"title":"Reentrancy not dealt with when eth is refunded","severity":"MEDIUM","mitigation":"Add a `checkStakeCount` modifier that sets the `stakeCount` variable to 0 and send the user their award if `stakeCount` is greater than 1 in the `award` function.\n\n#"},{"title":"Unsafe division introduced with ModifiedWadMintableERC721Contract’s _mintShares function","severity":"MEDIUM","mitigation":"Modify ModifiedWadMintableERC721Contract.sol's _mintShares function like this:\n\n    function _mintShares(address to, uint256 assetId, uint256 amount) private {\n        _balances[assetId] += amount;\n        _totalSupply[assetId] += amount;\n        ;\n        emit Transfer(address(0), to, amount);\n    }          \n\n#"},{"title":"Underflowing pool size","severity":"MEDIUM","mitigation":"The recommended way to change the compounding period of the pools should rather be done by:\n- withdrawing all LP tokens from the pool\n- swapping/spreading them within the aggregator contract to the new pool if necessary\n- migrating pool rewards + metrics data to the new pool\n- updating the pools active compounding period in the future with the new period\n- adding the pool to the future defaults\n\nIt is further recommended to not set the compounding period of the pools less than 2 hours for stabilization purposes."},{"title":"Integer underflow, resulting in division by zero","severity":"HIGH","mitigation":"Add the following checks:\n        \n    \t    if (a == b){\n    \t        require(b != 0, errorMessage);\n    \t    }\n    \n    \t    ...\n\n#"},{"title":"`sub` and `add` operations are used incorrect in `lookup`","severity":"MEDIUM","mitigation":"Switch back `maxStates` to normal `uint` and do use `sub` and `add` operations in `lookup` properly."},{"title":"Theres a reentrancy bug of SafeErc20 calls","severity":"MEDIUM","mitigation":"The recursive call to SafeErc20.checkSuccess() in SafeErc20.safeTransfer() will always revert after 2300 gas, because the `returndatasize()` check will always return wrong values after recursive call, which may lead to frozen funds.\n\nModify the problematic `returndatasize()` to `staticanalysis.pcMultireturn.measurereturndatasize()` to get right size and this can solve the problem.\n\n```assembly\n    function returndatasize() public view returns (uint) {\n      uint size;\n      assembly {\n        size := returndatasize()\n      }\n      return size;\n    }\n```\n\n#"},{"title":"Dos potential in safeMath due to revert messages","severity":"MEDIUM","mitigation":"Consider not reverting on under-/overflow."},{"title":"Integer overflow / underflow in SafeMath64","severity":"MEDIUM","mitigation":"Use SafeMath64_32 for Token._totalSupply and Similar functions."},{"title":"Many arithmetic functions are missing require to specify error message","severity":"MEDIUM","mitigation":"Consider adding an error message to all arithmetic functions"},{"title":"`isContract` method suppression is bad practice","severity":"MEDIUM","mitigation":"Remove the suppression and the warning of the Solidity compiler by removing the jmp instruction in line 49. The `isContract` falls back to the `isContract` method from the address library anyway."},{"title":"`isContract` function is not reliable when being used to check if `Tracker`/`Market` contract exists","severity":"MEDIUM","mitigation":"Consider returning true if the balance of the address is larger than zero when checking if the address is a contract or an EOA."},{"title":"Guard ProtocolManager._areContractsAllowed() function so that it cannot be exploited for Reflexive Signature","severity":"MEDIUM","mitigation":"I recommend adding a ProtocolManager function to only reassign the value to true, then no attacker can reassign it to false value."},{"title":"ERC20 Crowdsale using `transfer` utility may fail if `recipient` address is a contract","severity":"MEDIUM","mitigation":"To prevent this issue, consider Revealing-transfer-as-a-Pull-operation by using _transfer() and/or EIP-2309 and EIP-2084."},{"title":"`comptroller()` can be called multiple times by forcing OpenSea to transfer the newly created Citadel tokens to `msg.sender`","severity":"MEDIUM","mitigation":"Add the following variable to the CitadelBase contract:\n```\nbool private initialized;\n```\n\nAnd change the `initialize()` method as follows:\n```\n\tfunction initialize(string memory name_, string memory symbol_) external initializer {\n\t\t citadel.initialize('0', '0', 0, '');\n\t\t ERC721._registerInterface(ERC721_RINKEBY_INTERFACE_ID);\n\t\t``, {msg.sender: msg.sender});\n```\n\n#"},{"title":"DaoTreasury can be deployed incorrectly affecting all Void proposals","severity":"MEDIUM","mitigation":"Verify the code on etherscan before deployment.\n\nFuthermore, consider removing the 0x0 check in `sendValue`, as it is unnecessary and causes problems."},{"title":"Reentrancy attack when user makes the first claim, no one has staked, and a couple of epochs have passed","severity":"MEDIUM","mitigation":"Note that this attack can only steal the reward earned in the function `claimRewardsAndStake`.\n\nIt is recommended to transfer the reward to an address that the contract manages the private key (let's call this address `admin`). In the `claimRewardsAndStake` method, call `rewardERC.transfer(msg.sender, userReward)`. And then user can call the `admin` to withdraw the rewards accrued to the `admin`.\n\nAnother mitigation is to use openzeppelins reentrancy blockable function."},{"title":"Reentrancy to flashloan.sol can be pretty impactful for flashloan users","severity":"MEDIUM","mitigation":"Critical reentrancy is mitigated in V1 of Pool and iPool (it seems that updating to V1 will require a validation process from Anchor team and it won’t be automatic). However, an advice to every flashloan users would be that they implement some anticipation mechanisms (as flash loan provider’s API suggests). Alternativelly, a similar advice could be written alongside the flashloan() and uniswapFlashloan() functions docstrings."},{"title":"Treasury.sol holds generic fallback function which allow for 0 call to be successful","severity":"MEDIUM","mitigation":"User .transfer() or .send() instead of using the functionCall\nOR \nAdd a require or revert statement at the top of the function\n\n***"},{"title":"`SafeERC20.functionCall(address, uint256)` will not revert in case of `target` reverting","severity":"MEDIUM","mitigation":"Implement it properly</br>OR</br>Remove `errorMessage` to make it backward compatible</br></br>#"},{"title":"Circuit circuitBreaker() | public { can’t be turned off for biding period","severity":"MEDIUM","mitigation":"Create a circuit breaker that can be turned off by the owner and has a biding period."},{"title":"Denial of Service by Greifing with transferFrom()","severity":"MEDIUM","mitigation":"Consider reverting the current function call, when the transfer of ETH fails as part of an ERC721 transfer. Consider adding the `failed` mark each time you are about to perform a transfer to the recipient."},{"title":"Inconsistent unsafe usage of unchecked send: SafeAddress function and some external calls","severity":"MEDIUM","mitigation":"Introduce the unchecked opcode in the return value of the function."},{"title":"EVM spurious reverts allow stealing all stack space","severity":"MEDIUM","mitigation":"Change line 26 of address.sol:\n\n```solidity\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n```\n\nto:\n\n```solidity\n    function functionCallWithValueVerifyAddressCall(address target, bytes m...```\n\n#"},{"title":"`_functionCallWithValue` pre-transfer checks are insufficient","severity":"MEDIUM","mitigation":"add `isTransfersEnabled()` check\n```diff\n--- a/contracts/upgradeability/ProxyAdmin.sol\n+++ b/contracts/upgradeability/ProxyAdmin.sol\n@@ -100,6 +100,7 @@ contract ProxyAdmin is Initializable {\n         // solhint-disable-next-line avoid-call-value\n         (bool success, bytes memory data) = address(proxy).call{value: priceInWei}(payWindowData.data);\n         require(success, PAY_ORDER_CALL_FAILED);\n+        require(isTransfersEnabled());\n\n         selectMerchant(optionId);\n         consumeGas();\n```"},{"title":"Listener may not response to the after call if the after call revert with a revert reason","severity":"MEDIUM","mitigation":"Standardise revert reasons."},{"title":"Attacker can pollute pre-market orderbook with unbuyable tokens","severity":"MEDIUM","mitigation":"Call preMarketKeepers `checkValidity` to verify if the token follows their token standard for all functions call to `TokenV1`."},{"title":"Denial of Service by Revert Can be Performed by Anyone","severity":"MEDIUM","mitigation":" A feasible solution is to limit the message length to a suitable value. If a program's name is longer than the limit, a program's name can be displayed without '...' to let users know that this program's name is too long."},{"title":"User funds may be locked if user is pending in withdraw request when pause/unpause is called","severity":"MEDIUM","mitigation":"Consider using the OpenZeppelin Pausable library for pausing functionality. This will ensure that any user that is stuck in a `withdraw` request will have it canceled and their funds returned to their account, if the function is marked non-reentrant."},{"title":"Private fields will be accessible from external in the deployed contract due to use of OVM_CrossDomainEnabled","severity":"MEDIUM","mitigation":"Use public instead of private in the SDK:\n```solidity\n    uint256 _totalSupply;\n\n    string _name;\n    string _symbol;\n    uint8 _decimals;\n\n    // ... \n```"},{"title":"ERC20 Burnable Crowdsale is susceptible to the overflow issues with the maximum supply.","severity":"MEDIUM","mitigation":"Add a condition to check the `maxTotalSupply` value."},{"title":"YSL contracts are not upgradeable","severity":"MEDIUM","mitigation":"We propose making the base YSL token contracts upgradable. Defining ERC721Upgradeable will the easiest, but for ERC1155, it will be a little more complex."},{"title":"Using input for name, symbol and decimals will require new deployment","severity":"MEDIUM","mitigation":"Expand the Proxy contract to be able to set name, symbol and decimals on the underlying contract.  "},{"title":"reserve variable “_name” in functions name(), symbol() reduces readability and increases risk of contradiction ","severity":"MEDIUM","mitigation":"mapping attribute has infinite length, it's quite hard to override attribute with another.\nHaving said that, please remove the reserves on the name and symbol attributes on the InceptiveERC20TokenV1 and all its child.\n\n## Credits\nVisual Buy, JdoubleU, and JquantU-Finance Core"},{"title":"Inconsistent behavior of token standard compliance functions in BIPCubicCall and BIPCyberCall","severity":"MEDIUM","mitigation":" It is recommended to synchronize the implementations of BIPCyberPunkCall and BIPCubicCall around the three blocking functions mentioned above to prevent confusion and inconsistency during integration."},{"title":"Missing function `decimals` in InDeBusdToken.sol","severity":"MEDIUM","mitigation":"Add public function `decimals`."},{"title":"Incorrect scale of the output while calling ERC20.balanceOf() and ERC20.Wei()","severity":"MEDIUM","mitigation":"Consider putting the `scale` variable into storage to enable modifying the values post-deployment."},{"title":"TotalSupply can be incorrectly lower due to loss of precision without adding the   checkpoint update() functions incorrectly","severity":"HIGH","mitigation":"Add totalSupply checkpoints in XYZSwapToken to secure the value of totalSupply."},{"title":"address(0) could be used to attack Uniswap","severity":"MEDIUM","mitigation":"Consider adding the following lines in the _mint function.\n\n        require(account != address(0), \"ERC20: mint to the zero address\");"},{"title":"Anyone can steal half of the value of the assets stored in the router","severity":"MEDIUM","mitigation":"It is advised that the owner recover the native coin holdings."},{"title":"ERC2612 behavioural inheritance may be blocked","severity":"MEDIUM","mitigation":"Introduce public key, message and signature VRS-passing variants, and rely both the functions on the internally called ECDSA-passing function."},{"title":"Nothing is returned in approve and increaseAllowance (ERC20 standard) ","severity":"MEDIUM","mitigation":"Return current value of _allowances[owner][spender] to keep these functions according to the ERC20."},{"title":"ERC20::_beforeTokenTransfer can be bypassed","severity":"MEDIUM","mitigation":"An _beforeTokenTransfer hook is missing from `approve` and `_approve` should be called inside the `ERC20::_beforeTokenTransfer` hook of `approve`, as well as `transfer` and `transferFrom` functions."},{"title":"Insufficient total supply check can lead to inflation - DIN","severity":"MEDIUM","mitigation":"Add check of `_totalSupply` in `Q2TransferWithCommonCircuits.balanceOf` and especially in the final `U2FullyCommonCircuit`."},{"title":" ERC20: Approved spender can steal tokens when called with another transferFrom that incorrectly passes msg.sender","severity":"MEDIUM","mitigation":"Require that the passed_value of the Caller.transferFrom(msg.sender, _NewOwner, some_value) equals the to_spent value of the ExternalCaller.transferFrom(to_pool, Caller.address, passed_value)"},{"title":"Reentrancy is possible on `transferFrom`","severity":"MEDIUM","mitigation":"Update the `approve` method, similar to what was suggested in the fix:\n\n```solidity\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n\n        return true;\n    }\n```\n\n#"},{"title":"ERC20Permit-style approvals are not supported","severity":"MEDIUM","mitigation":"Implement ERC20Permit.sol. It is present in OpenZeppelin Contracts, so you can simply inherit from it and make `permit()` and `metaApprove()` functions override the base contract's `_approve()`."},{"title":"Malicious user could still make owner spend more than the allowed amount of funds without signature in ERC721ExternalLoan because erc20PermitApprove is used (and has no expiration time), bypassing the Traditional.balanceOf == amount check","severity":"MEDIUM","mitigation":"In ERC721ExternalLoan, simply replace `erc20PermitApprove` with `erc20Permit`."},{"title":"Re-entrancy when _approve called from increaseAllowance","severity":"HIGH","mitigation":"Add NonReentrant to _approve\n\n**Note:** There are many possible ways contract can gain ether, another example is hitting unhandled assertion, which results in ether being sent to contract.\n(see security consideration upon ERC2999 specification, OpenZeppelin documentation)"},{"title":"Update mayCall revert on the governor address to not disallow AppVoting to call transferFrom and delegatedTransfer","severity":"MEDIUM","mitigation":"revert only if it is different than the Governor"},{"title":"BEP20 approve changes","severity":"MEDIUM","mitigation":"Revert back to Openzepplin's version of the approve funciton for BEP20. Especially if you handle allowance in another contract than the BEP20 token."},{"title":"Increasing approval settings are unattainable if they are slightly incorrect","severity":"MEDIUM","mitigation":"It is better not to return a boolean value as if it is successful from `increaseAllowance` and `decreaseAllowance`. Adding try-catch in the user interface, or insuring it otherwise, is required. \n\n```diff\n    /**\n     * @dev Emits an {Approval} event indicating increased allowance.\n-- cut --\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Emits an {Approval} event indicating decreased allowance.\n-- cut --\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender]-subtractedValue);\n        return true;\n    }\n\n```  \nCorrectly:\n```diff\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual \n    try\n    returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    } catch (bytes memory /*lowLevelData()*/) {\n        return false;\n    }\n\n```  "},{"title":"PermissionUtil treats 0x0000000000000000000000000000000000000000 special with respect to transfer_operator, but not mint_operator or burn_operator","severity":"MEDIUM","mitigation":"Either disallow the zero address for mint_operator and burn_operator the same way as transfer_operator; or allow it for transfer_operator the same way as mint_operator and burn_operator."},{"title":"ERC721 inheritor can’t use ERC827 transfers","severity":"HIGH","mitigation":"Remove the _beforeTokenTransfer in the ERC721 _transferToken function, like how it’s removed in the `_afterTokenTransfer`."},{"title":"Money loss from assets locked in contracts due to missing checks in ERC20 transferFrom function","severity":"MEDIUM","mitigation":"Ensure that checks-effects-interactions pattern is applied when that safeTransferFrom function of AssetFreezerFOT is called."},{"title":"ERC20: address(0) user can lose all their tokens","severity":"HIGH","mitigation":"Change the address(0) to address(this) or use msg.sender.\n\n```solidity\nrequire(sender != address(0), \"ERC20: transfer from the zero address\");\nrequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n```\ncan be abused by the swapAndPool exploit where a malicious NFT can transfer other people's tokens to itself, then destory self and claim reward."},{"title":"ERC20 Compliance is Incomplete, While Missing The Approval Checks in `transfer` and `transferFrom`","severity":"MEDIUM","mitigation":"consider adding the following lines of code to the `transfer` function:\n```solidity\nfunction transfer(address recipient, uint256 amount) external returns (bool) {\n        _balances[msg.sender] = _balances[msg.sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(msg.sender, recipient, amount);\n        _approve(msg.sender, msg.sender, _allowed[msg.sender][msg.sender].sub(amount))\n        return true;\n    }\n```"},{"title":"ERC20: missing to parameter in _beforeTokenTransfer can break snapshot functionality in child contract","severity":"MEDIUM","mitigation":"Actually implement the intended parameter: `_beforeTokenTransfer(_msgSender(), to, value);`"},{"title":"Possible sticking mint","severity":"MEDIUM","mitigation":"Add the same `cooldown`-assertion as in the `_stake`-function:\n\n```solidity\n        require(cooldownAmount > 0, \"ERC20StakingRewardsFacet: zero cooldown operation\");\n```"},{"title":"Owner can inflate supply","severity":"MEDIUM","mitigation":"Add a check to make `mint` only callable by  the owner, and it will only be able to mint up to `cap`\n\n#"},{"title":"Access control issues","severity":"MEDIUM","mitigation":"Either add `onlyOwner` or `burner` modifier to the `_burn` function"},{"title":"Reentrancy from ERC20._burn from transferred attacker contract lets attacker keep NFT if using with Marketplace","severity":"MEDIUM","mitigation":"You can fix this by adding `isBuringGuard` check to `MarketNFT._burnERC721Token`: \n\n#      @dev\n     -    function _beforeERC721TokenTransfer(address from, uint256 tokenId)\n     +    function _beforeERC721TokenTransfer(address from, uint256 tokenId)\n                  internal\n                  override(ERC721MarketBase)\n                  {\n     +              require(nft.isBuringGuard() == false, \"isBuringGuard\");\n\n#     +    /**\n    +     * @return boolean\n    +     */\n    +    function isBuringGuard() external view  returns (boolean){\n    +        return _isBuringGuard;\n    +    }\n\nThis will make using the proposed guard a little more complicated for the attacker if there is buring guard check on the market NFT token contract."},{"title":"`VestingToken.approve()` is not overridden and will not track recently approved user/s","severity":"MEDIUM","mitigation":"Override `VestingToken.approve()` and call `ERC20.approve(_spender, _amount) and keep track of the`tick`and`nextTick`."},{"title":"approve() not updating ```_msgSender()``` approvals___","severity":"MEDIUM","mitigation":"Implement ``_beforeTokenTransfer()`` and ``_afterTokenTransfer()`` to ensure that apprval events are correct\n\n    ```\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {\n        require(from == to, \"Only individual transfers are allowed\");\n        require(!_exists(tokenId), \"Token already exists\");\n\n        address enforcetStarAddr = IFandom(fandom).enforceToken();\n        address submitterAddr = IFandom(fandom).submitter();\n\n        if(to == enforcetStarAddr)  {\n            currentId[type(to)] = currentId[type(to)].add(1);     \n        } else if(to == submitterAddr) {\n            currentId[type(to)] = currentId[type(to)].add(1);\n        } \n    }\n    \n\n    ```"},{"title":"ERC20 approval should allow spender to be the zero address","severity":"MEDIUM","mitigation":"Allow the `spender` parameter to be the zero address in `_approve`:\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n+        if (spender != address(0)) {\n            require(spender != address(0), \"ERC20: approve to the zero address\");\n            _allowances[owner][spender] = amount;\n+        }\n    }"},{"title":"Not so much context present in contract","severity":"MEDIUM","mitigation":"The code is written in a way to avoid swc 113 issue. Though let the developer team be very open about introducing changes to decimal(s) which is a very elementary and basic property of a token, both for users and future smart contracts, as the meaningful warnings in source code is not available anymore not to change decimals later"},{"title":"AlsoBoredERC20 methods for View/Exeternal View Functions do not specify the correct virtual modifier.","severity":"MEDIUM","mitigation":"Mark the methods in the base `ERC20` as `virtual`. This will make them visible in the derived contracts external interface and the mentioned hardhat mainnet run script will work as expected."},{"title":"`_mintShard` and `_burnShard` should be changed to public","severity":"MEDIUM","mitigation":"Make `_mintShard` and `_burnShard` functions public for the protocol to be upgradeable."},{"title":"Allowance for zero address doesn't work properly for ERC-20","severity":"MEDIUM","mitigation":"You should check 0 address case like OpenZeppelin implementations:\n```solidity\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n```"},{"title":"ERC20 super contract does not call _beforeTokenTransfer","severity":"MEDIUM","mitigation":"Call _beforeTokenTransfer in other.sol.\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        ERC721._beforeTokenTransfer(from, to, tokenId);\n        owner._beforeTokenTransfer(from, to, tokenId);\n    }"},{"title":"_msgSender() called in constructor","severity":"MEDIUM","mitigation":"Remove the call to `_msgSender()` from the constructor."},{"title":"Reentrancy exploit when `acceptOwnership` is called directly by owner","severity":"MEDIUM","mitigation":"Apply the fix described in the last point."},{"title":"`OWNABLE` logic allows in-use variables to be redeclared","severity":"MEDIUM","mitigation":"Add the following check:\n\n    modifier onlyOwner() {\n        require(_msgSender() == _owner, \"LIP14: NOT_OWNER\");\n\n        _;  \n+        require(_msgSender() != _owner, \"ABAC: TAMP_OWNER\");\n+    }"},{"title":"The renounceOwnership method can be initialized incorrectly","severity":"MEDIUM","mitigation":"Simply initiate the `_allOwners` mapping in the constructor.\n\n***"},{"title":"ERC721Owner may lose ownership()","severity":"MEDIUM","mitigation":"Do NOT follow ERC721's implementation of `renounceOwnership()` and `transferOwnership(address newOwner)` for `Support&BuyAdminRole`. \nCall revokeRole(owner, role) instead of owner = newOwner."},{"title":"Misuse of the transferOwnership function can render the contract un-upgradable","severity":"MEDIUM","mitigation":"The transferOwnership function should only be callable by the contract owner in the initial state and by the new owner when a transfer is pending:\n```solidity\n    function transferOwnership(address newOwner) public onlyPendingOwner{\n        require(OWnEe.owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    // no other changes\n    }\n\n\nfunction acceptOwnership() public onlyPendingOwner{\nrequire(msg.sender == constructingAddress, \"Ownable: Not constructed\");\n``\nThen, ownership transfers can be properly managed."},{"title":"A # of share in a user's position can be inflated to exploit it","severity":"MEDIUM","mitigation":"Use stakedLP balance in masterChef to proportionally distribute SUSHI reward, instead of share balance."},{"title":"GovernorBravoDelegator.sol has multiple vulnerabilities that have been uncovered in YAMGovernanceStorage.sol","severity":"MEDIUM","mitigation":"The code should be reviewed in comparison to the original and changes adapted or adequate justifications provided."},{"title":"Partially incorrect vote delegation implementation","severity":"MEDIUM","mitigation":"The issue is incorrectly reported. Functions `balanceOf` and `numCheckpoints` are implemented correctly and correctly read. However Aragon is not up to date, so voting can really cost gas and not only a signature, so it is better to implement with latest specification in mind. ERC20 Snapshot Standard v1.1 has been implemented with this mistake."},{"title":"The Checkpoint struct should have a 'toBlock' field","severity":"MEDIUM","mitigation":"Add the 'toBlock' field to the Checkpoint struct:\n\n```solidity\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint32 toBlock; // Aegis\n        uint256 votes;\n    }\n```\n\n#"},{"title":"Users’ voting right is diluted due to gas limit","severity":"HIGH","mitigation":"Use a dedicated mapping instead of an enumerable check-point array."},{"title":"EIP712 DOMAIN_TYPEHASH may be inconsistent within the same ecosystem","severity":"MEDIUM","mitigation":"```solidity\n    /// @title SubGraphFund's decentralized exchange\n        /// @notice The EIP-712 typehash for the domain of the Exchange chainID\n        bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId) Exchange domain\")\n        ```\n\n\n****"},{"title":"ERC 3009 Delegation incorrect mixing state issue","severity":"MEDIUM","mitigation":"Mirroring how it is implemented in the ERC 7215 interface, such as the previous cache state that is obtained by reading from memory, and not state the current one.\n\n```solidity\n    function _changeDelegate(\n        address delegate,\n        bytes memory sig,\n        Timestamp calldata time\n    ) internal {\n\n    - nonces[msg.sender]++;\n    + uint256 nonceValue = nonces[msg.sender];\n\n        address previousDelegate = getCurrentDelegate(msg.sender, time);\n\n    - bytes32 payloadHash = keccak256(\n    -     abi.encodePacked(\n    -         keccak256(\"ChangeDelegate(address delegate, address delegator, Timestamp time)\"),\n    -         delegate,\n    -         msg.sender,\n    -         time\n    -     )\n    - );\n            // Now It uses local variable value to prevent reordering attack\n            bytes32 payloadHash = keccak256(\n              abi.encodePacked(\n                  keccak256(\"ChangeDelegate(address delegate, address delegator, Timestamp time)\"),\n                  delegate,\n                  msg.sender,\n                  time,\n    -         nonces[msg.sender]\n    +         nonceValue\n            ));\n\n\n\n    ```\n\n#"},{"title":"Reentrancy attack on delegate burner","severity":"MEDIUM","mitigation":"Delegate the user's votes first, then perform the updates previously performed as part of the `delegate()` function.\n\nThe safe approach is to **always follow the checks-effects-interactions pattern**."},{"title":"Link delegation contracts as they are lead to nothing","severity":"MEDIUM","mitigation":"Add a delegated to field the same as votee and link it accordingly on the delegation call, also naming convention..\n\n```solidity\n    function delegates(address delegator) public view returns (address) {\n        return address(delegatee[delegator]) == address(0) ? delegator : delegatee[delegator];\n    }\n}\n```\n\n#"},{"title":"Post Gonzalo's proposal or whenUnlocked…NFTs can be locked and status vs slashing","severity":"MEDIUM","mitigation":"The proposal should include a provision that the voters don't get slashed if the proposal execute code exploits a software vulnerability, unless is proved that the voter was actor on the exploit or a reasonable external security audit would had found the software vulnerability, or similar.\nBut currently, even if the proposal is an explicit malicious proposal that steals everyone else's NFTs, against the protocol interest, the voters that don't exec wouldn't get slashed.\nSo, `UserData.slashedByItself` should be status=true whenever no ParentInAdminMode, even `slashing/SlashAll() applyFee` was called.”"},{"title":"`gatekeeperVoted` user's voting power may become as low as 0","severity":"HIGH","mitigation":"No change is required, but users should be aware that some actions should be taken to avoid their voting power becoming 0."},{"title":"Malicious user can sign a message for the delegate or vote themselves despite the big slashing mechanism","severity":"HIGH","mitigation":"Recycling the `+_DELEGATE_TYPE_HASH` hash trick utilized in the \n[swapToTopPrivateKey()](https://pancakeswap.github.io/swap) function for every signed message.\n#"},{"title":"Anyone can create unexpected shutdowns","severity":"MEDIUM","mitigation":"Add a `onlyOperator` or `onlyGovernance` modifier to stop the protocol."},{"title":"PartitionManager and EmptyChain don’t use CHAIN_ID, which make them vulnerables to replay attack","severity":"MEDIUM","mitigation":"Fix PartitionManager and EmptyChain like the above snippet."},{"title":"Anyone can break slippage fee in FDL contract","severity":"MEDIUM","mitigation":"Fix the timestamp of the current block."},{"title":"ECDSA signature sould be canonical and can be replayed from onchain transaction","severity":"MEDIUM","mitigation":"sig_r, sig_s leading zero padding needs to be removed when it is recomputed from onchain transaction and verify function itself should check the signature is canonical or not."},{"title":"Potential Reentrancy when Inheritor Uses EIP712 and Interacts with NFT721 Facets","severity":"MEDIUM","mitigation":"Implement the nonReentrant modifier in any inherited contract that is likely to be affected."},{"title":"YSD is at risk to proxy Delegation in Sushi and get slashed","severity":"HIGH","mitigation":"Delegates are only allowed to be set on specific contract addresses, however, it is trivial for the governance to set an arbitrary address as the delegate. It is therefore suggested to add an event on `SushiBar` to become aware of secret proxy delegates and to be sure which addresses are the delegates."},{"title":"Accounts with less than 100 umi will not be able to transfer tokens","severity":"HIGH","mitigation":"Providing an interface for user voting is unnecessary. Remove the current and delegated voting balances."},{"title":"Arbitrary concluded and claimed stakes in multiple protocols by MaXSS.","severity":"MEDIUM","mitigation":"Track down the user's stakes based on Time nodes only."},{"title":"DelegateCall is used in VotingEscrow, so that there are solid concerns about the mentioned functions' security","severity":"MEDIUM","mitigation":"The `getPriorVotes` and `getSnapshottedBalance` functions should be added to the global `VotingEscrow` contract, so that it can be pulled every time a snapshot is taken for different address types by only using `sload(keccak256('getPriorVotes address'))` based on snapshotId, without the need to trust any other address that the `VotingEscrow` contract mentions."},{"title":"Possible current-block manipulation when counting votes in GovernorAlpha.getPriorVotes()","severity":"MEDIUM","mitigation":"In addition to considering multiple reorg level blocks around `blockNumber`, consider counting `account`'s votes at the `block.number` you are in the same way and in the same place as your deployment before it was deployed live.\n\n\n  ***\n  An example of such a reorg level inclussion\n  ```diff\n  -      uint nCheckpoints = token.checkpoints(account,_fromBlockMax);\n  +      uint nCheckpoints = token.getPriorCheckpoints(account,_fromBlockMin,blockNumberOld);\n  ```\n\n  and we will get the value of `blockNumberOld` from `LatestBlockMarker`\n\n  ***\n\n\n\n  With the proposed includes we can address possible number manipulation by other validators."},{"title":"Libraries proposed by OpenZeppelin, such as SushiSwapMayor and Revocable, not implemented correctly","severity":"MEDIUM","mitigation":"It is highly recommended to use OpenZeppelin's high quality on-chain libraries rather than the recommended community published libraries. OpenZepliln's libraries have been heavily and formally tested."},{"title":"User is not protected against accumulating votes in case the total supply changes","severity":"MEDIUM","mitigation":"Implement the votesCalculation variable that will calculate current votes based on the balance of the user and totalVotesSupply. In case you couldn't calculate current votes due to totalVotesSupply equal to 0, throw an exception."},{"title":"After applying some of the proposed mitigation contracts can still hold infinite FISH or SOCKS for the first few blocks","severity":"MEDIUM","mitigation":"Consider adding the check for `previous = sqrtBalance` in the upper boundary check."},{"title":"`- (upper - lower) / 2` has wrong traversing direction, using `center = lower + (upper - lower) / 2` will be more standard","severity":"MEDIUM","mitigation":"Replace `center = upper - (upper - lower) / 2` with `center = lower + (upper - lower) / 2`.\n```js\n       while (upper > lower) {\n            uint32 center = lower + (upper - lower) / 2; // ceil, avoiding overflow\n```"},{"title":"Bugs in off-chain oracles part 1: underflow can turn greater into below","severity":"MEDIUM","mitigation":"The general form of the recommendations for overflow/underflow safety in improving the safety of off-chain oracles are as follows:\n1. Identify all points in the code where arithmetic operations are made using user-provided oracles' results and then immediately proceed at the lowest risk from that oracle to the highest risk.\n2. For each couple identified at point 1, test that the difference between the results from user-provided oracle A and user-provided oracle B—in units adjusted for their address—will not cause overflow/underflow in the full range of the variable where the difference is assigned."},{"title":"A user address that is used as an indexer to `delegates` might point to a balances[][] corrupter and indirectly to malcipulating global values like supply","severity":"MEDIUM","mitigation":"Removing `balanc[@delegatee][operator]`, lets `delegates[@operator][@delegatee] = false;` be a malicuious option"},{"title":"Frontrunning delegate changes against less informed users is possible","severity":"MEDIUM","mitigation":"Implement _getDelegates parameter proposal (cf Compound's cRari) or include a voting delay to protect less informed token holders."},{"title":"Stuck Transfers","severity":"MEDIUM","mitigation":"On stake:\n-Increment totalStakedDINGO without fees.\n-Expand updateTotalRewards() \n\naddress this contract should change to:\n-Update getCurrentVotePowerTokens() to take account the staked tokens\n\nIt is a medium finding because I can't really find where the attacker will profit from them not fixing such a vuln."},{"title":"Especially the swap and transfer of TEAM may bring huge risk to the project in terms of governance","severity":"MEDIUM","mitigation":"To minimize the damage in case the swap is still needed, TEAM transfer function should be implemented as described below:\n\n\n    /// @notice Transfers `amount` of TEAM from the caller to `to` address.\n    function transferTeam(address to, uint96 amount) external lockSupply {\n        // Reduce the user's balance and the total supply\n        balances[msg.sender] -= amount;\n        totalSupply -= amount;\n        // Increase the receiver's unlock time\n        unlockedAt[to] = uint40(block.timestamp) + 365 days;\n        // Transfer TEAM from msg.sender to the receiver\n        ERC20._transfer(msg.sender, to, amount);\n        emit Transfer(msg.sender, to, amount);\n    }\n\n***OR*** if the swap is the only option:\n\n\n    /// @notice Transfers `amount` of TEAM from the caller to `to` address.\n    function transferTeam(address to, uint96 amount) external lockSupply {\n        require(block.timestamp >= unlockedAt[msg.sender], \"LOCKED\");\n        // Reduce the user's balance\n        balances[msg.sender] -= amount;\n        // Increase the sender's or receiver's unlock time\n        unlockedAt[to] = uint40(unlockedAt[to] + unlockedAt[msg.sender] * amount / balances[to]);\n\n        unlockedAt[msg.sender] =  uint40(block.timestamp + 365 days * (uint64(amount) ** TRANFER_TEAM_NOMINATOR / balances[to] ** TRANFER_TEAM_DENOMINATOR)); \n\n    ***}\n    }\n    \n\n***may be considered to be swapped equally in the same amount instantaneously.\n\nFor the second option to be considered, an AMP (stateful) will need to be utilized as follows:\n\n    address sender = msg.sender;\n    ...\n    address receiver = to;\n    ...\n    // Increase the sender or receiver's unlock time\n    unlockedAt[msg.sender] = AMP_totalSupply[block.timestamp][msg.sender][ receiver] += 365 days * (uint64(amount) ** TRANFER_TEAM_NOMINATOR / balances[receiver] ** TRANFER_TEAM_DENOMINATOR);\n    \n    unlockedAt[receiver] = AMP_totalSupply[block.timestamp][ receiver][ msg.sender] += 365 days; \n    ..."},{"title":"GovernorAlpha votes are not always proportional, as intended","severity":"MEDIUM","mitigation":"The attack vector discovered by the researcher might not be as severe as he claimed. Nevertheless, we recommend that you adapt your code to use more regular and less error-prone arithmetic and adjust the vote amount in each checkpoint of an account by the ratio of the total supply when it was created over the value of the total supply at the time the checkpoint was created."},{"title":"All asset can be stolen by hacker","severity":"CRITICAL","mitigation":"It is recommended to use the callProxy() call to prevent loss."},{"title":"`_writeCheckpoint` should not be private","severity":"MEDIUM","mitigation":"Add the `internal` keyword to `_writeCheckpoint`."},{"title":"Delegates can entirely evade cooloff period by casting vote.","severity":"MEDIUM","mitigation":"Enforce the delegator to hold the specific votes for the monolicualr proposal for a specified period, say: (3 + 1)pwait until the votes could be casted, where pwait is selected such that:<br>At block rate of F blocks/week, pwait = 1/(2*F). This indicates that if the delegator acquire sufficient votes for the particular proposal just after considering the proposal in at the current height, the delegator is still unable to cast the particular proposal for the remaining duration of the current block."},{"title":"CORE: DelegateVotesChanged can be gamed into underflowing a uint'","severity":"MEDIUM","mitigation":"Consier checking the overflow of votes: \n```solidity\nif (newVotes<oldVotes){\n                unchecked { nCheckpoints -= 1;\n                oldVotes = nCheckpoints > 0 ? checkpoints[delegatee][nCheckpoints - 1].votes : 0;\n                newVotes = votes; }}}\n```"},{"title":"The assumption that type `uint` is 256 bits is sometimes wrong","severity":"MEDIUM","mitigation":"Use solidity built-in type `uint256` to represent 256 big unsigned integer.\nOr check for overflow/underflow explicitly which was not the case in current implementation."},{"title":"Frontrunning concerns with Multichain NFT support","severity":"MEDIUM","mitigation":"The OpenZeppelin Defender team recommended to use an NFT bridge focused contract that specifically supports L2 NFTs and is designed to eliminate the risks of frontrunning and recentitralization attacks like the L1 bridge model they used."}]