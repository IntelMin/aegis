{"locs": [["code-423n4/2023-08-verwa", "main", "src/GaugeController.sol", "L211> <br><https://github.com/code-423n4/2023-08-verwa/blob/main/src/VotingEscrow.sol#L356>"]], "vuln": "Voters from VotingEscrow can vote infinite times in vote_for_gauge_weights() of GaugeController", "severity": "HIGH", "mitigation": "The vulnerability comes from the fact that the voting power is fetched from the current timestamp, instead of n blocks in the past, allowing users to vote, delegate, vote again and so on. Thus, the voting power should be fetched from n blocks in the past.\n\nAdditionaly, note that this alone is not enough, because when the current block reaches n blocks in the future, the votes can be replayed again by having delegated to another user n blocks in the past. The exploit in this scenario would become more difficult, but still possible, such as: vote, delegate, wait n blocks, vote and so on. For this reason, a predefined window by the governance could be scheduled, in which users can vote on the weights of a gauge, n blocks in the past from the scheduled window start."}
{"locs": [["GenerationSoftware/pt-v5-vault-boost", "9d640051ab61a0fdbcc9500814b7f8242db9aec2", "src/VaultBoosterFactory.sol", "L29>"]], "vuln": "Create methods are suspicious of the reorg attack", "severity": "MEDIUM", "mitigation": "Deploy such contracts via `create2` with `salt` that includes `msg.sender`."}
{"locs": [["GenerationSoftware/pt-v5-vault-boost", "9d640051ab61a0fdbcc9500814b7f8242db9aec2", "src/VaultBooster.sol", "L171-L176)"]], "vuln": "`VaultBooster`: users tokens will be stuck if they deposited with unsupported boost tokens", "severity": "MEDIUM", "mitigation": "Update `deposit` function to revert if the user tries to deposit unsuppoerted tokens (that doesn't have a boost set):\n\n```diff\n  function deposit(IERC20 _token, uint256 _amount) external {\n+    if(_boosts[_token].liquidationPair==address(0)) revert();\n    _accrue(_token);\n    _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n    emit Deposited(_token, msg.sender, _amount);\n  }\n```\n\n#"}
{"locs": [["code-423n4/2023-07-moonwell", "main", "src/core/MultiRewardDistributor/MultiRewardDistributor.sol", "L1147-L1247>"]], "vuln": "Malicious `emissionToken` could poison rewards for a market", "severity": "MEDIUM", "mitigation": "Consider adding a way for `admin` to remove an `emissionConfig`.\n\nAlternatively, the reward transfer could be wrapped in a `try`/`catch` and returning `_amount` in `catch`. Be mindful to only allow a certain amount of gas to the transfer then as otherwise the same attack works with consuming all gas available."}
{"locs": [["code-423n4/2023-07-moonwell", "fced18035107a345c31c9a9497d0da09105df4df", "test/proposals/mips/mip00.sol", "L77>"]], "vuln": "Incorrect chainId of Base in deploy script will force redeployment", "severity": "MEDIUM", "mitigation": "Change Base Network ID to 8453."}
{"locs": [["code-423n4/2023-07-moonwell", "main", "src/core/MultiRewardDistributor/MultiRewardDistributor.sol", "L703-L725>"]], "vuln": "A single emissionCap is not suitable for different tokens reward if they have different underlying decimals", "severity": "MEDIUM", "mitigation": "Consider creating emissionCap for each rewardTokens so they can be adapted based on their own decimals."}
{"locs": [["GenerationSoftware/pt-v5-vault", "b1deb5d494c25f885c34c83f014c8a855c5e2749", "src/Vault.sol", "L394-L402>"]], "vuln": "`Vault.mintYieldFee` function can be called by anyone to mint `Vault Shares` to any recipient address", "severity": "HIGH", "mitigation": "Hence, it is recommended to use the `_yieldFeeRecipient` state variable value as the `yield fee recipient` inside the `Vault.mintYieldFee` external function and to remove the input parameter `address _recipient` from the `Vault.mintYieldFee` function; so that the caller will not be able to mint shares to any arbitrary address of their choice and steal the yield fee of the protocol.\n\nThe updated function should be as follows:\n\n```solidity\n  function mintYieldFee(uint256 _shares) external {\n    _requireVaultCollateralized();\n    if (_shares > _yieldFeeTotalSupply) revert YieldFeeGTAvailable(_shares, _yieldFeeTotalSupply);\n\n    _yieldFeeTotalSupply -= _shares;\n    _mint(_yieldFeeRecipient, _shares);\n\n    emit MintYieldFee(msg.sender, _recipient, _shares);\n  } \n```"}
{"locs": [["GenerationSoftware/pt-v5-vault", "b1deb5d494c25f885c34c83f014c8a855c5e2749", "src/VaultFactory.sol", "L67-L78>"]], "vuln": "An attacker can front-run `deployVault` to deploy at the same address", "severity": "MEDIUM", "mitigation": "Use `CREATE2` and the vault config as salt.\n\n#"}
{"locs": [["GenerationSoftware/pt-v5-vault", "b1deb5d494c25f885c34c83f014c8a855c5e2749", "src/VaultFactory.sol", "L55) function allows deploying `Vault` contracts. The factory contract maintains a [mapping to verify that a vault has been deployed via the factory](https://github.com/GenerationSoftware/pt-v5-vault/blob/b1deb5d494c25f885c34c83f014c8a855c5e2749/src/VaultFactory.sol#L32-L36). This allows users to check the authenticity of a vault to ensure the that implementation of a vault is authentic (i.e. not altered/malicious)."]], "vuln": "`VaultFactory` allows deployment of vaults with non-authentic `TwabController` and `PrizePool`", "severity": "MEDIUM", "mitigation": "Consider implementing `TwabController` and `PrizePool` factory contracts. In the contracts, consider tracking the addresses of the deployed `TwabController` and `PrizePool` contracts. In the `VaultFactory.deployVault` function, consider checking that the passed `_twabController` and `_prizePool` address were deployed via the respective factory contracts."}
{"locs": [["GenerationSoftware/pt-v5-prize-pool", "4bc8a12b857856828c018510b5500d722b79ca3a", "src/PrizePool.sol", "L963-L968) & [`totalContributed`](https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/PrizePool.sol#L951-L956) variables are computed on the `DrawAccumulatorLib` library, and [they are computed and returned as `uint256` values.](https://github.com/GenerationSoftware/pt-v5-prize-pool/blob/4bc8a12b857856828c018510b5500d722b79ca3a/src/libraries/DrawAccumulatorLib.sol#L166-L307)"]], "vuln": "Silent overflow could alter computation when calculating the `vaultPortion` in the `PrizePool` contract", "severity": "MEDIUM", "mitigation": "Make sure to implement a safe cast that checks if overflows occur to prevent computing a totally different value than what it should really be. Use `OZ safeCast` library for this type of operation.\n\n#"}
{"locs": [["GenerationSoftware/pt-v5-vault", "8985bead1be85ae6822cd329933f5a53de05c237", "src/Vault.sol", "L1208"]], "vuln": "Improper handling of cases when withdrawable assets = 0", "severity": "MEDIUM", "mitigation": "Since `_withdrawableAssets` is the dividend, there seems to be no harm in removing the check if `_withdrawableAssets` `= 0`. Therefore, I recommend removing it from the condition.\n\n#"}
{"locs": [["GenerationSoftware/pt-v5-prize-pool", "4bc8a12b857856828c018510b5500d722b79ca3a", "src/PrizePool.sol", "L434-L436) and the bot will face losses."]], "vuln": "`Claimer.claimPrizes` can be front-runned in order to make losses for the claim bot", "severity": "MEDIUM", "mitigation": "In the case of if a price is already claimed, then you can return early from the `PrizePool.claimPrize` function and emit some event. In this case, bots will not receive fee for the already claimed prize and their tx will continue with other prizes in the batch.\n\n#"}
{"locs": [["GenerationSoftware/pt-v5-claimer", "57a381aef690a27c9198f4340747155a71cae753", "src/Claimer.sol", "L76)"]], "vuln": "Inconsistent behavior for canary claims in the `claimer`", "severity": "MEDIUM", "mitigation": "Consider canary as a `claim`.\n\n```diff\n    uint96 feePerClaim = uint96(\n      _computeFeePerClaim(\n        _computeMaxFee(tier, prizePool.numberOfTiers()),\n        claimCount,\n-        prizePool.claimCount()\n+        prizePool.claimCount() + prizePool.canaryClaimCount()\n      )\n    );\n\n```\n\n#"}
{"locs": [["nounsDAO/nouns-monorepo", "718211e063d511eeda1084710f6a682955e80dcb", "packages/nouns-contracts/contracts/governance/NounsDAOV3Proposals.sol", "L571-L581>"]], "vuln": "`NounsDAOV3Proposals.cancel()` should allow to cancel the proposal of the Expired state", "severity": "MEDIUM", "mitigation": "Consider adding a proposal expiration time field in the Proposal structure.\n\n```diff\n    function queue(NounsDAOStorageV3.StorageV3 storage ds, uint256 proposalId) external {\n        require(\n            stateInternal(ds, proposalId) == NounsDAOStorageV3.ProposalState.Succeeded,\n            'NounsDAO::queue: proposal can only be queued if it is succeeded'\n        );\n        NounsDAOStorageV3.Proposal storage proposal = ds._proposals[proposalId];\n        INounsDAOExecutor timelock = getProposalTimelock(ds, proposal);\n        uint256 eta = block.timestamp + timelock.delay();\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            queueOrRevertInternal(\n                timelock,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        proposal.eta = eta;\n+       proposal.exp = eta + timelock.GRACE_PERIOD();\n...\n-       } else if (block.timestamp >= proposal.eta + getProposalTimelock(ds, proposal).GRACE_PERIOD()) {\n+       } else if (block.timestamp >= proposal.exp) {\n            return NounsDAOStorageV3.ProposalState.Expired;\n```"}
{"locs": [["code-423n4/2023-07-basin", "c1b72d4e372a6246e0efbd57b47fb4cbb5d77062", "src/libraries/LibBytes16.sol", "L45> <br><https://github.com/code-423n4/2023-07-basin/blob/c1b72d4e372a6246e0efbd57b47fb4cbb5d77062/src/libraries/LibLastReserveBytes.sol#L58>"]], "vuln": "Due to slot confusion, reserve amounts in the pump will be corrupted, resulting in wrong oracle values", "severity": "MEDIUM", "mitigation": "Change the `sload()` operation in both affected functions to `sload(add(slot, mul(maxI, 32)`"}
{"locs": [["BeanstalkFarms/Basin", "91233a22005986aa7c9f3b0c67393842cd8a8e4d", "src/functions/ConstantProduct2.sol", "L49)."]], "vuln": "There is a large precision error in sqrt calculation of lp", "severity": "MEDIUM", "mitigation": "Excess reserve tokens should be returned when the user adds liquidity"}
{"locs": [["BeanstalkFarms/Basin", "91233a22005986aa7c9f3b0c67393842cd8a8e4d", "src/Aquifer.sol", "L40)."]], "vuln": "`boreWell` can be frontrun/DoS-d", "severity": "MEDIUM", "mitigation": "To mitigate the identified security issues, it is recommended to make the upcoming Well address user-specific by combining the `salt` value with the user's address. This ensures that each user's Well has a unique address and prevents frontrunning attacks and DoS attacks. The following code snippet demonstrates the recommended modification:\n\n```\nwell = implementation.cloneDeterministic(\n    keccak256(abi.encode(msg.sender, `salt`))\n);\n\n```"}
{"locs": [["BeanstalkFarms/Basin", "91233a22005986aa7c9f3b0c67393842cd8a8e4d", "src/pumps/MultiFlowPump.sol", "L109).)"]], "vuln": "Treating of BLOCK_TIME as permanent will cause serious economic flaws in the oracle when block times change", "severity": "MEDIUM", "mitigation": "The BLOCK_TIME should be changeable, given a long enough freeze period where LPs can withdraw their tokens if they are unsatisfied with the change."}
{"locs": [["code-423n4/2023-07-basin", "9403cf973e95ef7219622dbbe2a08396af90b64c", "src/Well.sol", "L610> <br><https://github.com/code-423n4/2023-07-basin/blob/9403cf973e95ef7219622dbbe2a08396af90b64c/src/Well.sol#L304> <br><https://github.com/code-423n4/2023-07-basin/blob/9403cf973e95ef7219622dbbe2a08396af90b64c/src/Well.sol#L370>"]], "vuln": "Transferout exclusive `feeOnTransfer` tokens will run out of well", "severity": "MEDIUM", "mitigation": "Check the correct amount every time you transfer out."}
{"locs": [["lukso-network/lsp-smart-contracts", "v0.10.2", "contracts/LSP6KeyManager/LSP6Utils.sol", "L169-L177) for the code of `combinePermissions`."]], "vuln": "Permission escalation by adding the same permission twice", "severity": "MEDIUM", "mitigation": "The permissions shouldn't be added, but they should be `OR`'d.\nHere is a way to solve this:\n\n```diff\nfunction combinePermissions(bytes32[] memory permissions) internal pure returns (bytes32) {\n    uint256 result = 0;\n    for (uint256 i = 0; i < permissions.length; i++) {\n-      result += uint256(permissions[i]);\n+      result |= uint256(permissions[i]);\n    }\n    return bytes32(result);\n}\n```\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "main", "contracts/lybra/token/EUSD.sol", "L299-#L306> <br><https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L414-#L418>"]], "vuln": "`EUSD.mint` function wrong assumption of cases when calculated sharesAmount = 0", "severity": "HIGH", "mitigation": "I recommend checking again in `EUSD.mint` function if `sharesAmount` is 0 and `totalSupply` is not 0, then exit the function without minting anything."}
{"locs": [["code-423n4/2023-06-lybra", "26915a826c90eeb829863ec3851c3c785800594b", "contracts/lybra/governance/LybraGovernance.sol", "L120-L122>"]], "vuln": "`_voteSucceeded()` returns true when `againstVotes > forVotes` and vice versa", "severity": "HIGH", "mitigation": "Swap 1 and 0:\n\n```solidity\n    function _voteSucceeded(uint256 proposalId) internal view override returns (bool){\n        return proposalData[proposalId].supportVotes[0] > proposalData[proposalId].supportVotes[1];\n    }\n```\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "26915a826c90eeb829863ec3851c3c785800594b", "contracts/lybra/governance/LybraGovernance.sol", "L120-L122>"]], "vuln": "Governance wrongly calculates `_quorumReached()`", "severity": "HIGH", "mitigation": "Use `totalVotes`:\n\n```solidity\n    function _quorumReached(uint256 proposalId) internal view override returns (bool){\n        return proposalData[proposalId].totalVotes >= quorum(proposalSnapshot(proposalId));\n    }\n```\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "7b73ef2fbb542b569e182d9abf79be643ca883ee", "contracts/lybra/token/esLBR.sol", "L33> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L40>"]], "vuln": "Allowing `refreshReward()` to fail during minting or buring esLBR could result in gain or loss previously earned reward", "severity": "MEDIUM", "mitigation": "The `refreshReward()` function should be a mandatory action inside either the `mint()` or `burn()` functions. The try-catch statement should be removed."}
{"locs": [["code-423n4/2023-06-lybra", "5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6", "contracts/lybra/pools/base/LybraPeUSDVaultBase.sol", "L157-L168>"]], "vuln": "`LybraPeUSDVaultBase.rigidRedemption` should use `getBorrowedOf` instead of `borrowed`", "severity": "MEDIUM", "mitigation": "Change to:\n\n```diff\n    function rigidRedemption(address provider, uint256 peusdAmount) external virtual {\n        require(configurator.isRedemptionProvider(provider), \"provider is not a RedemptionProvider\");\n-       require(borrowed[provider] >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n+       require(getBorrowedOf(provider) >= peusdAmount, \"peusdAmount cannot surpass providers debt\");\n        uint256 assetPrice = getAssetPrice();\n-       uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / borrowed[provider];\n+       uint256 providerCollateralRatio = (depositedAsset[provider] * assetPrice * 100) / getBorrowedOf(provider);\n        require(providerCollateralRatio >= 100 * 1e18, \"provider's collateral ratio should more than 100%\");\n        _repay(msg.sender, provider, peusdAmount);\n        uint256 collateralAmount = (((peusdAmount * 1e18) / assetPrice) * (10000 - configurator.redemptionFee())) / 10000;\n        depositedAsset[provider] -= collateralAmount;\n        collateralAsset.transfer(msg.sender, collateralAmount);\n        emit RigidRedemption(msg.sender, provider, peusdAmount, collateralAmount, block.timestamp);\n    }\n```\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "7b73ef2fbb542b569e182d9abf79be643ca883ee", "contracts/lybra/token/esLBR.sol", "L30-L32> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/esLBR.sol#L20> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L73-L77>"]], "vuln": "There is no mechanism that prevents from minting less than `esLBR` maximum supply in `StakingRewardsV2`", "severity": "MEDIUM", "mitigation": "Do one of the following:\n\n*   Introduce some mechanism that will enforce that esLBR max supply will never be achieved (something similar to Bitcoin halving, for example).\n*   Do not set esLBR max supply (still do your best to limit it to `100 000 000`, but if it goes above that number, users will still be able to claim their acquired rewards).\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "7b73ef2fbb542b569e182d9abf79be643ca883ee", "contracts/lybra/miner/stakerewardV2pool.sol", "L132-L150> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/ProtocolRewardsPool.sol#L227-L240> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/miner/EUSDMiningIncentives.sol#L226-L242>"]], "vuln": "Rewards for initial period can be lost in all of the synthetix derivative contracts", "severity": "MEDIUM", "mitigation": "A possible solution to the issue would be to set the start and end time for the current reward cycle when the first participant joins the reward program (i.e. when the total supply is greater than zero) instead of starting the process in the `notifyRewardAmount`."}
{"locs": [["code-423n4/2023-06-lybra", "7b73ef2fbb542b569e182d9abf79be643ca883ee", "contracts/lybra/pools/base/LybraEUSDVaultBase.sol", "L124> <br><https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/pools/base/LybraEUSDVaultBase.sol#L126>"]], "vuln": "No check for Individual mint amount surpassing 10% when the circulation reaches 10\\_000\\_000 in `mint()` of `LybraEUSDVaultBase` contract", "severity": "MEDIUM", "mitigation": "Add checks to the `mint()` to revert if mint amount is greater than 10% of the total supply, if total supply is >= 10,000,000.\n\n        function mint(address onBehalfOf, uint256 amount) external {\n            require(onBehalfOf != address(0), \"MINT_TO_THE_ZERO_ADDRESS\");\n            require(amount > 0, \"ZERO_MINT\");\n\n            if ( poolTotalEUSDCirculation >= 10_000_000 ) {\n             require(amount <= (10 * poolTotalEUSDCirculation) / 100, 'amount greater than 10% of circulation' );\n            }\n            _mintEUSD(msg.sender, onBehalfOf, amount, getAssetPrice());\n        }\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "main", "contracts/lybra/governance/LybraGovernance.sol", "L152>"]], "vuln": "`CLOCK_MODE()` will not work properly for Arbitrum or Optimism due to `block.number`", "severity": "MEDIUM", "mitigation": "Use `block.timestamp` rather than `block.number`\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "5d70170f2c68dbd3f7b8c0c8fd6b0b2218784ea6", "contracts/lybra/configuration/LybraConfigurator.sol", "L127>"]], "vuln": "Liquidation won't work when bad and safe collateral ratio are set to default values", "severity": "MEDIUM", "mitigation": "Instead of internal accessing variables, use functions `getSafeCollateralRatio()` and `getBadCollateralRatio()` in all the occurences because variables can be zero.\n\n#"}
{"locs": [["code-423n4/2023-06-lybra", "26915a826c90eeb829863ec3851c3c785800594b", "contracts/lybra/configuration/LybraConfigurator.sol", "L127> <br><https://github.com/code-423n4/2023-06-lybra/blob/26915a826c90eeb829863ec3851c3c785800594b/contracts/lybra/configuration/LybraConfigurator.sol#L202>"]], "vuln": "The relation between the safe collateral ratio and the bad collateral ratio for the PeUSD vaults is not enforced correctly", "severity": "MEDIUM", "mitigation": "Change:\n\n```solidity\nrequire(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] + 1e19, \"LNA\");\n```\n\nto:\n\n```solidity\nrequire(newRatio >= 130 * 1e18 && newRatio <= 150 * 1e18 && newRatio <= vaultSafeCollateralRatio[pool] - 1e19, \"LNA\");\n```\n\n#"}
{"locs": [["code-423n4/2023-06-canto", "main", "Canto/x/onboarding/keeper/ibc_callbacks.go", "L93-L96> <br><https://github.com/code-423n4/2023-06-canto/blob/a4ff2fd2e67e77e36528fad99f9d88149a5e8532/Canto/x/onboarding/keeper/ibc_callbacks.go#L124>"]], "vuln": "Potential risk of using `swappedAmount` in case of swap error", "severity": "MEDIUM", "mitigation": "Zero the `swappedAmount` variable in the error case:\n\n    swappedAmount = sdk.ZeroInt()\n\n#"}
{"locs": [["code-423n4/2023-06-llama", "9d641b32e3f4092cc81dbac7b1c451c695e78983", "src/strategies/LlamaRelativeQuorum.sol", "L223> <br><https://github.com/code-423n4/2023-06-llama/blob/9d641b32e3f4092cc81dbac7b1c451c695e78983/src/strategies/LlamaRelativeQuorum.sol#L242>"]], "vuln": "In `LlamaRelativeQuorum`, the governance result might be incorrect as it counts the wrong approval/disapproval", "severity": "HIGH", "mitigation": "`getApprovalQuantityAt()` and `getDisapprovalQuantityAt()` should return 1 instead of `quantity` for the positive quantity.\n\nI think we can modify these functions like below.\n\n```solidity\n  function getApprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp) external view returns (uint128) {\n    if (role != approvalRole && !forceApprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n    \n    if (quantity > 1) quantity = 1;\n\n    return quantity > 0 && forceApprovalRole[role] ? type(uint128).max : quantity;\n  }\n\n  function getDisapprovalQuantityAt(address policyholder, uint8 role, uint256 timestamp)\n    external\n    view\n    returns (uint128)\n  {\n    if (role != disapprovalRole && !forceDisapprovalRole[role]) return 0;\n    uint128 quantity = policy.getPastQuantity(policyholder, role, timestamp);\n\n    if (quantity > 1) quantity = 1;\n\n    return quantity > 0 && forceDisapprovalRole[role] ? type(uint128).max : quantity;\n  }\n```"}
{"locs": [["code-423n4/2023-06-llama", "main", "src/LlamaCore.sol", "L334> <br><https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaExecutor.sol#L29>"]], "vuln": "It is not possible to execute actions that require ETH (or other protocol token)", "severity": "MEDIUM", "mitigation": "It seems like an important part of protocol functionality that is not working, therefore suggested **High** severity.\n\nThe fix is straightforward, making LlamaExecutor.execute payable and passing value in LlamaCore:\n\n```diff\ndiff --git a/src/LlamaCore.sol b/src/LlamaCore.sol\nindex 89d60de..05f1755 100644\n--- a/src/LlamaCore.sol\n+++ b/src/LlamaCore.sol\n@@ -331,7 +331,7 @@ contract LlamaCore is Initializable {\n \n     // Execute action.\n     (bool success, bytes memory result) =\n-      executor.execute(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);\n+      executor.execute{value: msg.value}(actionInfo.target, actionInfo.value, action.isScript, actionInfo.data);\n \n     if (!success) revert FailedActionExecution(result);\n \ndiff --git a/src/LlamaExecutor.sol b/src/LlamaExecutor.sol\nindex f92ebc0..fe7127e 100644\n--- a/src/LlamaExecutor.sol\n+++ b/src/LlamaExecutor.sol\n@@ -28,6 +28,7 @@ contract LlamaExecutor {\n   /// @return result The data returned by the function being called.\n   function execute(address target, uint256 value, bool isScript, bytes calldata data)\n     external\n+    payable\n     returns (bool success, bytes memory result)\n   {\n     if (msg.sender != LLAMA_CORE) revert OnlyLlamaCore();\n```"}
{"locs": [["code-423n4/2023-06-llama", "main", "src/LlamaPolicy.sol", "L404-#L409> <br><https://github.com/code-423n4/2023-06-llama/blob/main/src/LlamaCore.sol#L516-#L562>"]], "vuln": "LlamaPolicy could be DOS by creating large amount of actions", "severity": "MEDIUM", "mitigation": "I recommend limiting the number of active actions a user can create."}
{"locs": [["code-423n4/2023-06-stader", "main", "contracts/SocializingPool.sol", "L21> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/Auction.sol#L14> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L17><br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/OperatorRewardsCollector.sol#L16>"]], "vuln": "`pause/unpause` functionalities not implemented in many pausable contracts", "severity": "MEDIUM", "mitigation": "Add public/external `pause` and `unpause` functions in the aforementioned contracts to allow them to be pausable, this can be done as in the `UserWithdrawalManager` contract. For example:\n\n```solidity\n/**\n * @dev Triggers stopped state.\n * Contract must not be paused\n */\nfunction pause() external {\n    UtilLib.onlyManagerRole(msg.sender, staderConfig);\n    _pause();\n}\n\n/**\n * @dev Returns to normal state.\n * Contract must be paused\n */\nfunction unpause() external onlyRole(DEFAULT_ADMIN_ROLE) {\n    _unpause();\n}\n```"}
{"locs": [["code-423n4/2023-06-stader", "7566b5a35f32ebd55d3578b8bd05c038feb7d9cc", "contracts/VaultProxy.sol", "L20-L36> <br><https://github.com/code-423n4/2023-06-stader/blob/7566b5a35f32ebd55d3578b8bd05c038feb7d9cc/contracts/VaultProxy.sol#L41-L50>"]], "vuln": "`VaultProxy` implementation can be initialized by anyone and self-destructed", "severity": "HIGH", "mitigation": "Prevent the `initialise` function from being called on the `VaultProxy` implementation contract by inheriting from OpenZeppelin's `Initializable` contract, like the system is doing in other contracts. Call the `_disableInitializers` function in the constructor and protect `initialise` with the `initializer` modifier. Alternatively, the `initialise` function can be called from the `initialize` function of the `VaultFactory` contract when the `VaultProxy` contract is instantiated.\n\n#"}
{"locs": [["code-423n4/2023-06-stader", "main", "contracts/PermissionlessNodeRegistry.sol", "L183> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/PermissionedNodeRegistry.sol#L254>"]], "vuln": "Stader OPERATOR is a single point of failure", "severity": "MEDIUM", "mitigation": "There is no simple fix for the issue, but at minimum, the protocol shouldn't be advertised as permissionless.\n\n#"}
{"locs": [["code-423n4/2023-06-stader", "main", "contracts/PoolUtils.sol", "L55-L65)"]], "vuln": "`updatePoolAddress` functions always revert when updating existing `poolId`", "severity": "MEDIUM", "mitigation": "Remove the `verifyNewPool` call inside the `updatePoolAddress` function and replace it with the following:\n\n```solidity\nfunction updatePoolAddress(\n    uint8 _poolId,\n    address _newPoolAddress\n) external override onlyExistingPoolId(_poolId) onlyRole(DEFAULT_ADMIN_ROLE) {\n    UtilLib.checkNonZeroAddress(_newPoolAddress);\n    // @audit revert only when mismatch in poolId\n    if (INodeRegistry(IStaderPoolBase(_poolAddress).getNodeRegistry()).POOL_ID() != _poolId) {\n        revert MismatchingPoolId();\n    }\n    poolAddressById[_poolId] = _newPoolAddress;\n    emit PoolAddressUpdated(_poolId, _newPoolAddress);\n}\n```\n\n#"}
{"locs": [["code-423n4/2023-06-stader", "main", "contracts/StaderOracle.sol", "L148> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L290>"]], "vuln": "`StaderOracle` - Strict equal can cause no consensus if trusted nodes are removed before consensus", "severity": "MEDIUM", "mitigation": "Replace strict equal with equal or greater than. Or replace it with greater than and decrease the right side.\n\nNot sure about adding cooldown for add/remove trusted nodes."}
{"locs": [["code-423n4/2023-06-stader", "main", "contracts/StaderOracle.sol", "L270> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L285>"]], "vuln": "Corruption of oracle data", "severity": "MEDIUM", "mitigation": "Add `if (_sdPriceData.reportingBlockNumber == getSDPriceReportableBlock())` to ensure it is always the latest reportable block data.<br>\nAdd `mapping(uint256 => uint256[]) blockPrices` to store the prices array separately for each block being reported, to avoid mixing and corruption of data. Or have `uint256 currentEpochBlock`,\nso  when a new block of data is pushed, previous data is deleted before pushing the new data.\n\n    if(_sdPriceData.reportingBlockNumber!=currentEpochBlock){\n       delete prices;\n    }\n\n#"}
{"locs": [["code-423n4/2023-06-stader", "main", "contracts/ValidatorWithdrawalVault.sol", "L62). If it's less than the accrued penalty by the validator, then operator is slashed."]], "vuln": "`ValidatorWithdrawalVault.distributeRewards` can be called to make operator slashable", "severity": "MEDIUM", "mitigation": "Maybe think about restricting access to the `distributeRewards` function.\n\n#"}
{"locs": [["code-423n4/2023-06-stader", "main", "contracts/StaderOracle.sol", "L646> <br><https://github.com/code-423n4/2023-06-stader/blob/main/contracts/StaderOracle.sol#L648>"]], "vuln": "Chainlink's `latestRoundData` may return a stale or incorrect result", "severity": "MEDIUM", "mitigation": "Add a check for the `updatedAt` returned value from `latestRoundData`.\n\n```diff\n    function getPORFeedData()\n        internal\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n-       (, int256 totalETHBalanceInInt, , , ) = AggregatorV3Interface(staderConfig.getETHBalancePORFeedProxy())\n+       (, int256 totalETHBalanceInInt, , uint256 balanceUpdatedAt, ) = AggregatorV3Interface(staderConfig.getETHBalancePORFeedProxy())\n            .latestRoundData();\n+       require(block.timestamp - balanceUpdatedAt <= MAX_DELAY, \"stale price\");\n\n-       (, int256 totalETHXSupplyInInt, , , ) = AggregatorV3Interface(staderConfig.getETHXSupplyPORFeedProxy())\n+       (, int256 totalETHXSupplyInInt, , uint256 supplyUpdatedAt, ) = AggregatorV3Interface(staderConfig.getETHXSupplyPORFeedProxy())\n            .latestRoundData();\n+       require(block.timestamp - supplyUpdatedAt <= MAX_DELAY, \"stale price\");\n\n        return (uint256(totalETHBalanceInInt), uint256(totalETHXSupplyInInt), block.number);\n    }\n```\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "54a45beb1428d85999da3f721f923cbf36ee3d35", "src/ulysses-omnichain/RootBridgeAgent.sol", "L823> <br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1044>"]], "vuln": "Incorrect accounting logic for `fallback` gas will lead to insolvency", "severity": "MEDIUM", "mitigation": "Deduct `fallback` gas from deposited gas.\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "main", "src/ulysses-omnichain/RootBridgeAgent.sol", "L684><br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L728>"]], "vuln": "DoS of `RootBridgeAgent` due to missing negation of return values for `UniswapV3Pool.swap()`", "severity": "MEDIUM", "mitigation": "Negate the return values of `UniswapV3Pool.swap()` in `RootBridgeAgent._gasSwapIn()` and `RootBridgeAgent._gasSwapOut()` before casting to `uint256`.\n\n#"}
{"locs": [["reservoirprotocol/indexer", "6c89d546d3fb98d5eaa505b9943e89bd91f2e8ec", "packages/contracts/contracts/router/ReservoirV6_0_1.sol", "L50>"]], "vuln": "Marketplace may call `onERC721Received()` and create a lien during `buyNftFromMarket()`, creating divergence", "severity": "HIGH", "mitigation": "Consider adding a flag that indicates the contract is in the `buyNftFromMarket()` flow and use it as a check in `onERC721Received()`. For example:\n\n```solidity\n_marketBuyFlow = 1;\n_execBuyNftFromMarket(lien.collection, tokenId, amount, useToken, marketplace, tradeData);\n_marketBuyFlow = 0;\n```\n\nAnd in `onERC721Receive()`:\n\n```solidity\nif (data.length == 64) {\n  if(_martketBuyFlow) {\n    return this.onERC721Received.selector;\n  }\n}\n```\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "54a45beb1428d85999da3f721f923cbf36ee3d35", "src/ulysses-amm/UlyssesPool.sol", "L223"]], "vuln": "`setWeight()` Logic error", "severity": "HIGH", "mitigation": "```solidity\n    function setWeight(uint256 poolId, uint8 weight) external nonReentrant onlyOwner {\n...\n\n-        if (oldTotalWeights > newTotalWeights) {\n+        if (oldTotalWeights < newTotalWeights) {\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n                if (i != poolIndex) {\n                    uint256 oldBandwidth = bandwidthStateList[i].bandwidth;\n                    if (oldBandwidth > 0) {\n                        bandwidthStateList[i].bandwidth =\n                            oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n                        leftOverBandwidth += oldBandwidth - bandwidthStateList[i].bandwidth;\n                    }\n                }\n\n                unchecked {\n                    ++i;\n                }\n            }\n            poolState.bandwidth += leftOverBandwidth.toUint248();\n        } else {\n            uint256 oldBandwidth = poolState.bandwidth;\n            if (oldBandwidth > 0) {\n-               poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights, newTotalWeights).toUint248();\n+               poolState.bandwidth = oldBandwidth.mulDivUp(newTotalWeights, oldTotalWeights).toUint248();\n\n                leftOverBandwidth += oldBandwidth - poolState.bandwidth;\n            }\n\n+           uint256 currentGiveWidth = 0;\n+           uint256 currentGiveCount = 0;\n            for (uint256 i = 1; i < bandwidthStateList.length;) {\n\n+                if (i != poolIndex) {\n+                     if(currentGiveCount == bandwidthStateList.length - 2 - 1) { //last\n+                         bandwidthStateList[i].bandwidth += leftOverBandwidth - currentGiveWidth;\n+                    }\n+                     uint256 sharesWidth = leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248();\n+                     bandwidthStateList[i].bandwidth += sharesWidth;\n+                     currentGiveWidth +=sharesWidth;  \n+                     currentCount++;\n+                 }                \n\n-                if (i != poolIndex) {\n-                    if (i == bandwidthStateList.length - 1) {\n-                        bandwidthStateList[i].bandwidth += leftOverBandwidth.toUint248();\n-                    } else if (leftOverBandwidth > 0) {\n-                        bandwidthStateList[i].bandwidth +=\n-                            leftOverBandwidth.mulDiv(bandwidthStateList[i].weight, weightsWithoutPool).toUint248();\n-                    }\n-               }\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n...\n\n```\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "main", "src/talos/TalosStrategyStaked.sol", "L28)"]], "vuln": "Many `create` methods are suspicious of the reorg attack", "severity": "MEDIUM", "mitigation": "Deploy such contracts via `create2` with `salt`."}
{"locs": [["code-423n4/2023-05-maia", "54a45beb1428d85999da3f721f923cbf36ee3d35", "src/ulysses-omnichain/RootBridgeAgent.sol", "L1219-L1222> <br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L848-L852>"]], "vuln": "Depositing gas through `depositGasAnycallConfig` should not withdraw the `nativeToken`", "severity": "MEDIUM", "mitigation": "Also, add deposit logic to `depositGasAnycallConfig`, or remove the withdrawal logic.\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "main", "src/ulysses-omnichain/RootBridgeAgent.sol", "L873-L890> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L922> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L246> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L571>"]], "vuln": "When the `anyExecute` call is made to `RootBridgeAgent` with a `depositNonce` that has been recorded in `executionHistory`, `initialGas` and `userFeeInfo` will not be updated, which would affect the next caller of `retrySettlement`.", "severity": "MEDIUM", "mitigation": "Consider implementing one of these:\n\n- Restrict `retrySettlement` to only be called by `AgentExecutor`.\n- Delete `initialGas` and `userFeeInfo` before a return is called if the `nonce` has been executed before:\n\n```solidity\n//Check if tx has already been executed\nif (executionHistory[fromChainId][nonce]) {\n    _forceRevert();\n    delete initialGas;\n    delete userFeeInfo;\n    //Return true to avoid triggering anyFallback in case of `_forceRevert()` failure\n    return (true, \"already executed tx\");\n}\n```\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "main", "src/talos/boost-aggregator/BoostAggregator.sol", "L119> <br><https://github.com/code-423n4/2023-05-maia/blob/main/src/talos/boost-aggregator/BoostAggregator.sol#L153>"]], "vuln": "`BoostAggregator` owner can set fees to 100% and steal all of the user's rewards", "severity": "MEDIUM", "mitigation": "Create a mapping which tracks the `protocolFee` at which the user has deposited their NFT. Upon withdrawing, get the `protocolFee` from the said mapping."}
{"locs": [["code-423n4/2023-05-maia", "54a45beb1428d85999da3f721f923cbf36ee3d35", "src/ulysses-omnichain/BranchBridgeAgent.sol", "L1349-L1357)'s code is below. Because `deposits` are never allocated memory, the function will always revert."]], "vuln": "`BranchBridgeAgent._normalizeDecimalsMultiple` will always revert because of the lack of allocating memory", "severity": "MEDIUM", "mitigation": "```solidity\n@@ -1351,7 +1351,9 @@\n         view\n         returns (uint256[] memory deposits)\n     {\n-        for (uint256 i = 0; i < _deposits.length; i++) {\n+        uint len = _deposits.length;\n+        deposits = new uint256[](len);\n+        for (uint256 i = 0; i < len; i++) {\n             deposits[i] = _normalizeDecimals(_deposits[i], ERC20(_tokens[i]).decimals());\n         }\n     }\n\n```\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "54a45beb1428d85999da3f721f923cbf36ee3d35", "src/uni-v3-staker/UniswapV3Staker.sol", "L340-L348> <br><https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/uni-v3-staker/UniswapV3Staker.sol#L373-L374>"]], "vuln": "The `RestakeToken` function is not permissionless", "severity": "MEDIUM", "mitigation": "A simple fix is to change the `isNotRestake` flag inside the `restakeToken` function to `false`:\n\n```diff\ndiff --git a/src/uni-v3-staker/UniswapV3Staker.sol b/src/uni-v3-staker/UniswapV3Staker.sol\nindex 5970379..d7add32 100644\n--- a/src/uni-v3-staker/UniswapV3Staker.sol\n+++ b/src/uni-v3-staker/UniswapV3Staker.sol\n@@ -339,7 +339,7 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n \n     function restakeToken(uint256 tokenId) external {\n         IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n-        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n+        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, false);\n \n         (IUniswapV3Pool pool, int24 tickLower, int24 tickUpper, uint128 liquidity) =\n             NFTPositionInfo.getPositionInfo(factory, nonfungiblePositionManager, tokenId);\n```\n\nA more complicated fix, which would reduce code complexity in the future, would be to rename the `isNotRestake` flag to `isRestake`.\n\nThis way, one level of indirection would be reduced.\n\n```diff\ndiff --git a/src/uni-v3-staker/UniswapV3Staker.sol b/src/uni-v3-staker/UniswapV3Staker.sol\nindex 5970379..43ff24c 100644\n--- a/src/uni-v3-staker/UniswapV3Staker.sol\n+++ b/src/uni-v3-staker/UniswapV3Staker.sol\n@@ -354,15 +354,15 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n     /// @inheritdoc IUniswapV3Staker\n     function unstakeToken(uint256 tokenId) external {\n         IncentiveKey storage incentiveId = stakedIncentiveKey[tokenId];\n-        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, true);\n+        if (incentiveId.startTime != 0) _unstakeToken(incentiveId, tokenId, false);\n     }\n \n     /// @inheritdoc IUniswapV3Staker\n     function unstakeToken(IncentiveKey memory key, uint256 tokenId) external {\n-        _unstakeToken(key, tokenId, true);\n+        _unstakeToken(key, tokenId, false);\n     }\n \n-    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isNotRestake) private {\n+    function _unstakeToken(IncentiveKey memory key, uint256 tokenId, bool isRestake) private {\n         Deposit storage deposit = deposits[tokenId];\n \n         (uint96 endTime, uint256 stakedDuration) =\n@@ -371,7 +371,7 @@ contract UniswapV3Staker is IUniswapV3Staker, Multicallable {\n         address owner = deposit.owner;\n \n         // anyone can call restakeToken if the block time is after the end time of the incentive\n-        if ((isNotRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();\n+        if ((isRestake || block.timestamp < endTime) && owner != msg.sender) revert NotCalledByOwner();\n```\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "54a45beb1428d85999da3f721f923cbf36ee3d35", "src/maia/tokens/ERC4626PartnerManager.sol", "L325-L335>"]], "vuln": "`ERC4626PartnerManager.checkTransfer` does not check `amount` correctly, as it applies `bHermesRate` to `balanceOf[from]`, but not `amount`.", "severity": "MEDIUM", "mitigation": "```diff\n modifier checkTransfer(address from, uint256 amount) virtual {\n-        uint256 userBalance = balanceOf[from] * bHermesRate;\n+        uint256 userBalance = (balanceOf[from] - amount) * bHermesRate;\n\n-        if (\n-            userBalance - userClaimedWeight[from] < amount || userBalance - userClaimedBoost[from] < amount\n-                || userBalance - userClaimedGovernance[from] < amount\n-                || userBalance - userClaimedPartnerGovernance[from] < amount\n-        ) revert InsufficientUnderlying();\n\n+        if (\n+            userBalance < userClaimedWeight[from] || userBalance < userClaimedBoost[from] \n+                || userBalance < userClaimedGovernance[from]  || userBalance <  userClaimedPartnerGovernance[from] \n+        ) revert InsufficientUnderlying();\n\n        _;\n    }\n```\n\n#"}
{"locs": [["code-423n4/2023-05-maia", "54a45beb1428d85999da3f721f923cbf36ee3d35", "src/ulysses-omnichain/BranchPort.sol", "L161>)."]], "vuln": "Branch Strategies lose yield due to wrong implementation of time limit in `BranchPort.sol`", "severity": "MEDIUM", "mitigation": "Implement the logic as shown under section **The implementation that was probably intended**\n\nPlease also, consider the following comments:\n\n- To get the maximum amount out of their daily budget, a strategy must make a call to the `manage()` function exactly every 24 hours after the first time calling it. Otherwise, there are time frames where amounts could be retrieved, but are not. That would have the strategy missing out on investments and therefore, potential yield. E.g. the 2nd call happens 36 hours (instead of 24 hours) after the initial call => 12 hours (1/2 of a daily budget) remains unused.\n\n- The amount also needs to be fully used within the 24 hour timeframe, since the daily limit is overwriting and not cumulating (using `strategyDailyLimitRemaining[msg.sender][_token]` = `strategyDailyLimitAmount[msg.sender][_token]` and not `strategyDailyLimitRemaining[msg.sender][_token]` += `strategyDailyLimitAmount[msg.sender][_token]`).\n\n- An alternative to the aforementioned, could be to calculate the amount to grant to a strategy after an initial/last grant like the following: (time since last grant of fresh daily limit / 24 hours) `*` daily limit. This would have the effect that a strategy could use their granted limits without missing amounts due to suboptimal timing. It would also spare the strategy the necessary call every 24 hours, which would save some gas and remove the need for setting up automation for each strategy (e.g. using Chainlink keepers). The strategy could never spend more than the cumulative daily budget. But it may lead to a sudden usage of a large amount of accumulated budget, which may not be intended.\n\n#"}
{"locs": [["code-423n4/2023-05-party", "f6f80dde81d86e397ba4f3dedb561e23d58ec884", "contracts/party/PartyGovernanceNFT.sol", "L332-L345>"]], "vuln": "rageQuit() cannot transfer ERC1155 fungible tokens", "severity": "MEDIUM", "mitigation": "Include support for ERC1155 in `rageQuit()`."}
{"locs": [["Uniswap/v3-core", "main", "contracts/UniswapV3Pool.sol", "LL640C9-L650C15) stops the loop if the price limit is reached or the entire input has been used. If the pool does not have enough liquidity, it will still do the swap until the price reaches the minimum/maximum price."]], "vuln": "Low Liquidity in Uniswap V3 Pool Can Lead to ETH Lockup in `JBXBuybackDelegate` Contract", "severity": "MEDIUM", "mitigation": "Consider returning the amount of unused ETH to the beneficiary."}
{"locs": [["code-423n4/2023-05-xeth", "main", "src/AMO2.sol", "L323-L325> <br><https://github.com/code-423n4/2023-05-xeth/blob/main/src/AMO2.sol#L335-L351>"]], "vuln": "Incorrect slippage check in the AMO2.rebalanceUp can be attacked by MEV", "severity": "MEDIUM", "mitigation": "`rebalanceUp` and `rebalanceDown` should use different slippage calculation methods in the `applySlippage`.\n\n#"}
{"locs": [["convex-eth/platform", "main", "contracts/contracts/BaseRewardPool.sol", "L238>"]], "vuln": "CVXStaker.sol Unable to process newly add rewardTokens", "severity": "MEDIUM", "mitigation": "Add a new method to modify`CVXStaker.rewardTokens[]`\n\n#"}
{"locs": [["code-423n4/2023-05-venus", "main", "contracts/Shortfall/Shortfall.sol", "L158-L202><br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L467-L470><br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Shortfall/Shortfall.sol#L213>"]], "vuln": "Malicious actor can win an auction unfavorably to the protocol by block stuffing", "severity": "MEDIUM", "mitigation": "There are at least three options to resolve this issue:\n\n1.  Make the bidding window much higher at the beginning; like 1000 blocks.\n2.  Make the bidding window very high at the beginning and decrease it; the more attractive the new bid is.\n3.  Make the bidding window dependent on the money at stake, to disincentivize block stuffing."}
{"locs": [["code-423n4/2023-05-venus", "main", "contracts/Comptroller.sol", "L199> <br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L299> <br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L324> <br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L553> <br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L1240> <br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L1255> <br><https://github.com/code-423n4/2023-05-venus/blob/main/contracts/Comptroller.sol#L578>"]], "vuln": "It's possible to borrow, redeem, transfer tokens and exit markets with outdated collateral prices and borrow interest", "severity": "MEDIUM", "mitigation": "Update the price and interest of every collateral, except the VToken that triggered the hook which has already been updated. Similarly to what is being done on `healAccount(...)`:\n\n    for (uint256 i; i < userAssetsCount; ++i) {\n       userAssets[i].accrueInterest();\n       oracle.updatePrice(address(userAssets[i]));\n    }\n\n#"}
{"locs": [["VenusProtocol/venus-protocol-interface", "develop", "src/clients/api/queries/getVaiCalculateRepayAmount/index.ts", "L17-L33)."]], "vuln": "liquidateAccount will fail if the transaction is not included in the current block", "severity": "MEDIUM", "mitigation": "Use a looser check:\n\n    snapshot = _getCurrentLiquiditySnapshot(borrower, _getLiquidationThreshold);\n    require (snapshot.shortfall == 0);\n\nto replace:\n\n    for (uint256 i; i < marketsCount; ++i) {\n            (, uint256 borrowBalance, ) = _safeGetAccountSnapshot(borrowMarkets[i], borrower);\n            require(borrowBalance == 0, \"Nonzero borrow balance after liquidation\");\n    }\n\n#"}
{"locs": [["code-423n4/2023-05-venus", "8be784ed9752b80e6f1b8b781e2e6251748d0d7e", "contracts/Comptroller.sol", "L424-L526>"]], "vuln": "Potential Unjust Liquidation After Exiting Market", "severity": "MEDIUM", "mitigation": "Update the `preLiquidateHook` function to check if a user has exited a market before proceeding with liquidation.\n\n#"}
{"locs": [["code-423n4/2023-05-ajna", "276942bc2f97488d07b887c8edceaaab7a5c3964", "ajna-core/src/RewardsManager.sol", "L811>"]], "vuln": "Claiming accumulated rewards while the contract is underfunded can lead to a loss of rewards", "severity": "HIGH", "mitigation": "*   Consider reverting if there are insufficient Ajna tokens available as rewards. This is the best immediate solution to the problem.\n*   Create unit tests for each issue identified in the audit report and confirm that it has been properly addressed. This will prevent recurring problems where the development team believes an issue has been resolved, but in reality, it has not.\n*   Create a separate pull request for each finding and mark the issue in the audit table. This will help developers and auditors verify whether the issue has been resolved or not, and will make future audits more manageable, ultimately improving the overall quality and security of the protocol."}
{"locs": [["code-423n4/2023-05-ajna", "fc70fb9d05b13aee2b44be2cb652478535a90edd", "ajna-core/src/RewardsManager.sol", "L310-L318>"]], "vuln": "Potential unfair distribution of Rewards due to MEV in `updateBucketExchangeRatesAndClaim`", "severity": "MEDIUM", "mitigation": "I see potentially two solutions here:\n\n1.  Introduce a randomized reward mechanism, such as a lottery system or a probabilistic reward distribution for people who contribute to updating buckets. This could reduce the predictability of rewards and hence the potential for MEV exploitation.\n2.  Consider limiting the reward claim process to users who have staked in the rewards manager because they are the individuals that are directly affected if the bucket is not updated, because if its not updated for 14 days they won't be getting rewards. Additionally, you can couple it with a rate-limitting mechanism by implementing a maximum claim per address per time period"}
{"locs": [["ajna-finance/audits", "main", "sherlock/Contest1.md", "issue-m-7-calculating-new-rewards-is-susceptible-to-precision-loss-due-to-division-before-multiplication> which is not fixed properly. Still, the final multiplication is being performed after the division."]], "vuln": "Calculating new rewards is susceptible to precision loss due to division before multiplication", "severity": "MEDIUM", "mitigation": "All the multiplication should be performed in step 1 and then division at the end."}
{"locs": [["code-423n4/2023-04-frankencoin", "1022cb106919fba963a89205d3b90bf62543f68f", "contracts/Position.sol", "L268-L276> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L329-L354> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L252-L276>"]], "vuln": "When the challenge is successful, the user can send tokens to the position to avoid the position's cooldown period being extended", "severity": "HIGH", "mitigation": "Consider extending the cooldown period of the position even if the challenge is successful"}
{"locs": [["code-423n4/2023-04-frankencoin", "main", "contracts/Equity.sol", "L54-L59>"]], "vuln": "`anchorTime()` will not work properly on Optimism due to use of `block.number`", "severity": "MEDIUM", "mitigation": "Consider using block.timestamp instead of block.number for more accurate measurement of time."}
{"locs": [["code-423n4/2023-04-frankencoin", "1022cb106919fba963a89205d3b90bf62543f68f", "contracts/Position.sol", "L112> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L263> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L373-L376>"]], "vuln": "Owner of Denied Position is not able to withdraw collateral until expiry", "severity": "MEDIUM", "mitigation": "Return the collateral to the owner at the end of `deny`\n\n        function deny(address[] calldata helpers, string calldata message) public {\n            if (block.timestamp >= start) revert TooLate();\n            IReserve(zchf.reserve()).checkQualified(msg.sender, helpers);\n            cooldown = expiration; // since expiration is immutable, we put it under cooldown until the end\n            internalWithdrawCollateral(owner, IERC20(collateral).balanceOf(address(this)));\n            emit PositionDenied(msg.sender, message);\n        }"}
{"locs": [["code-423n4/2023-04-frankencoin", "main", "contracts/Position.sol", "L132-L152> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L159-L167>"]], "vuln": "Unable to adjust position in some cases", "severity": "MEDIUM", "mitigation": "To solve this problem, we can modify the \"adjust\" function like this;\n\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) public onlyOwner {\n        uint256 colbal = collateralBalance();\n        if (newCollateral > colbal){\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        // Must be called after collateral deposit, but before withdrawal\n        if (newMinted < minted){\n            zchf.burnFrom(msg.sender, minted - newMinted, reserveContribution);\n            minted = newMinted;\n        }\n        if (newCollateral < colbal){\n            withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        // Must be called after collateral withdrawal\n        if (newMinted > minted){\n            mint(msg.sender, newMinted - minted);\n        }\n\n        if (newPrice != price){\n            adjustPrice(newPrice);\n        }\n    }"}
{"locs": [["code-423n4/2023-04-frankencoin", "1022cb106919fba963a89205d3b90bf62543f68f", "contracts/Equity.sol", "L241-L255> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L266-L270> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L275-L282> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Equity.sol#L290-L297>"]], "vuln": "No slippage control when minting and redeeming FPS", "severity": "MEDIUM", "mitigation": "Consider setting minFPSout and minZCHFout parameters to allow slippage control when minting and redeeming FPS"}
{"locs": [["code-423n4/2023-04-frankencoin", "1022cb106919fba963a89205d3b90bf62543f68f", "contracts/MintingHub.sol", "L217-L224> <br><https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L329-L350>"]], "vuln": "Later challengers can bid on the previous challenge to extend the expiration time of the previous challenge, so that their own challenge can succeed before the previous challenge and get challenge rewards", "severity": "MEDIUM", "mitigation": "Consider implementing a challenge queue that allows the end function to be called on subsequent challenges only after previous challenges have ended."}
{"locs": [["code-423n4/2023-04-caviar", "main", "src/PrivatePool.sol", "L334"]], "vuln": "Royalty recipients will not get fair share of royalties", "severity": "MEDIUM", "mitigation": "To address this issue, it is recommended that the weight of NFTs relative to other NFTs being purchased should be taken into consideration when calculating royalties."}
{"locs": [["code-423n4/2023-04-caviar", "main", "src/Factory.sol", "L92"]], "vuln": "Factory.create: Predictability of pool address creates multiple issues.", "severity": "MEDIUM", "mitigation": "Consider making the upcoming pool address user specific by combining the salt value with user's address.\n```solidity\n    privatePool = PrivatePool(payable(privatePoolImplementation.cloneDeterministic(\n        keccak256(abi.encode(msg.seender, _salt))\n    )));\n```"}
{"locs": [["code-423n4/2023-04-caviar", "cd8a92667bcb6657f70657183769c244d04c015c", "src/PrivatePool.sol", "L648-L649"]], "vuln": "PrivatePool owner can steal all ERC20 and NFT from user via arbitrary execution", "severity": "HIGH", "mitigation": "We recommend the protocol not let the private pool owner perform arbtirary execution. The private pool can use the flashloan to claim the airdrop himself."}
{"locs": [["code-423n4/2023-04-caviar", "cd8a92667bcb6657f70657183769c244d04c015c", "src/EthRouter.sol", "L273"]], "vuln": "EthRouter can\u2019t perform multiple changes", "severity": "MEDIUM", "mitigation": "only send the required change fee and not `msg.value`"}
{"locs": [["code-423n4/2023-04-caviar", "main", "src/PrivatePool.sol", "L750-L752>"]], "vuln": "Flash loan fee is incorrect in Private Pool contract", "severity": "MEDIUM", "mitigation": "The `flashFee` function should properly scale the value of the `changeFee` variable, similar to how it is implemented in `changeFeeQuote`."}
{"locs": [["code-423n4/2023-04-caviar", "main", "src/PrivatePool.sol", "L623"]], "vuln": "PrivatePool.flashLoan() takes fee from the wrong address", "severity": "MEDIUM", "mitigation": "Change to:\n```sol\n        uint initialBalance = address(this).balance;\n        // ... \n\n        if (baseToken != address(0)) ERC20(baseToken).transferFrom(receiver, address(this), fee);\n        else require(address(this).balance - initialBalance == fee);\n```"}
{"locs": [["code-423n4/2023-04-party", "440aafacb0f15d037594cebc85fd471729bcb6d9", "contracts/proposals/VetoProposal.sol", "L8-L69) contract allows to veto proposals with the [`voteToVeto`](https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/proposals/VetoProposal.sol#L19-L60) function."]], "vuln": "`VetoProposal`: User can veto multiple times so every proposal can be vetoed by any user that has a small amount of votes", "severity": "HIGH", "mitigation": "The fix is straightforward.\n\nWe introduce a `hasVoted` mapping that tracks for each `(party, proposalId, address)` triplet if it has vetoed already.\n\nFix:\n\n```diff\ndiff --git a/contracts/proposals/VetoProposal.sol b/contracts/proposals/VetoProposal.sol\nindex 780826f..fb1f1ab 100644\n--- a/contracts/proposals/VetoProposal.sol\n+++ b/contracts/proposals/VetoProposal.sol\n@@ -8,9 +8,11 @@ import \"../party/Party.sol\";\n contract VetoProposal {\n     error NotPartyHostError();\n     error ProposalNotActiveError(uint256 proposalId);\n+    error AlreadyVotedError(address caller);\n \n     /// @notice Mapping from party to proposal ID to votes to veto the proposal.\n     mapping(Party => mapping(uint256 => uint96)) public vetoVotes;\n+    mapping(Party => mapping(uint256 => mapping(address => bool))) public hasVoted;\n \n     /// @notice Vote to veto a proposal.\n     /// @param party The party to vote on.\n@@ -33,6 +35,12 @@ contract VetoProposal {\n         if (proposalStatus != PartyGovernance.ProposalStatus.Voting)\n             revert ProposalNotActiveError(proposalId);\n \n+        if (hasVoted[party][proposalId][msg.sender]) {\n+            revert AlreadyVotedError(msg.sender);\n+        }\n+\n+        hasVoted[party][proposalId][msg.sender] = true;\n+\n         // Increase the veto vote count\n         uint96 votingPower = party.getVotingPowerAt(\n             msg.sender,\n```"}
{"locs": [["code-423n4/2023-04-party", "440aafacb0f15d037594cebc85fd471729bcb6d9", "contracts/crowdfund/ETHCrowdfundBase.sol", "L195-L219)"]], "vuln": "Contributions can be smaller than `minContribution` and may receive no voting power", "severity": "MEDIUM", "mitigation": "Enforce minContribution after reductions to amount."}
{"locs": [["code-423n4/2023-04-party", "440aafacb0f15d037594cebc85fd471729bcb6d9", "contracts/crowdfund/ReraiseETHCrowdfund.sol", "L354-L377)"]], "vuln": "`ReraiseETHCrowdfund#claimMultiple` can be used to grief large depositors", "severity": "MEDIUM", "mitigation": "If msg.sender isn't contributor it should force the user to mint the minimum possible number of NFTs:\n\n        uint256 votingPower = pendingVotingPower[contributor];\n\n        if (votingPower == 0) return;\n\n    +  if (msg.sender != contributor) {\n    +      require(votingPowerByCard.length == (((votingPower - 1)/maxContribution) + 1));\n    +  }"}
{"locs": [["code-423n4/2023-03-mute", "4d8b13add2907b17ac14627cfa04e0c3cc9a2bed", "contracts/bonds/MuteBond.sol", "L156-L159) shows that when a user sets `max_buy` to true the value used is the `maxPurchaseAmount()`"]], "vuln": "Bond max-buyer might end up buying the max buy of the next epoch", "severity": "HIGH", "mitigation": "Require the user to specify the epoch number when doing a 'max buy', and revert if it doesn't match the current epoch (it might be a good idea to refactor the code to 2 external functions for normal buy and max buy, where they both share an internal function to make the actual deposit).\n\nSide note: this is similar to another bug I've reported regarding getting a lower price than expected, however the root cause, impact, and mitigation are different and therefore I've reported this separately."}
{"locs": [["code-423n4/2023-03-mute", "4d8b13add2907b17ac14627cfa04e0c3cc9a2bed", "contracts/amplifier/MuteAmplifier.sol", "L482-L486"]], "vuln": "A user can 'borrow' dMute balance for a single block to increase their amplifier APY", "severity": "MEDIUM", "mitigation": "Make sure that the user holds the dMute for a longer time, one way to do it might be to sample a few random blocks between staking and current blocks and use the minimum balance as the user's balance."}
{"locs": [["code-423n4/2023-03-mute", "4d8b13add2907b17ac14627cfa04e0c3cc9a2bed", "contracts/amplifier/MuteAmplifier.sol", "L185-L191"]], "vuln": "`MuteAmplifier.rescueTokens()` checks the wrong condition for `muteToken`", "severity": "MEDIUM", "mitigation": "It should be modified like the below.\n\n```solidity\nelse if (tokenToRescue == muteToken) {\n    if (totalStakers > 0) { //should check totalReclaimed as well\n        require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards.sub(totalClaimedRewards).sub(totalReclaimed)),\n            \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"\n        );\n    }\n    else if(block.timestamp <= endTime) { //no stakers but staking is still active, should maintain totalRewards\n        require(amount <= IERC20(muteToken).balanceOf(address(this)).sub(totalRewards),\n            \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"\n        );\n    }\n}\n```"}
{"locs": [["code-423n4/2023-03-mute", "4d8b13add2907b17ac14627cfa04e0c3cc9a2bed", "contracts/amplifier/MuteAmplifier.sol", "L180-L194"]], "vuln": "`MuteAmplifier.sol`: `rescueTokens` function does not prevent fee tokens from being transferred", "severity": "MEDIUM", "mitigation": "The `MuteAmplifier.rescueTokens` function should check that only excess `fee0` / `fee1` tokens can be paid out. Such that tokens that will be paid out to stakers need to stay in the contract.  \n\nFix:  \n```diff\ndiff --git a/contracts/amplifier/MuteAmplifier.sol b/contracts/amplifier/MuteAmplifier.sol\nindex 9c6fcb5..b154d81 100644\n--- a/contracts/amplifier/MuteAmplifier.sol\n+++ b/contracts/amplifier/MuteAmplifier.sol\n@@ -188,6 +188,18 @@ contract MuteAmplifier is Ownable{\n                     \"MuteAmplifier::rescueTokens: that muteToken belongs to stakers\"\n                 );\n             }\n+        } else if (tokenToRescue == address(IMuteSwitchPairDynamic(lpToken).token0())) {\n+            if (totalStakers > 0) {\n+                require(amount <= IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)).sub(totalFees0.sub(totalClaimedFees0)),\n+                    \"MuteAmplifier::rescueTokens: that token belongs to stakers\"\n+                );\n+            }\n+        } else if (tokenToRescue == address(IMuteSwitchPairDynamic(lpToken).token1())) {\n+            if (totalStakers > 0) {\n+                require(amount <= IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this)).sub(totalFees1.sub(totalClaimedFees1)),\n+                    \"MuteAmplifier::rescueTokens: that token belongs to stakers\"\n+                );\n+            }\n         }\n \n         IERC20(tokenToRescue).transfer(to, amount);\n```\n\nThe issue discussed in this report also ties in with the fact that the `fee0 <= totalFees0 && fee1 <= totalFees1` check before transferring fee tokens always passes. It does not prevent the scenario that the sponsor wants to prevent which is when there are not enough fee tokens to be transferred the transfer should not block the function.  \n\nSo in addition to the above changes I propose to add these changes as well:  \n\n```diff\ndiff --git a/contracts/amplifier/MuteAmplifier.sol b/contracts/amplifier/MuteAmplifier.sol\nindex 9c6fcb5..39cd75b 100644\n--- a/contracts/amplifier/MuteAmplifier.sol\n+++ b/contracts/amplifier/MuteAmplifier.sol\n@@ -255,7 +255,7 @@ contract MuteAmplifier is Ownable{\n         }\n \n         // payout fee0 fee1\n-        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n+        if ((fee0 > 0 || fee1 > 0) && fee0 < IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)) && fee1 < IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this))) {\n             address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);\n             address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);\n \n@@ -295,7 +295,7 @@ contract MuteAmplifier is Ownable{\n         }\n \n         // payout fee0 fee1\n-        if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n+        if ((fee0 > 0 || fee1 > 0) && fee0 < IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)) && fee1 < IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this))) {\n             address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(msg.sender, fee0);\n             address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(msg.sender, fee1);\n \n@@ -331,7 +331,7 @@ contract MuteAmplifier is Ownable{\n             }\n \n             // payout fee0 fee1\n-            if ((fee0 > 0 || fee1 > 0) && fee0 <= totalFees0 && fee1 <= totalFees1) {\n+            if ((fee0 > 0 || fee1 > 0) && fee0 < IERC20(IMuteSwitchPairDynamic(lpToken).token0()).balanceOf(address(this)) && fee1 < IERC20(IMuteSwitchPairDynamic(lpToken).token1()).balanceOf(address(this))) {\n                 address(IMuteSwitchPairDynamic(lpToken).token0()).safeTransfer(account, fee0);\n                 address(IMuteSwitchPairDynamic(lpToken).token1()).safeTransfer(account, fee1);\n```"}
{"locs": [["rocket-pool/rocketpool", "967e4d3c32721a84694921751920af313d1467af", "contracts/contract/token/RocketTokenRETH.sol", "L157-L172) that prevents any user who has recently deposited to transfer or burn tokens. In the past this delay was set to 5760 blocks mined (aprox. 19h, considering one block per 12s). This delay can prevent asymmetry protocol users from unstaking if another user staked recently."]], "vuln": "Possible DoS on `unstake()`", "severity": "MEDIUM", "mitigation": "Consider modifying Reth derivative to obtain rETH only through the UniswapV3 pool, on average users will get less rETH due to the slippage, but will avoid any future issues with the deposit delay mechanism."}
{"locs": [["code-423n4/2023-03-asymmetry", "44b5cd94ebedc187a08884a7f685e950e987261c", "contracts/SafEth/derivatives/Reth.sol", "L101) with the Uniswap rETH/WETH pool."]], "vuln": "Non-ideal rETH/WETH pool used pays unnecessary fees", "severity": "MEDIUM", "mitigation": "The best solution is to use the same flow as RocketPool's frontend UI and to call `swapTo()` in [RocketSwapRouter.sol](https://etherscan.io/address/0x16d5a408e807db8ef7c578279beeee6b228f1c1c#code#F19#L64). An alternative is to modify Reth.sol to use the Balancer rETH/ETH pool for swapping instead of Uniswap's rETH/WETH pool to better conserve user value by reducing swap fees and reducing slippage costs."}
{"locs": [["code-423n4/2023-03-asymmetry", "main", "contracts/SafEth/SafEth.sol", "L71-L81)"]], "vuln": "No slippage protection on `stake()` in SafEth.sol", "severity": "MEDIUM", "mitigation": "Consider having a user inputtable `minMintAmountOut` added in the function parameters of `stake()` and the function logic refactored as follows:\n\n```diff\n-    function stake() external payable {\n+    function stake(uint256 minMintAmountOut) external payable {\n\n        [... Snipped ...]\n\n        _mint(msg.sender, mintAmount);\n+        require(shares >= minSharesOut, \"mint amount too low\");\n\n        [... Snipped ...]\n```\n\nIdeally, this slippage calculation should be featured in the UI, with optionally selectable stake amount impact, e.g. 0.1%."}
{"locs": [["code-423n4/2023-03-canto-identity", "077372297fc419ea7688ab62cc3fd4e8f4e24e66", "canto-namespace-protocol/src/Namespace.sol", "L110)"]], "vuln": "Users will be able to purchase fewer NFTs than the project had anticipated", "severity": "HIGH", "mitigation": "Pass font class instead of 0\n\n```diff\n-            bytes memory charAsBytes = Utils.characterToUnicodeBytes(0, tileData.characterIndex, characterModifier);\n+            bytes memory charAsBytes = Utils.characterToUnicodeBytes(tileData.fontClass, tileData.characterIndex, characterModifier);\n```"}
{"locs": [["code-423n4/2023-03-polynomial", "main", "src/LiquidityPool.sol", "L738-L743"]], "vuln": "Function `hedgePositions` is incorrect, because it missed the `queuedPerpSize` in the calculation", "severity": "HIGH", "mitigation": "`currentPosition` should be `_getTotalPerpPosition()` + `queuedPerpSize` in function `hedgePositions`."}
{"locs": [["code-423n4/2023-03-wenwin", "main", "src/LotterySetup.sol", "L164-L176):"]], "vuln": "Unsafe casting from `uint256` to `uint16` could cause ticket prizes to become much smaller than intended", "severity": "MEDIUM", "mitigation": "Consider storing the prize amount of each `winTier` in a mapping instead of packing them into a `uint256` using bitwise arithmetic. This approach removes the upper limit (6553.5) and lower limit (0.1) for prizes, which would allow the protocol to use tokens with extremely high or low prices.\n\nAlternatively, check if `rewards[winTier] > type(uint256).max` and revert if so. This can be done through OpenZeppelin's [SafeCast](https://docs.openzeppelin.com/contracts/3.x/api/utils#SafeCast-toUint16-uint256-)."}
{"locs": [["code-423n4/2023-02-kuma", "3f3d2269fcb3437a9f00ffdd67b5029487435b95", "src/mcag-contracts/KUMABondToken.sol", "L143) only checks if `msg.sender` and `to` are not blacklisted. It doesn't check if the owner of the `tokenId` is not blacklisted."]], "vuln": "`KUMABondToken.approve()` should revert if the owner of the tokenId is blacklisted", "severity": "MEDIUM", "mitigation": "`KUMABondToken.approve()` should revert if the owner of the tokenId is blacklisted:\n\n```\ndiff --git a/src/mcag-contracts/KUMABondToken.sol b/src/mcag-contracts/KUMABondToken.sol\nindex 569a042..906fe7b 100644\n--- a/src/mcag-contracts/KUMABondToken.sol\n+++ b/src/mcag-contracts/KUMABondToken.sol\n@@ -146,6 +146,7 @@ contract KUMABondToken is ERC721, Pausable, IKUMABondToken {\n         whenNotPaused\n         notBlacklisted(to)\n         notBlacklisted(msg.sender)\n+        notBlacklisted(ERC721.ownerOf(tokenId))\n     {\n         address owner = ERC721.ownerOf(tokenId);\n\n```"}
{"locs": [["code-423n4/2023-02-kuma", "3f3d2269fcb3437a9f00ffdd67b5029487435b95", "src/kuma-protocol/KUMASwap.sol", "L116-L118>"]], "vuln": "KUMASwap incorrectly reverts when when `_maxCoupons` has been reached", "severity": "MEDIUM", "mitigation": "sellBond should only revert if the max length has been reached and bond.coupon doesn't already exist:\n\n    -   if (_coupons.length() == _maxCoupons) {\n    +   if (_coupons.length() == _maxCoupons && !_coupons.contains(bond.coupon)) {\n            revert Errors.MAX_COUPONS_REACHED();\n        }"}
{"locs": [["code-423n4/2023-02-ethos", "73687f32b934c9d697b97745356cdf8a1f264955", "Ethos-Vault/contracts/ReaperVaultV2.sol", "L617"]], "vuln": "In ReaperVaultV2, we should update lockedProfit and lastReport before changing lockedProfitDegradation", "severity": "MEDIUM", "mitigation": "We should modify `setLockedProfitDegradation()` like below.\n\n```solidity\n    function setLockedProfitDegradation(uint256 degradation) external {\n        _atLeastRole(ADMIN);\n        require(degradation <= DEGRADATION_COEFFICIENT, \"Degradation cannot be more than 100%\");\n\n        // update lockedProfit and lastReport\n        lockedProfit = _calculateLockedProfit();\n        lastReport = block.timestamp;\n\n        lockedProfitDegradation = degradation;\n        emit LockedProfitDegradationUpdated(degradation);\n    }\n```"}
{"locs": [["code-423n4/2023-02-ethos", "main", "Ethos-Core/contracts/LUSDToken.sol", "L28"]], "vuln": "DOMAIN_SEPARATOR() is missing in LUSDToken.sol", "severity": "MEDIUM", "mitigation": "To mitigate this risk, it is recommended to follow the ERC2612 specification strictly and ensure that the DOMAIN_SEPARATOR is correctly implemented."}
{"locs": [["code-423n4/2023-02-ethos", "73687f32b934c9d697b97745356cdf8a1f264955", "Ethos-Core/contracts/RedemptionHelper.sol", "L128"]], "vuln": "Last Trove may be prevented from redeeming", "severity": "MEDIUM", "mitigation": "- Consider removing this check as the invariant no longer applies"}
{"locs": [["code-423n4/2023-02-ethos", "main", "Ethos-Core/contracts/StabilityPool.sol", "L575-L595"]], "vuln": "P can be updated to zero which can cause a DOS when liquidating troves", "severity": "MEDIUM", "mitigation": "Recommend setting SCALE_FACTOR to 1e18, even though the docs did explain that 1e9 is used instead of 1e18 to ensure negligible precision loss, the alternative option is redesigning the mitigation mechanism of rounding error for P."}
{"locs": [["code-423n4/2023-02-ethos", "main", "Ethos-Vault/contracts/ReaperVaultV2.sol", "L368-L408"]], "vuln": "ReaperVaultERC4626 is not EIP-4626 compliant and integrations can result in loss of funds", "severity": "MEDIUM", "mitigation": "The `withdraw` and `redeem` functions should be modified to meet the specifications of EIP-4626: the `value` transferred must always be equal to the `assets` withdrawn. In case this is not true, the transaction must be reverted."}
{"locs": [["code-423n4/2023-02-ethos", "73687f32b934c9d697b97745356cdf8a1f264955", "Ethos-Core/contracts/TroveManager.sol", "L1500-L1507"]], "vuln": "lastFeeOperationTime is not modified correctly in function _updateLastFeeOpTime(), resulting a much slower decay model for borrowing base rate", "severity": "MEDIUM", "mitigation": "Using  the effective elapsed time that is consumed by the model so far to revise ``lastFeeOperationTime``.\n\n```diff\n function _updateLastFeeOpTime() internal {\n        uint timePassed = block.timestamp.sub(lastFeeOperationTime);\n\n        if (timePassed >= SECONDS_IN_ONE_MINUTE) {\n-            lastFeeOperationTime = block.timestamp;\n+            lastFeeOperationTime += _minutesPassedSinceLastFeeOp()*SECONDS_IN_ONE_MINUTE;\n            emit LastFeeOpTimeUpdated(block.timestamp);\n        }\n    }\n```"}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/RewardSystem/RewardThrottle.sol", "L437-L462>"]], "vuln": "RewardThrottle: If an epoch does not have any profit, then there may not be rewards for that epoch at the start of the next epoch.", "severity": "HIGH", "mitigation": "Consider removing the `fillInEpochGaps` function, or only allowing it to be called when the contract is not active."}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/StabilityPod/StabilizerNode.sol", "L312-L334>"]], "vuln": "Manipulation of `livePrice` to receive `defaultIncentive` in 2 consecutive blocks", "severity": "HIGH", "mitigation": "Consider not giving incentives for caller or reset the `primedBlock` at least after `primedWindow` blocks."}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/StabilityPod/SwingTraderManager.sol", "L397-L447>"]], "vuln": "SwingTraderManager.addSwingTrader will push traderId with `active = false` to activeTraders", "severity": "HIGH", "mitigation": "Change to:\n\n```diff\n  function addSwingTrader(\n    uint256 traderId,\n    address _swingTrader,\n    bool active,\n    string calldata name\n  ) external onlyRoleMalt(ADMIN_ROLE, \"Must have admin privs\") {\n    SwingTraderData storage trader = swingTraders[traderId];\n    require(traderId > 2 && trader.id == 0, \"TraderId already used\");\n    require(_swingTrader != address(0), \"addr(0)\");\n\n    swingTraders[traderId] = SwingTraderData({\n      id: traderId,\n-     index: activeTraders.length,\n+     index: active ? activeTraders.length\u00a0: 0,\n      traderContract: _swingTrader,\n      name: name,\n      active: active\n    });\n+  if(active) activeTraders.push(traderId);\n\n-   activeTraders.push(traderId);\n\n    emit AddSwingTrader(traderId, name, active, _swingTrader);\n  }\n```"}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/StabilityPod/StabilizerNode.sol", "L161-L176>"]], "vuln": "StabilizerNode.stabilize may use undistributed rewards in the overflowPool as collateral", "severity": "MEDIUM", "mitigation": "Call RewardThrottle.checkRewardUnderflow at the beginning of StabilizerNode.stabilize to distribute the rewards in the overflowPool, then call `impliedCollateralService.syncGlobalCollateral()` to synchronize the latest data.\n\n```diff\n  function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {\n    // Ensure data consistency\n    maltDataLab.trackPool();\n\n    // Finalize auction if possible before potentially starting a new one\n    auction.checkAuctionFinalization();\n\n+  RewardThrottle.checkRewardUnderflow();\n+  impliedCollateralService.syncGlobalCollateral();\n\n    require(\n      block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),\n      \"Can't call stabilize\"\n    );\n```"}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/RewardSystem/RewardThrottle.sol", "L690-L696>"]], "vuln": "RewardThrottle.setTimekeeper: If changing the timekeeper causes the epoch to change, it will mess up the system", "severity": "MEDIUM", "mitigation": "Consider only allowing setTimekeeper to be called when RewardThrottle is not active."}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/StabilityPod/SwingTraderManager.sol", "L252-L258>"]], "vuln": "Value of `totalProfit` might be wrong because of wrong logic in function `sellMalt()`", "severity": "MEDIUM", "mitigation": "Updating `totalProfit` before the dust check in function `sellMalt()`."}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/RewardSystem/RewardThrottle.sol", "L660-L688>"]], "vuln": "RewardThrottle.populateFromPreviousThrottle may be exposed to front-run attack", "severity": "MEDIUM", "mitigation": "If populateFromPreviousThrottle is used to initialize the state in the current RewardThrottle, it should be called on contract setup."}
{"locs": [["code-423n4/2023-02-malt", "700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9", "contracts/RewardSystem/LinearDistributor.sol", "L111-L153>"]], "vuln": "LinearDistributor.declareReward: previouslyVested may update incorrectly, which will cause some rewards to be lost", "severity": "MEDIUM", "mitigation": "Consider adapting previouslyVested based on distributed:\n\n```diff\n    uint256 linearBondedValue = rewardMine.valueOfBonded();\n\n    uint256 distributed = (linearBondedValue * netVest) / vestingBondedValue;\n    uint256 balance = collateralToken.balanceOf(address(this));\n\n    if (distributed > balance) {\n      distributed = balance;\n+    currentlyVested = distributed * vestingBondedValue / linearBondedValue + previouslyVested;\n    }\n```"}
{"locs": [["code-423n4/2023-01-popcorn", "d95fc31449c260901811196d617366d6352258cd", "src/utils/MultiRewardStaking.sol", "L170-L187>"]], "vuln": "Staking rewards can be drained", "severity": "HIGH", "mitigation": "Follow the checks-effects-interactions pattern and clear out `accruedRewards[user][_rewardTokens[i]]` before transferring.\n\nAdditionally, it would be a good idea to add a ReentrancyGuard modifier to the function."}
{"locs": [["code-423n4/2023-01-popcorn", "d95fc31449c260901811196d617366d6352258cd", "src/vault/Vault.sol", "L480-L494>"]], "vuln": "The calculation of ````takeFees```` in ````Vault```` contract is incorrect", "severity": "MEDIUM", "mitigation": "Use the correct formula such as:\n\n```diff\n    modifier takeFees() {\n        uint256 managementFee = accruedManagementFee();\n        uint256 totalFee = managementFee + accruedPerformanceFee();\n        uint256 currentAssets = totalAssets();\n        uint256 shareValue = convertToAssets(1e18);\n\n        if (shareValue > highWaterMark) highWaterMark = shareValue;\n\n        if (managementFee > 0) feesUpdatedAt = block.timestamp;\n\n-       if (totalFee > 0 && currentAssets > 0)\n-           _mint(feeRecipient, convertToShares(totalFee));\n+       if (totalFee > 0 && currentAssets > 0) {\n+           uint256 supply = totalSupply();\n+           uint256 feeInShare = supply == 0\n+               ? totalFee\n+               : totalFee.mulDiv(supply, currentAssets - totalFee, Math.Rounding.Down);\n+           _mint(feeRecipient, feeInShare);\n+       }\n\n        _;\n    }\n```"}
{"locs": [["code-423n4/2023-01-popcorn", "d95fc31449c260901811196d617366d6352258cd", "src/vault/adapter/abstracts/AdapterBase.sol", "L479-L483>"]], "vuln": "AdapterBase should always use delegatecall to call the functions in the strategy", "severity": "MEDIUM", "mitigation": "In `AdapterBase.\\_verifyAndSetupStrategy`, the verifyAdapterSelectorCompatibility/verifyAdapterCompatibility/setUp functions are called using delegatecall."}
{"locs": [["code-423n4/2023-01-popcorn", "d95fc31449c260901811196d617366d6352258cd", "src/vault/Vault.sol", "L496-L499)"]], "vuln": "`syncFeeCheckpoint()` does not modify the highWaterMark correctly, sometimes it might even decrease its value, resulting in charging more performance fees than it should", "severity": "MEDIUM", "mitigation": "Revise the `syncFeeCheckpoint()` as follows:\n\n     modifier syncFeeCheckpoint() {\n            _;\n         \n             uint256 shareValue = convertToAssets(1e18);\n\n            if (shareValue > highWaterMark) highWaterMark = shareValue;\n        }"}
{"locs": [["code-423n4/2023-01-popcorn", "main", "src/vault/Vault.sol", "L540-L546>"]], "vuln": "Anyone can reset fees to 0 value when Vault is deployed", "severity": "MEDIUM", "mitigation": "```solidity\n    function changeFees() external {\n        if (proposedFeeTime == 0 || block.timestamp < proposedFeeTime + quitPeriod)\n            revert NotPassedQuitPeriod(quitPeriod);\n\n        emit ChangedFees(fees, proposedFees);\n        fees = proposedFees;\n    }\n```"}
{"locs": [["code-423n4/2023-01-numoen", "2ad9a73d793ea23a25a381faadc86ae0c8cb5913", "src/core/Pair.sol", "L56"]], "vuln": "Precision loss in the invariant function can lead to loss of funds", "severity": "HIGH", "mitigation": "Make sure to multiply first before division to prevent precision loss.\n```solidity\n  /// @inheritdoc IPair\n  function invariant(uint256 amount0, uint256 amount1, uint256 liquidity) public view override returns (bool) {\n    if (liquidity == 0) return (amount0 == 0 && amount1 == 0);\n\n    uint256 scale0 = FullMath.mulDiv(amount0 * token0Scale, 1e18, liquidity) ;//@audit-info change here\n    uint256 scale1 = FullMath.mulDiv(amount1 * token1Scale, 1e18, liquidity) ;//@audit-info change here\n\n    if (scale1 > 2 * upperBound) revert InvariantError();\n\n    uint256 a = scale0 * 1e18;\n    uint256 b = scale1 * upperBound;\n    uint256 c = (scale1 * scale1) / 4;\n    uint256 d = upperBound * upperBound;\n\n    return a + b >= c + d;\n  }\n\n```"}
{"locs": [["code-423n4/2023-01-numoen", "main", "src/core/Lendgine.sol", "L99"]], "vuln": "Fee on transfer tokens will not behave as expected", "severity": "MEDIUM", "mitigation": "Consider:\n\n1. whitelisting token0 and token1 ensuring no fee-on-transfer token is allowed when a new instance of a market is created using the factory, or\n2. calculating the balance before and after the transfer of token1 (collateral), and use the difference between those two balances as the amount received rather than using the input amount `collateral` if deflationary token is going to be allowed in the protocol."}
{"locs": [["code-423n4/2023-01-numoen", "2ad9a73d793ea23a25a381faadc86ae0c8cb5913", "src/core/Pair.sol", "L53-L140"]], "vuln": "Economical games that can be played to gain MEV", "severity": "MEDIUM", "mitigation": "There are two things that could be done in the future to mitigate issues:\n- value the bigger markets more than the smaller ones, where users are incentivized to use the bigger markets.\n- Use an aggregator that crawls over several markets and let liquidity providers to stake in a range of liquidity."}
{"locs": [["code-423n4/2023-01-numoen", "2ad9a73d793ea23a25a381faadc86ae0c8cb5913", "src/periphery/UniswapV2/libraries/UniswapV2Library.sol", "L27"]], "vuln": "Wrong init code hash", "severity": "MEDIUM", "mitigation": "Integrate the latest version of UniswapV2."}
{"locs": [["code-423n4/2023-01-numoen", "2ad9a73d793ea23a25a381faadc86ae0c8cb5913", "src/periphery/LiquidityManager.sol", "L135"]], "vuln": "First liquidity provider will suffer from revert or fund loss", "severity": "MEDIUM", "mitigation": "Add a functionality to calculate the liquidity for the first deposit on-chain.\nAnd it is also recommended to add preview functions."}
{"locs": [["rabbitholegg/quest-protocol", "8c4c1f71221570b14a0479c216583342bd652d8d", "contracts/Quest.sol", "L113"]], "vuln": "Buyer on secondary NFT market can lose fund if they buy a NFT that is already used to claim the reward", "severity": "MEDIUM", "mitigation": "Disable NFT transfer and trade once the NFT is used to claim the reward."}
{"locs": [["rabbitholegg/quest-protocol", "8c4c1f71221570b14a0479c216583342bd652d8d", "contracts/QuestFactory.sol", "L219-L229"]], "vuln": "Possible scenario for Signature Replay Attack", "severity": "MEDIUM", "mitigation": "Consider including deadline, chainid and QuestFactory's address in the signature message. Ideally signatures should be created according to the [EIP712](https://eips.ethereum.org/EIPS/eip-712) standard."}
{"locs": [["code-423n4/2023-01-timeswap", "ef4c84fb8535aad8abd6b67cc45d994337ec4514", "packages/v2-token/src/base/ERC1155Enumerable.sol", "L116-L121>."]], "vuln": "`_ownedTokensIndex` is SHARED by different owners, as a result, `_removeTokenFromAllTokensEnumeration` might remove the wrong tokenId.", "severity": "MEDIUM", "mitigation": "Redefine `ownedTokensIndex` so that is is not shared:\n\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokensIndex;"}
{"locs": [["ProjectOpenSea/seaport", "5de7302bc773d9821ba4759e47fc981680911ea0", "contracts/lib/ConsiderationEncoder.sol", "L569-L574)"]], "vuln": "Incorrect Encoding of Order Hashes", "severity": "MEDIUM", "mitigation": "We advise the `offset` instruction to be omitted as the current implementation will copy from unsafe memory space, causing data corruption in the worst-case scenario and incorrect order hashes being specified in the encoded payload. As an additional point, the `_encodeOrderHashes` will fail execution if the array of order hashes is empty as a `headAndTailSize` of `0` will cause the `MemoryPointerLib::copy` function to fail as the precompile would yield a `returndatasize()` of `0`."}
{"locs": [["reserve-protocol/protocol", "df7ecadc2bae74244ace5e8b39e94bc992903158", "contracts/libraries/RedemptionBattery.sol", "L59-L70"]], "vuln": "Battery discharge mechanism doesn\u2019t work correctly for first redemption", "severity": "MEDIUM", "mitigation": "The `battery.lastBlock` value must be initialized in the `init` function of `RTokenP1`\n```solidity\n    function init(\n        // ...\n    ) external initializer {\n        // ...\n        battery.lastBlock = uint48(block.number);\n    }\n```"}
{"locs": [["reserve-protocol/protocol", "df7ecadc2bae74244ace5e8b39e94bc992903158", "contracts/plugins/assets/Asset.sol", "L144-L145"]], "vuln": "Asset.lotPrice() doesn\u2019t use the most recent price in case of oracle timeout", "severity": "MEDIUM", "mitigation": "Allow specifying a timeout to `tryPrice()`, in case that `tryPrice()` fails due to oracle timeout then call it again with `priceTimeout` as the timeout.\nIf the call succeeds the second time then use it as the most recent price for fallback calculations."}
{"locs": [["reserve-protocol/protocol", "df7ecadc2bae74244ace5e8b39e94bc992903158", "contracts/p1/StRSR.sol", "L560-L564"]], "vuln": "In case that unstakingDelay is decreased, users who have previously unstaked would have to wait more than unstakingDelay for new unstakes", "severity": "MEDIUM", "mitigation": "Allow users to use current delay even if it was previously higher. I think this should apply not only to new drafts but also for drafts that were created before the change.\nAlternatively, the protocol can set a rule that even if the staking delay was lowered stakers have to wait at least the old delay since the change till they can withdraw.  But in this case the rule should apply to everybody regardless if they have pending drafts or not."}
{"locs": [["reserve-protocol/protocol", "df7ecadc2bae74244ace5e8b39e94bc992903158", "contracts/p1/mixins/RecollateralizationLib.sol", "L449"]], "vuln": "Shortfall might be calculated incorrectly if a price value for one collateral isn\u2019t fetched correctly", "severity": "MEDIUM", "mitigation": "Check that price is correctly fetched for a collateral."}
{"locs": [["reserve-protocol/protocol", "df7ecadc2bae74244ace5e8b39e94bc992903158", "contracts/p1/mixins/RecollateralizationLib.sol", "L275"]], "vuln": "RecollateralizationLib: Dust loss for an asset should be capped at it\u2019s low value", "severity": "MEDIUM", "mitigation": "I suggest that an asset can only incur as much dust loss as its balance is.  \nIf the protocol only holds `$5` of asset A then this should not cause a dust loss of say `$10`.  \n\nThe fix first saves the `assetLow` value which should be saved to memory because it is now needed two times then it caps the dust loss of an asset at its low value:  \n\n```\ndiff --git a/contracts/p1/mixins/RecollateralizationLib.sol b/contracts/p1/mixins/RecollateralizationLib.sol\nindex 648d1813..b5b86cac 100644\n--- a/contracts/p1/mixins/RecollateralizationLib.sol\n+++ b/contracts/p1/mixins/RecollateralizationLib.sol\n@@ -261,7 +261,8 @@ library RecollateralizationLibP1 {\n \n             // Intentionally include value of IFFY/DISABLED collateral when low is nonzero\n             // {UoA} = {UoA} + {UoA/tok} * {tok}\n-            assetsLow += low.mul(bal, FLOOR);\n+            uint192 assetLow = low.mul(bal,FLOOR);\n+            assetsLow += assetLow;\n             // += is same as Fix.plus\n \n             // assetsHigh += high.mul(bal, CEIL), where assetsHigh is [0, FIX_MAX]\n@@ -272,7 +273,7 @@ library RecollateralizationLibP1 {\n             // += is same as Fix.plus\n \n             // Accumulate potential losses to dust\n-            potentialDustLoss = potentialDustLoss.plus(rules.minTradeVolume);\n+            potentialDustLoss = potentialDustLoss.plus(fixMin(rules.minTradeVolume, assetLow));\n         }\n \n         // Account for all the places dust could get stuck\n```"}
{"locs": [["code-423n4/2023-01-astaria", "main", "src/AstariaRouter.sol", "L639-L647>"]], "vuln": "Wrong starting price when listing on Seaport for assets that has less than 18 decimals", "severity": "HIGH", "mitigation": "1.  Either fetch the asset's decimals on-chain or add it as a part of the strategy.\n2.  Convert liquidationInitialAsk to the asset's decimals before passing it as a starting price."}
{"locs": [["code-423n4/2023-01-astaria", "1bfc58b42109b839528ab1c21dc9803d663df898", "src/CollateralToken.sol", "L526-L534>"]], "vuln": "`settleAuction()` Check for status errors", "severity": "MEDIUM", "mitigation": "```solidity\n\n  function settleAuction(uint256 collateralId) public {\n    if (\n-     s.collateralIdToAuction[collateralId] == bytes32(0) &&\n-    ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(\n-        s.idToUnderlying[collateralId].tokenId\n-      ) !=\n-      s.clearingHouse[collateralId]\n+      s.collateralIdToAuction[collateralId] == bytes32(0) || \n+       ERC721(s.idToUnderlying[collateralId].tokenContract).ownerOf(s.idToUnderlying[collateralId].tokenId\n+      ) == \n+      s.clearingHouse[collateralId]\n    ) {\n      revert InvalidCollateralState(InvalidCollateralStates.NO_AUCTION);\n    }\n```"}
{"locs": [["code-423n4/2023-01-astaria", "1bfc58b42109b839528ab1c21dc9803d663df898", "src/LienToken.sol", "L366-L368>"]], "vuln": "`LienToken.transferFrom` There is a possibility of malicious attack", "severity": "MEDIUM", "mitigation": "The corresponding vault address is stored in s.lienMeta\\[id].orginOwner when the LienToken is created, this is not modified. Get the vault address from this variable, not from ownerOf(id)."}
{"locs": [["code-423n4/2023-01-astaria", "main", "src/PublicVault.sol", "L323-L325>"]], "vuln": "yIntercept of public vaults can overflow", "severity": "MEDIUM", "mitigation": "Remove the unchecked block.\n\n***"}
{"locs": [["code-423n4/2023-01-astaria", "1bfc58b42109b839528ab1c21dc9803d663df898", "src/WithdrawProxy.sol", "L152-L161>"]], "vuln": "WithdrawProxy allows `redeem()` to be called before withdraw reserves are transferred in", "severity": "MEDIUM", "mitigation": "Add an additional storage variable that is explicitly switched to `open` when it is safe to withdraw funds."}
{"locs": [["code-423n4/2023-01-astaria", "1bfc58b42109b839528ab1c21dc9803d663df898", "src/AstariaRouter.sol", "L611-L619>"]], "vuln": "Users can liquidate themselves before others, allowing them to take 13% above their borrowers", "severity": "MEDIUM", "mitigation": "Don't allow users to liquidate their own loans until they are liquidatable by the public."}
{"locs": [["AstariaXYZ/astaria-gpl", "4b49fe993d9b807fe68b3421ee7f2fe91267c9ef", "src/ERC4626RouterBase.sol", "L41-L52>"]], "vuln": "`ERC4626RouterBase.withdraw` can only be called once", "severity": "MEDIUM", "mitigation": "Change to\n\n```diff\n  function withdraw(\n    IERC4626 vault,\n    address to,\n    uint256 amount,\n-   uint256 maxSharesOut\n+  uint256 maxSharesIn\n  ) public payable virtual override returns (uint256 sharesOut) {\n+   ERC20(address(vault)).safeApprove(address(vault), maxSharesIn);\n+   if ((sharesIn = vault.withdraw(amount, to, msg.sender)) > maxSharesIn) {\n-   ERC20(address(vault)).safeApprove(address(vault), amount);\n-   if ((sharesOut = vault.withdraw(amount, to, msg.sender)) > maxSharesOut) {\n      revert MaxSharesError();\n    }\n+   ERC20(address(vault)).safeApprove(address(vault), 0);\n\n  }\n```"}
{"locs": [["code-423n4/2023-01-astaria", "main", "src/PublicVault.sol", "L275-L337>"]], "vuln": "`PublicVault.processEpoch` updates `YIntercept` incorrectly when `totalAssets() <= expected`", "severity": "MEDIUM", "mitigation": "In case when `totalAssets() <= expected` do not call `_setYIntercept`.\n\n***"}
{"locs": [["code-423n4/2023-01-astaria", "main", "src/Vault.sol", "L59>"]], "vuln": "Pause checks are missing on deposit for Private Vault", "severity": "MEDIUM", "mitigation": "Revise the deposit function as below:\n\n    function deposit(uint256 amount, address receiver)\n        public\n        virtual \n        whenNotPaused\n        returns (uint256)\n      {\n        VIData storage s = _loadVISlot();\n        require(s.allowList[msg.sender] && receiver == owner());\n        ERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);\n        return amount;\n      }"}
{"locs": [["code-423n4/2023-01-biconomy", "53c8c3823175aeb26dee5529eeefa81240a406ba", "scw-contracts/contracts/smart-contract-wallet/paymasters/verifying/singleton/VerifyingSingletonPaymaster.sol", "L97-L111)"]], "vuln": "Paymaster ETH can be drained with malicious sender", "severity": "HIGH", "mitigation": "Since `validatePaymasterUserOp` function is not limited to view function in erc4337 spec, add simple boolean data for mapping if hash is used or not\n\n    mapping(bytes32 => boolean) public usedHash\n\n        function validatePaymasterUserOp(UserOperation calldata userOp, bytes32 /*userOpHash*/, uint256 requiredPreFund)\n        external override returns (bytes memory context, uint256 deadline) {\n            (requiredPreFund);\n            bytes32 hash = getHash(userOp);\n            require(!usedHash[hash], \"used hash\");\n            usedHash[hash] = true;"}
{"locs": [["code-423n4/2023-01-biconomy", "53c8c3823175aeb26dee5529eeefa81240a406ba", "scw-contracts/contracts/smart-contract-wallet/base/ModuleManager.sol", "L18)"]], "vuln": "`SmartAccount.sol` is intended to be upgradable but inherits from contracts that contain storage and no gaps", "severity": "MEDIUM", "mitigation": "Add storage gaps to all inherited contracts that contain storage variables."}
{"locs": [["code-423n4/2023-01-biconomy", "53c8c3823175aeb26dee5529eeefa81240a406ba", "scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol", "L212)<br>"]], "vuln": "Replay attack (EIP712 signed transaction)", "severity": "HIGH", "mitigation": "Add `batchId` to the hash calculation of the transaction in `encodeTransactionData` function."}
{"locs": [["with-backed/papr", "9528f2711ff0c1522076b9f93fba13f88d5bd5e6", "src/PaprController.sol", "L444"]], "vuln": "Stealing fund by applying reentrancy attack on removeCollateral, startLiquidationAuction, and purchaseLiquidationAuctionNFT", "severity": "HIGH", "mitigation": "- Adding a reentrancy guard to the involved functions can be a solution."}
{"locs": [["with-backed/papr", "9528f2711ff0c1522076b9f93fba13f88d5bd5e6", "src/PaprController.sol", "L159"]], "vuln": "Collateral NFT deposited to a wrong address, when transferred directly to PaprController", "severity": "HIGH", "mitigation": "Consider this change:\n```diff\n--- a/src/PaprController.sol\n+++ b/src/PaprController.sol\n@@ -156,7 +156,7 @@ contract PaprController is\n     /// @param _id the id of the NFT\n     /// @param data encoded IPaprController.OnERC721ReceivedArgs\n     /// @return selector indicating succesful receiving of the NFT\n-    function onERC721Received(address from, address, uint256 _id, bytes calldata data)\n+    function onERC721Received(address, address from, uint256 _id, bytes calldata data)\n         external\n         override\n         returns (bytes4)\n```"}
{"locs": [["with-backed/papr", "9528f2711ff0c1522076b9f93fba13f88d5bd5e6", "src/PaprController.sol", "L226"]], "vuln": "PaprController pays swap fee in buyAndReduceDebt, not user", "severity": "MEDIUM", "mitigation": "Consider this change:\n```diff\n--- a/src/PaprController.sol\n+++ b/src/PaprController.sol\n@@ -223,7 +223,7 @@ contract PaprController is\n         );\n\n         if (hasFee) {\n-            underlying.transfer(params.swapFeeTo, amountIn * params.swapFeeBips / BIPS_ONE);\n+            underlying.safeTransferFrom(msg.sender, params.swapFeeTo, amountIn * params.swapFeeBips / BIPS_ONE);\n         }\n\n         _reduceDebt({account: account, asset: collateralAsset, burnFrom: msg.sender, amount: amountOut});\n```"}
{"locs": [["with-backed/papr", "9528f2711ff0c1522076b9f93fba13f88d5bd5e6", "src/PaprController.sol", "L264-L294"]], "vuln": "User fund loss because function purchaseLiquidationAuctionNFT() takes extra liquidation penalty when user\u2019s last collateral is liquidated, (set wrong value for maxDebtCached when isLastCollateral is true)", "severity": "MEDIUM", "mitigation": "the code should be like this:\n```\nuint256 maxDebtCached = isLastCollateral ? 0: _maxDebt(collateralValueCached, updateTarget());\n```"}
{"locs": [["code-423n4/2022-12-tessera", "f37a11407da2af844bbfe868e1422e3665a5f8e4", "src/seaport/modules/OptimisticListingSeaport.sol", "L112-L116>"]], "vuln": "Attacker can DOS OptimisticListing with very low cost", "severity": "HIGH", "mitigation": "Require the total value of the new collateral to be greater than the previous.\n\nThis however still allows a Rae holder with sufficiently large holding to block proposal by creating a new proposal and immediately reject it himself."}
{"locs": [["code-423n4/2022-12-tessera", "f37a11407da2af844bbfe868e1422e3665a5f8e4", "src/modules/GroupBuy.sol", "L186-L188>"]], "vuln": "GroupBuy may purchase NFT not in the allowed list", "severity": "MEDIUM", "mitigation": "Hash the tokenId even if there is only when length is 1."}
{"locs": [["code-423n4/2022-12-tessera", "f37a11407da2af844bbfe868e1422e3665a5f8e4", "src/seaport/targets/SeaportLister.sol", "L29-L46>"]], "vuln": "Orders may not be fillable due to missing approvals", "severity": "MEDIUM", "mitigation": "Use OpenZeppelin's `safeApprove()`, which checks the return code and reverts if it's not success."}
{"locs": [["code-423n4/2022-12-tessera", "f37a11407da2af844bbfe868e1422e3665a5f8e4", "src/seaport/targets/SeaportLister.sol", "L29-L46"]], "vuln": "Only one GroupBuy can ever use USDT or similar tokens with front-running approval protections", "severity": "MEDIUM", "mitigation": "Always reset the approval to zero before changing it to the maximum"}
{"locs": [["code-423n4/2022-12-tessera", "f37a11407da2af844bbfe868e1422e3665a5f8e4", "src/seaport/modules/OptimisticListingSeaport.sol", "L209"]], "vuln": "Loss of ETH for proposer when it is a contract that doesn\u2019t have fallback function.", "severity": "MEDIUM", "mitigation": "Either enforce that proposer is an EOA or take in a recipient address for ETH transfers."}
{"locs": [["code-423n4/2022-12-tessera", "f37a11407da2af844bbfe868e1422e3665a5f8e4", "src/modules/GroupBuy.sol", "L308-L320), which falls under the case where the price is the same and the quantity is different. The readme states `If two users place bids at the same price but with different quantities, the queue will pull from the bid with a higher quantity first`, and as the submission shows, it's pulling from the higher quantity first - doesn't that mean this finding is invalid?"]], "vuln": " Earlier bidders get cut out of future NFT holdings by bidders specifying the same price.", "severity": "MEDIUM", "mitigation": "Change the < to <= in the if condition:\n\n    if (_price <= lowestBid.price) {\n        break;\n    }"}
{"locs": [["code-423n4/2022-12-tessera", "f37a11407da2af844bbfe868e1422e3665a5f8e4", "src/modules/GroupBuy.sol", "L83"]], "vuln": "GroupBuys that are completely filled still don\u2019t raise stated target amount", "severity": "MEDIUM", "mitigation": "Round the minBidPrices up, rather than down. It will ensure enough funds are collected."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/MinipoolManager.sol", "L374"]], "vuln": "AVAX Assigned High Water is updated incorrectly", "severity": "HIGH", "mitigation": "Call `staking.resetAVAXAssignedHighWater(owner)` instead of calling `increaseAVAXAssignedHighWater()`.\n\n```solidity\nMinipoolManager.sol\n373: \t\tif (staking.getAVAXAssignedHighWater(owner) < staking.getAVAXAssigned(owner)) {\n374: \t\t\tstaking.resetAVAXAssignedHighWater(owner); //@audit update to the current AVAX assigned\n375: \t\t}\n```"}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/Staking.sol", "L379-L383"]], "vuln": "ProtocolDAO lacks a method to take out GGP", "severity": "HIGH", "mitigation": "1.transfer GGP to  ClaimProtocolDAO \nor\n2.Similar to ClaimProtocolDAO, add spend method to retrieve GGP\n\n```solidity\ncontract ProtocolDAO is Base {\n...\n\n+    function spend(\n+        address recipientAddress,\n+        uint256 amount\n+    ) external onlyGuardian {\n+        Vault vault = Vault(getContractAddress(\"Vault\"));\n+        TokenGGP ggpToken = TokenGGP(getContractAddress(\"TokenGGP\"));\n+\n+        if (amount == 0 || amount > vault.balanceOfToken(\"ProtocolDAO\", ggpToken)) {\n+            revert InvalidAmount();\n+        }\n+\n+        vault.withdrawToken(recipientAddress, ggpToken, amount);\n+\n+        emit GGPTokensSentByDAOProtocol(address(this), recipientAddress, amount);\n+   }\n```"}
{"locs": [["code-423n4/2022-12-gogopool", "main", "contracts/contract/MinipoolManager.sol", "L673-L675"]], "vuln": "Node operator is getting slashed for full duration even though rewards are distributed based on a 14 day cycle", "severity": "HIGH", "mitigation": "Either hard code the duration to 14 days for calculating expected rewards or calculate the actual duration using `startTime` and `endTime`."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/tokens/upgradeable/ERC4626Upgradeable.sol", "L123"]], "vuln": "Inflation of ggAVAX share price by first depositor", "severity": "HIGH", "mitigation": "When creating the vault add initial funds in order to make it harder to inflate the price. \nBest practice would add initial funds as part of the initialization of the contract (to prevent front-running)."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/RewardsPool.sol", "L155-L197"]], "vuln": "RewardsPool.sol : It is safe to have the startRewardsCycle with WhenNotPaused modifier", "severity": "MEDIUM", "mitigation": "We suggest to use `WhenNotPaused` modifier."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/MultisigManager.sol", "L80-L91"]], "vuln": "requireNextActiveMultisig will always return the first enabled multisig which increases the probability of stuck minipools", "severity": "MEDIUM", "mitigation": "Use a strategy like [round robin](https://en.wikipedia.org/wiki/Round-robin_item_allocation) to assign next active multisig to minipool\n\nSomething like this :\n\n```solidity\nprivate uint nextMultisigAddressIdx;\n\nfunction requireNextActiveMultisig() external view returns (address) {\n    uint256 total = getUint(keccak256(\"multisig.count\"));\n    address addr;\n    bool enabled;\n\n    uint256 i = nextMultisigAddressIdx; // cache last used\n    if (nextMultisigAddressIdx==total) {\n        i = 0;\n    }\n\n    for (; i < total; i++) {\n        (addr, enabled) = getMultisig(i);\n        if (enabled) {\n            nextMultisigAddressIdx = i+1;\n            return addr;\n        }\n    }\n    \n    revert NoEnabledMultisigFound();\n}\n```"}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/RewardsPool.sol", "L98"]], "vuln": "Inflation rate can be reduced by half at most if it gets called every 1.99 interval", "severity": "MEDIUM", "mitigation": "Consider only increasing `InflationIntervalStartTime` by the amount of intervals time interval length."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/MinipoolManager.sol", "L664"]], "vuln": "Rialto may not be able to cancel minipools created by contracts that cannot receive AVAX", "severity": "MEDIUM", "mitigation": "Consider using the [Pull over Push pattern](https://fravoll.github.io/solidity-patterns/pull_over_push.html) to return AVAX to owners of minipools that are canceled by Rialto."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/MinipoolManager.sol", "L450"]], "vuln": "Recreated pools receive a wrong AVAX amount due to miscalculated compounded liquid staker amount", "severity": "MEDIUM", "mitigation": "When compounding rewards in the `recreateMinipool` function, consider using an average reward so that node operator's and liquid stakers' deposits are increased equally and the entire reward amount is used:\n```diff\n--- a/contracts/contract/MinipoolManager.sol\n+++ b/contracts/contract/MinipoolManager.sol\n@@ -443,18 +443,22 @@ contract MinipoolManager is Base, ReentrancyGuard, IWithdrawer {\n        /// @param nodeID 20-byte Avalanche node ID\n        function recreateMinipool(address nodeID) external whenNotPaused {\n                int256 minipoolIndex = onlyValidMultisig(nodeID);\n                requireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);\n                Minipool memory mp = getMinipool(minipoolIndex);\n                // Compound the avax plus rewards\n                // NOTE Assumes a 1:1 nodeOp:liqStaker funds ratio\n-               uint256 compoundedAvaxNodeOpAmt = mp.avaxNodeOpAmt + mp.avaxNodeOpRewardAmt;\n+               uint256 nodeOpRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpRewardAmt\")));\n+               uint256 liquidStakerRewardAmt = getUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerRewardAmt\")));\n+               uint256 avgRewardAmt = (nodeOpRewardAmt + liquidStakerRewardAmt) / 2;\n+\n+               uint256 compoundedAvaxNodeOpAmt = mp.avaxNodeOpAmt + avgRewardAmt;\n                setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxNodeOpAmt\")), compoundedAvaxNodeOpAmt);\n                setUint(keccak256(abi.encodePacked(\"minipool.item\", minipoolIndex, \".avaxLiquidStakerAmt\")), compoundedAvaxNodeOpAmt);\n\n                Staking staking = Staking(getContractAddress(\"Staking\"));\n                // Only increase AVAX stake by rewards amount we are compounding\n                // since AVAX stake is only decreased by withdrawMinipool()\n-               staking.increaseAVAXStake(mp.owner, mp.avaxNodeOpRewardAmt);\n+               staking.increaseAVAXStake(mp.owner, avgRewardAmt);\n                staking.increaseAVAXAssigned(mp.owner, compoundedAvaxNodeOpAmt);\n                staking.increaseMinipoolCount(mp.owner);\n```\n\nAlso, consider sending equal amounts of rewards to the vault and the ggAVAX token in the `recordStakingEnd` function."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/MinipoolManager.sol", "L444"]], "vuln": "State Transition: Minipools can be created using other operator\u2019s AVAX deposit via recreateMinipool", "severity": "MEDIUM", "mitigation": "Make sure to keep the node operator's deposit status the same for all states that can lead to the same state.\nFor example, for all states that can transition to Prelaunch, make sure to send the AVAX back to the user and get them back on the call `recreateMiniPool()`."}
{"locs": [["code-423n4/2022-12-gogopool", "main", "contracts/contract/Staking.sol", "L379-L383"]], "vuln": "Slashing fails when node operator doesn\u2019t have enough staked GGP", "severity": "MEDIUM", "mitigation": "If the amount to be slashed is greater than what the node operator has staked, slash all their stake."}
{"locs": [["code-423n4/2022-12-gogopool", "aec9928d8bdce8a5a4efe45f54c39d4fc7313731", "contracts/contract/MultisigManager.sol", "L41-L43"]], "vuln": "MultisigManager may not be able to add a valid Multisig", "severity": "MEDIUM", "mitigation": "add replace old mulitsig method\n\n```solidity\n    function replaceMultisig(address addr,address oldAddr) external onlyGuardian {\n        int256 multisigIndex = getIndexOf(oldAddr);\n        if (multisigIndex == -1) {\n            revert MultisigNotFound();\n        }\n\n        setAddress(keccak256(abi.encodePacked(\"multisig.item\", multisigIndex, \".address\")), addr);\n        emit RegisteredMultisig(addr, msg.sender);\n    }\n```"}
{"locs": [["smartcontractkit/chainlink", "286a65065fcfa5e1b2362745079cdc218e40e68d", "contracts/src/v0.8/VRFCoordinatorV2.sol", "L370) at request-time, but rather checked in Chainlink [node](https://github.com/smartcontractkit/chainlink/blob/806ee17236ba70926a1f07d1141808b634db48b6/core/services/vrf/listener_v2.go#L346) code as well as on-chain by [VRFCoordinator](https://github.com/smartcontractkit/chainlink/blob/286a65065fcfa5e1b2362745079cdc218e40e68d/contracts/src/v0.8/VRFCoordinatorV2.sol#L594) when the request is satisfied. In the scenario where the subscriptionID lacks funds, there will be a period of 24 hours when user can top up the account and random response will be [sent](https://docs.chain.link/vrf/v2/subscription):"]], "vuln": "Draw organizer can rig the draw to favor certain participants such as their own account.", "severity": "HIGH", "mitigation": "The root cause is that Chainlink response can arrive up to 24 hours from the most request is dispatched, while redraw cooldown can be 1 hour+. The best fix would be to enforce minimum cooldown of 24 hours."}
{"locs": [["code-423n4/2022-12-caviar", "0212f9dc3b6a418803dbfacda0e340e059b8aae2", "src/Pair.sol", "L217-L243> <br><https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L248-L262>"]], "vuln": "It's possible to swap NFT token ids without fee and also attacker can wrap unwrap all the NFT token balance of the Pair contract and steal their air drops for those token ids", "severity": "MEDIUM", "mitigation": "The real solution to prevent this attack (stealing air drops) can be hard. some of the things can be done is:\n* create functionality so admin can call `getAirDrop()` functions during the airdrops before attacker.\n* call `getAirDrop()` (which admin specified) function before unwrapping tokens.\n* make some fee for NFT token unwrapping.\n* create some lock time(some days) for each wrapped NFT that in that lock time only the one who supplied that token can unwrap it.\n* create some delay for unwrapping tokens and if user wants to unwrap token he would receive it after this delay."}
{"locs": [["prepo-io/prepo-monorepo", "feat", "2022-12-prepo/apps/smart-contracts/core/contracts/WithdrawHook.sol", "L66-L72>"]], "vuln": "griefing / blocking / delaying users to withdraw", "severity": "HIGH", "mitigation": "The check how the user periods are handled need to be changed. One possible way is to change the lastUserPeriodReset to a mapping like\n**mapping(address => uint256) private lastUserPeriodReset** to track the time for every user separately.\n\nWith a mapping you can change the condition to:\n\n```solidity\nFile: apps/smart-contracts/core/contracts/WithdrawHook.sol\n18:   mapping(address => uint256) lastUserPeriodReset;\n\nFile: apps/smart-contracts/core/contracts/WithdrawHook.sol\n66:     if (lastUserPeriodReset[_sender] + userPeriodLength < block.timestamp) {\n67:       lastUserPeriodReset[_sender] = block.timestamp;\n68:       userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee;\n69:     } else {\n70:       require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, \"user withdraw limit exceeded\");\n71:       userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee;\n72:     }\n```\n\nWith this change, we can change the test to how we would normaly expect the contract to work and see that it is correct.\n\n```node\n    it('withdraw limit is checked for every use seperatly', async () => {\n      \n      // first withdraw with the limit amount for a user\n      await withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      \n      // we move to a new epoch in the future\n      const previousResetTimestamp = await getLastTimestamp(ethers.provider)\n      await setNextTimestamp(\n        ethers.provider,\n        previousResetTimestamp + TEST_USER_PERIOD_LENGTH + 1\n      )\n      \n      // now another user is the first one to withdraw in this new epoch      \n      await withdrawHook.connect(collateralSigner).hook(user2.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      \n      // the first user also can withdraw his limit in this epoch\n      await withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)      \n      \n      // we move the time, but stay in the same epoch\n      const previousResetTimestamp2 = await getLastTimestamp(ethers.provider)\n      await setNextTimestamp(\n        ethers.provider,\n        previousResetTimestamp2 + TEST_USER_PERIOD_LENGTH - 1\n      )\n\n      // this now will fail as we're in the same epoch\n      await expect(\n        withdrawHook.connect(collateralSigner).hook(user.address, 1, 1)\n      ).to.revertedWith('user withdraw limit exceeded')\n      \n    })\n```"}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/Trading.sol", "L267-L269"]], "vuln": "Bypass the maximum PnL check to take extra profit", "severity": "HIGH", "mitigation": "Add a check for ````addToPosition()```` function, revert if PnL >= 500%, enforce users to close the order to take a limited profit."}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/Trading.sol", "L295"]], "vuln": "Incorrect calculation of new price while adding position", "severity": "HIGH", "mitigation": "Use the correct formula, the following test case is for the same above examples after fix.\n\n```\nconst { expect } = require(\"chai\");\nconst { deployments, ethers, waffle } = require(\"hardhat\");\nconst { parseEther, formatEther } = ethers.utils;\nconst { signERC2612Permit } = require('eth-permit');\nconst exp = require(\"constants\");\n\ndescribe(\"Correct calculation of new margin price while adding position\", function () {\n  let owner;\n  let node;\n  let user;\n  let node2;\n  let node3;\n  let proxy;\n\n  let Trading;\n  let trading;\n\n  let TradingExtension;\n  let tradingExtension;\n\n  let TradingLibrary;\n  let tradinglibrary;\n\n  let StableToken;\n  let stabletoken;\n\n  let StableVault;\n  let stablevault;\n\n  let position;\n\n  let pairscontract;\n  let referrals;\n\n  let permitSig;\n  let permitSigUsdc;\n\n  let MockDAI;\n  let mockdai;\n  let MockUSDC;\n  let mockusdc;\n\n  let badstablevault;\n\n  let chainlink;\n\n  beforeEach(async function () {\n    await deployments.fixture(['test']);\n    [owner, node, user, node2, node3, proxy] = await ethers.getSigners();\n    StableToken = await deployments.get(\"StableToken\");\n    stabletoken = await ethers.getContractAt(\"StableToken\", StableToken.address);\n    Trading = await deployments.get(\"Trading\");\n    trading = await ethers.getContractAt(\"Trading\", Trading.address);\n    await trading.connect(owner).setMaxWinPercent(5e10);\n    TradingExtension = await deployments.get(\"TradingExtension\");\n    tradingExtension = await ethers.getContractAt(\"TradingExtension\", TradingExtension.address);\n    const Position = await deployments.get(\"Position\");\n    position = await ethers.getContractAt(\"Position\", Position.address);\n    MockDAI = await deployments.get(\"MockDAI\");\n    mockdai = await ethers.getContractAt(\"MockERC20\", MockDAI.address);\n    MockUSDC = await deployments.get(\"MockUSDC\");\n    mockusdc = await ethers.getContractAt(\"MockERC20\", MockUSDC.address);\n    const PairsContract = await deployments.get(\"PairsContract\");\n    pairscontract = await ethers.getContractAt(\"PairsContract\", PairsContract.address);\n    const Referrals = await deployments.get(\"Referrals\");\n    referrals = await ethers.getContractAt(\"Referrals\", Referrals.address);\n    StableVault = await deployments.get(\"StableVault\");\n    stablevault = await ethers.getContractAt(\"StableVault\", StableVault.address);\n    await stablevault.connect(owner).listToken(MockDAI.address);\n    await stablevault.connect(owner).listToken(MockUSDC.address);\n    await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);\n    await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther(\"1\"));\n    await tradingExtension.connect(owner).setNode(node.address, true);\n    await tradingExtension.connect(owner).setNode(node2.address, true);\n    await tradingExtension.connect(owner).setNode(node3.address, true);\n    await network.provider.send(\"evm_setNextBlockTimestamp\", [2000000000]);\n    await network.provider.send(\"evm_mine\");\n    permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n    permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);\n\n    const BadStableVault = await ethers.getContractFactory(\"BadStableVault\");\n    badstablevault = await BadStableVault.deploy(StableToken.address);\n\n    const ChainlinkContract = await ethers.getContractFactory(\"MockChainlinkFeed\");\n    chainlink = await ChainlinkContract.deploy();\n\n    TradingLibrary = await deployments.get(\"TradingLibrary\");\n    tradinglibrary = await ethers.getContractAt(\"TradingLibrary\", TradingLibrary.address);\n    await trading.connect(owner).setLimitOrderPriceRange(1e10);\n  });\n\n  describe(\"Initial margin $500, leverage 2x, position $1000, price $1000\", function () {\n    let orderId;\n    let initPrice = parseEther(\"1000\");\n    beforeEach(async function () {\n      // To simpliy the problem, set fees to 0\n      await trading.setFees(true, 0, 0, 0, 0, 0);\n      await trading.setFees(false, 0, 0, 0, 0, 0);\n\n      let TradeInfo = [parseEther(\"500\"), MockDAI.address, StableVault.address, parseEther(\"2\"), 1, true, parseEther(\"0\"), parseEther(\"0\"), ethers.constants.HashZero];\n      let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];\n      let message = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, initPrice, 0, 2000000000, false]\n        )\n      );\n      let sig = await node.signMessage(\n        Buffer.from(message.substring(2), 'hex')\n      );\n      \n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];\n      orderId = await position.getCount();\n      await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);\n      expect(await position.assetOpenPositionsLength(1)).to.equal(1);\n      let trade = await position.trades(orderId);\n      let marginAfterFee = trade.margin;\n      expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);\n      expect(trade.price.eq(parseEther('1000'))).to.be.true;\n      expect(trade.leverage.eq(parseEther('2'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\", async function () {\n      // The price increases from $1000 to $2000, the old position earns $1000 profit.\n      // The expected PnL payout = old margin + earned profit + new margin\n      //                         = $500 + $1000 + $500\n      //                         = $2000\n      let addingPrice = parseEther('2000');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('2000'))).to.be.true;\n    });\n\n    it.only(\"Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\", async function () {\n      // The price decreases from $1000 to $750, the old position losses $250.\n      // The expected PnL payout = old margin - loss + new margin\n      //                         = $500 - $250 + $500\n      //                         = $750\n      let addingPrice = parseEther('750');\n      let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];\n      let addingMessage = ethers.utils.keccak256(\n        ethers.utils.defaultAbiCoder.encode(\n          ['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],\n          [node.address, 1, addingPrice, 0, 2000000000, false]\n        )\n      );\n      let addingSig = await node.signMessage(\n        Buffer.from(addingMessage.substring(2), 'hex')\n      );\n\n      let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];\n      await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);\n\n      let trade = await position.trades(orderId);\n      let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,\n        trade.margin, trade.leverage, trade.accInterest);\n      expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;\n      expect(pnl._payout.lt(parseEther('750'))).to.be.true;\n    });\n\n  });\n});\n\n```\n\nThe test result\n```\nCorrect calculation of new margin price while adding position\n    Initial margin $500, leverage 2x, position $1000, price $1000\n      \u221a Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999\n      \u221a Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999\n```"}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/Position.sol", "L126-L161"]], "vuln": "reentrancy attack during mint() function in Position contract which can lead to removing of the other user\u2019s limit orders or stealing contract funds because initId is set low value", "severity": "HIGH", "mitigation": "follow the check-effect-interaction pattern."}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/TradingExtension.sol", "L88-L120"]], "vuln": "User can abuse tight stop losses and high leverage to make risk free trades", "severity": "HIGH", "mitigation": "Take profit and stop loss trades should be executed at the current price rather than the price specified by the user:\n\n             if (_trade.tpPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.tpPrice > _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.tpPrice < _price) revert(\"6\"); //LimitNotMet\n            }\n    -       _limitPrice = _trade.tpPrice;\n    +       _limitPrice = _price;\n        } else {\n            if (_trade.slPrice == 0) revert(\"7\"); //LimitNotSet\n            if (_trade.direction) {\n                if (_trade.slPrice < _price) revert(\"6\"); //LimitNotMet\n            } else {\n                if (_trade.slPrice > _price) revert(\"6\"); //LimitNotMet\n            }\n    -       _limitPrice = _trade.slPrice;\n    +       _limitPrice = _price;"}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/Trading.sol", "L275-L282"]], "vuln": "Not enough margin pulled or burned from user when adding to a position", "severity": "HIGH", "mitigation": "In `Trading.addToPosition` call the `_handleDeposit` function without subtracting the `_fee` value:\n\n```js\n_handleDeposit(\n    _trade.tigAsset,\n    _marginAsset,\n    _addMargin,\n    _stableVault,\n    _permitData,\n    _trader\n);\n```"}
{"locs": [["code-423n4/2022-12-tigris", "main", "contracts/Lock.sol", "L117"]], "vuln": "Must approve 0 first", "severity": "MEDIUM", "mitigation": "Add an approve(0) before approving;\n```\n    function claimGovFees() public {\n        address[] memory assets = bondNFT.getAssets();\n\n        for (uint i=0; i < assets.length; i++) {\n            uint balanceBefore = IERC20(assets[i]).balanceOf(address(this));\n            IGovNFT(govNFT).claim(assets[i]);\n            uint balanceAfter = IERC20(assets[i]).balanceOf(address(this));\n            IERC20(assets[i]).approve(address(bondNFT), 0);\n            IERC20(assets[i]).approve(address(bondNFT), type(uint256).max);\n            bondNFT.distribute(assets[i], balanceAfter - balanceBefore);\n        }\n  }\n```"}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/Trading.sol", "L857-L868"]], "vuln": "Bypass the delay security check to win risk free funds", "severity": "MEDIUM", "mitigation": "Cache recent lowest and highest prices, open long order with the highest price and short order with the lowest price."}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/GovNFT.sol", "L168"]], "vuln": "Failure in endpoint can cause minting more than one NFT with the same token id in different chains", "severity": "MEDIUM", "mitigation": "It is recommended to track the consumed messages, and add a consumed flag whenever the function `lzReceive` is called, because it will either immediately mint the NFT or add it to he failed messages to be minted later.\n```\nmapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public consumedMessage;\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) external override {\n        \n        require(!consumedMessage[_srcChainId][_srcAddress][_nonce], \"already consumed\");\n        consumedMessage[_srcChainId][_srcAddress][_nonce] = true;\n\n        require(_msgSender() == address(endpoint), \"!Endpoint\");\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft()*4/5, 150, abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload));\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n            emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n```"}
{"locs": [["code-423n4/2022-12-tigris", "496e1974ee3838be8759e7b4096dbee1b8795593", "contracts/GovNFT.sol", "L19-L20"]], "vuln": "GovNFT: maxBridge has no effect", "severity": "MEDIUM", "mitigation": "Consider applying the maxBridge variable"}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/Trading.sol", "L857-L868"]], "vuln": "_checkDelay will not work properly for Arbitrum or Optimism due to block.number ", "severity": "MEDIUM", "mitigation": "The delay should be measured using block.timestamp rather than block.number"}
{"locs": [["code-423n4/2022-12-tigris", "496e1974ee3838be8759e7b4096dbee1b8795593", "contracts/Trading.sol", "L565-L576"]], "vuln": "User can close an order via limitClose(), and take bot fees to themselves", "severity": "MEDIUM", "mitigation": "Don't allow updating sl or tp and"}
{"locs": [["code-423n4/2022-12-tigris", "b2ebb8ea1def4927a747e7a185174892506540ab", "contracts/Trading.sol", "L506"]], "vuln": "StopLoss/TakeProfit should be validated again for the new price in Trading.executeLimitOrder()", "severity": "MEDIUM", "mitigation": "Recommend validating sl/tp for the new `trade.price` in `Trading.executeLimitOrder()`."}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/BondNFT.sol", "L168-L187"]], "vuln": "Malicious user can steal all assets in BondNFT", "severity": "HIGH", "mitigation": "I recommend that an expired bond should be forced to `release()`, `claim()` an expired bond should revert.\n\nSample code:\n\n```solidity\n\ndiff --git a/contracts/BondNFT.sol b/contracts/BondNFT.sol\nindex 33a6e76..77e85ae 100644\n--- a/contracts/BondNFT.sol\n+++ b/contracts/BondNFT.sol\n@@ -148,7 +148,7 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         amount = bond.amount;\n         unchecked {\n             totalShares[bond.asset] -= bond.shares;\n-            (uint256 _claimAmount,) = claim(_id, bond.owner);\n+            (uint256 _claimAmount,) = _claim(_id, bond.owner);\n             amount += _claimAmount;\n         }\n         asset = bond.asset;\n@@ -157,8 +157,9 @@ contract BondNFT is ERC721Enumerable, Ownable {\n         _burn(_id);\n         emit Release(asset, lockAmount, _owner, _id);\n     }\n+\n     /**\n-     * @notice Claim rewards from a bond\n+     * @notice Claim rewards from an unexpired bond\n      * @dev Should only be called by a manager contract\n      * @param _id ID of the bond to claim rewards from\n      * @param _claimer address claiming rewards\n@@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {\n     function claim(\n         uint _id,\n         address _claimer\n+    ) public onlyManager() returns(uint amount, address tigAsset) {\n+        Bond memory bond = idToBond(_id);\n+        require(!bond.expired, \"expired\");\n+        return _claim(_id, _claimer);\n+    }\n+\n+    /**\n+     * @notice Claim rewards from a releasing bond or an unexpired bond\n+     * @param _id ID of the bond to claim rewards from\n+     * @param _claimer address claiming rewards\n+     * @return amount amount of tigAsset claimed\n+     * @return tigAsset tigAsset token address\n+     */\n+    function _claim(\n+        uint _id,\n+        address _claimer\n     ) public onlyManager() returns(uint amount, address tigAsset) {\n         Bond memory bond = idToBond(_id);\n         require(_claimer == bond.owner, \"!owner\");\n```"}
{"locs": [["code-423n4/2022-12-tigris", "b2ebb8ea1def4927a747e7a185174892506540ab", "contracts/Trading.sol", "L625-L627"]], "vuln": "Users can bypass the maxWinPercent limit using a partially closing", "severity": "HIGH", "mitigation": "We should check the `maxWinPercent` between the partial payout and partial margin like below.\n\n```solidity\n    _toMint = _handleCloseFees(_trade.asset, uint256(_payout)*_percent/DIVISION_CONSTANT, _trade.tigAsset, _positionSize*_percent/DIVISION_CONSTANT, _trade.trader, _isBot);\n\n    uint256 partialMarginToClose = _trade.margin * _percent / DIVISION_CONSTANT; //+++++++++++++++++++++++\n    if (maxWinPercent > 0 && _toMint > partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) { \n        _toMint = partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;\n    }\n```"}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/BondNFT.sol", "L329"]], "vuln": "BondNFTs can revert when transferred", "severity": "MEDIUM", "mitigation": "The reason for the check is to validate that a bond.expired updated according to the actual timestamp.\nInstead of having \n```\n        require(epoch[bond.asset] == block.timestamp/DAY, \"Bad epoch\");\n        require(!bond.expired, \"Expired!\");\n```\n\nYou could replace it with:\n```\n require(bond.expireEpoch  >= block.timestamp/DAY, \"Transfer after expired not allowed\");\n```"}
{"locs": [["code-423n4/2022-12-tigris", "588c84b7bb354d20cbca6034544c4faa46e6a80e", "contracts/Trading.sol", "L652"]], "vuln": "Trading will not work on Ethereum if USDT is used", "severity": "MEDIUM", "mitigation": "No need to to approve `USDT` every time. \nThe protocol could:\n1. Keep a record if allowance was already set on an address\n2. Create an external function that can be called by the owner to approve the a token address"}
{"locs": [["code-423n4/2022-12-tigris", "496e1974ee3838be8759e7b4096dbee1b8795593", "contracts/Trading.sol", "L513-L517"]], "vuln": "executeLimitOrder() modifies open-interest with a wrong position value", "severity": "MEDIUM", "mitigation": "Correct the calculation to use margin after fees."}
{"locs": [["OpenZeppelin/openzeppelin-contracts", "3d7a93876a2e5e1d7fe29b5a0e96e222afdc4cfa", "contracts/token/common/ERC2981.sol", "L94>)."]], "vuln": "Escher721 contract does not have setTokenRoyalty function", "severity": "MEDIUM", "mitigation": "In order to expose the internal `_setTokenRoyalty` function to the artist, add the following function to the `Escher721` contract:\n\n```solidity\nfunction setTokenRoyalty(\n    uint256 tokenId,\n    address receiver,\n    uint96 feeNumerato r\n) public onlyRole(DEFAULT_ADMIN_ROLE) {\n    _setTokenRoyalty(tokenId,receiver,feeNumerator);\n}\n```"}
{"locs": [["code-423n4/2022-12-escher", "main", "src/minters/LPDA.sol", "L68)"]], "vuln": "`buy()` in `LPDA.sol` Can be Manipulated by Buyers", "severity": "MEDIUM", "mitigation": "Consider refactoring the affected code line as follows:\n\n    - require(newId <= temp.finalId, \"TOO MANY\");\n    + if(newId > temp.finalId) {\n    +      uint256 diff = newId - temp.finalId; \n    +      newId = temp.finalId;\n    +      amountSold -= diff;\n    +      amount -= diff;\n    + }"}
{"locs": [["code-423n4/2022-12-Stealth-Project", "main", "router-v1/contracts/Router.sol", "L277-L287"]], "vuln": "Router.getOrCreatePoolAndAddLiquidity can be frontrunned which leads to price manipulation", "severity": "MEDIUM", "mitigation": "Do not allow to do such actions together in one tx. Do it in 2 tx. First, create Pool. And in second tx add liquidity."}
{"locs": [["code-423n4/2022-12-Stealth-Project", "fc8589d7d8c1d8488fd97ccc46e1ff11c8426ac2", "maverick-v1/contracts/models/Pool.sol", "L306"]], "vuln": "Trader can manipulate price because bin only moved after swap", "severity": "MEDIUM", "mitigation": "Move the bin at the beginning of a swap after updating twap"}
{"locs": [["code-423n4/2022-12-Stealth-Project", "fc8589d7d8c1d8488fd97ccc46e1ff11c8426ac2", "maverick-v1/contracts/models/Pool.sol", "L549-L551"]], "vuln": "Pool._amountToBin() returns a wrong value when protocolFeeRatio = 100%.", "severity": "MEDIUM", "mitigation": "We should modify `_amountToBin()` like below.\n\n```solidity\n    function _amountToBin(uint256 deltaInErc, uint256 feeBasis) internal view returns (uint256 amount) { \n        if (state.protocolFeeRatio == ONE_3_DECIMAL_SCALE)\n            return deltaInErc - feeBasis;\n\n        amount = state.protocolFeeRatio != 0 ? Math.clip(deltaInErc, feeBasis.mul(uint256(state.protocolFeeRatio) * PROTOCOL_FEE_SCALE) + 1) : deltaInErc;\n    }\n```"}
{"locs": [["code-423n4/2022-12-Stealth-Project", "fc8589d7d8c1d8488fd97ccc46e1ff11c8426ac2", "maverick-v1/contracts/models/Pool.sol", "L294"]], "vuln": "TWA update is not correct", "severity": "MEDIUM", "mitigation": "I recommend changing the relevant line as below without using `clip()` so that the `endSqrtPrice` can contribute to the `twa` reasonably.\n\n```solidity\n294:             twa.updateValue(currentState.activeTick * PRBMathSD59x18.SCALE + int256((delta.endSqrtPrice, delta.sqrtLowerTickPrice).div(delta.sqrtUpperTickPrice - delta.sqrtLowerTickPrice)));\n```"}
{"locs": [["code-423n4/2022-11-paraspace", "main", "paraspace-core/contracts/misc/NFTFloorOracle.sol", "L335"]], "vuln": "Data corruption in NFTFloorOracle; Denial of Service", "severity": "HIGH", "mitigation": "Update index in `feederPositionMap` after feeders swap and pop.\n```\nfeeders[feederIndex] = feeders[feeders.length - 1];\nfeederPositionMap[feeders[feederIndex]].index = feederIndex; //Index update added as a recommendation\nfeeders.pop();\n```"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol", "L176>"]], "vuln": "Attacker can manipulate low TVL Uniswap V3 pool to borrow and swap to make Lending Pool in loss", "severity": "HIGH", "mitigation": "Consider adding whitelist, only allowing pool with enough TVL to be collateral in Paraspace protocol."}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/pool/PoolParameters.sol", "L281>"]], "vuln": "User can pass auction recovery health check easily with flashloan", "severity": "HIGH", "mitigation": "In order to know user has definitely recovered, implement it as a function which holds the user's assets for X time (at least 5 minutes), then releases it back to the user and cancelling all their auctions."}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol", "L245>"]], "vuln": "UniswapV3 tokens of certain pairs will be wrongly valued, leading to liquidations", "severity": "HIGH", "mitigation": "Multiply by 2&ast;&ast;96 before the division operation in sqrtPriceX96 calculation.\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "main", "paraspace-core/contracts/misc/NFTFloorOracle.sol", "L429>"]], "vuln": "Semi-erroneous Median Value", "severity": "MEDIUM", "mitigation": "Consider having line 429 refactored as follows:\n\n            if (validNum % 2 != 0) {\n                return (true, validPriceList[validNum / 2]);\n            }\n            else\n                return (true, (validPriceList[validNum / 2] + validPriceList[(validNum / 2) - 1]) / 2); \n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "main", "paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol", "L320>"]], "vuln": "safeTransfer is not implemented correctly", "severity": "MEDIUM", "mitigation": "Add a call to `onERC721Received` for recipient and see if the recipient actually supports ERC721."}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/tokenization/NTokenMoonBirds.sol", "L63>"]], "vuln": "NTokenMoonBirds Reserve Pool Cannot Receive Airdrops", "severity": "MEDIUM", "mitigation": "Update the contract to allow airdrops to be received by the NTokenMoonBirds Reserve Pool.\n\n```diff\nfunction onERC721Received(\n\taddress operator,\n\taddress from,\n\tuint256 id,\n\tbytes memory\n) external virtual override returns (bytes4) {\n-\t// only accept MoonBird tokens\n-\trequire(msg.sender == _underlyingAsset, Errors.OPERATION_NOT_SUPPORTED);\n\n\t// if the operator is the pool, this means that the pool is transferring the token to this contract\n\t// which can happen during a normal supplyERC721 pool tx\n\tif (operator == address(POOL)) {\n\t\treturn this.onERC721Received.selector;\n\t}\n\n+\tif msg.sender == _underlyingAsset(\n        // supply the received token to the pool and set it as collateral\n        DataTypes.ERC721SupplyParams[]\n            memory tokenData = new DataTypes.ERC721SupplyParams[](1);\n\n        tokenData[0] = DataTypes.ERC721SupplyParams({\n            tokenId: id,\n            useAsCollateral: true\n        });\n+\t)\n\n\tPOOL.supplyERC721FromNToken(_underlyingAsset, tokenData, from);\n\n\treturn this.onERC721Received.selector;\n}\n```"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/libraries/logic/SupplyLogic.sol", "L462-L512>"]], "vuln": "Adversary can force user to pay large gas fees by transfering them collateral", "severity": "MEDIUM", "mitigation": "Don't automatically enable the collateral for the receiver.\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/misc/ParaSpaceOracle.sol", "L114-L136"]], "vuln": "During oracle outages or feeder outages/disagreement, the ParaSpaceFallbackOracle is not used", "severity": "MEDIUM", "mitigation": "Use a try-catch when fetching the normal `latestAnswer()`, and use the fallback if it failed"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/tokenization/NTokenUniswapV3.sol", "L51-L76>"]], "vuln": "Interactions with AMMs do not use deadlines for operations", "severity": "MEDIUM", "mitigation": "Add deadline arguments to all functions that interact with AMMs, and pass it along to AMM calls.\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/libraries/types/DataTypes.sol", "L296>"]], "vuln": "When users sign a credit loan for bidding on an item, they are forever committed to the loan even if the NFT value drops massively", "severity": "MEDIUM", "mitigation": "Add a deadline timestamp to the signed credit structure.\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/libraries/types/DataTypes.sol", "L296"]], "vuln": "Attacker can abuse victim\u2019s signature for marketplace bid to buy worthless item", "severity": "MEDIUM", "mitigation": "Credit structure should contain an additional field \"MarketplaceAddress\""}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol", "L394>"]], "vuln": "Bad debt will likely incur when multiple NFTs are liquidated", "severity": "MEDIUM", "mitigation": "Change the calculation to account for slippage when NFT balance is above some threshold."}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/tokenization/libraries/ApeStakingLogic.sol", "L253"]], "vuln": "Rewards are not accounted for properly in NTokenApeStaking contracts, limiting user\u2019s collateral", "severity": "MEDIUM", "mitigation": "Balance calculation should include pendingRewards from BAKC tokens if they exist."}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/misc/NFTFloorOracle.sol", "L365>"]], "vuln": "Oracle does not treat upward and downward price movement the same in validity checks, causing safety issues in oracle usage", "severity": "MEDIUM", "mitigation": "Use a percentage base calculation for both upward and downward price movements."}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/misc/NFTFloorOracle.sol", "L236>"]], "vuln": "Pausing assets only affects future price updates, not previous malicious updates", "severity": "MEDIUM", "mitigation": "Add whenNotPaused to getPrice() function as well.\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/misc/NFTFloorOracle.sol", "L370>"]], "vuln": "Price can deviate by much more than maxDeviationRate", "severity": "MEDIUM", "mitigation": "Code already has lastUpdated timestamp for each oracle. Use the elapsed time to calculate a reasonable maximum price change per oracle.\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/misc/NFTFloorOracle.sol", "L12>"]], "vuln": "Oracle will become invalid much faster than intended on non-mainnet chains", "severity": "MEDIUM", "mitigation": "Use block.timestamp to measure passage of time.\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/tokenization/base/MintableIncentivizedERC721.sol", "L572>"]], "vuln": "MintableIncentivizedERC721 and NToken do not comply with ERC721, breaking composability", "severity": "MEDIUM", "mitigation": "Change supportedInterface function:\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        external\n        view\n        virtual\n        override(IERC165)\n        returns (bool)\n    {\n        return\n            interfaceId == type(IERC721Enumerable).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId || ;\n    \t\tinterfaceId == type(IERC721).interfaceId || \n    }\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/libraries/types/DataTypes.sol", "L296>"]], "vuln": "Attacker can abuse victim's signature for marketplace bid to buy worthless item", "severity": "MEDIUM", "mitigation": "Credit structure should contain an additional field \"MarketplaceAddress\".\n\n***"}
{"locs": [["code-423n4/2022-11-paraspace", "c6820a279c64a299a783955749fdc977de8f0449", "paraspace-core/contracts/protocol/tokenization/libraries/ApeStakingLogic.sol", "L253>"]], "vuln": "Rewards are not accounted for properly in NTokenApeStaking contracts, limiting user's collateral", "severity": "MEDIUM", "mitigation": "Balance calculation should include pendingRewards from BAKC tokens if they exist.\n\n***"}
{"locs": [["code-423n4/2022-11-redactedcartel", "main", "src/PirexGmx.sol", "L921-L935>"]], "vuln": "`PirexGmx.initiateMigration` can be blocked", "severity": "MEDIUM", "mitigation": "Think about how to make contract ensure that he doesn't control any gmxVester and glpVester tokens before migration."}
{"locs": [["code-423n4/2022-11-redactedcartel", "03b71a8d395c02324cb9fdaf92401357da5b19d1", "src/vaults/AutoPxGmx.sol", "L242-L278>"]], "vuln": "Anyone can call AutoPxGmx.compound and perform sandwich attacks with control parameters", "severity": "MEDIUM", "mitigation": "Consider using poolFee as the fee and using an onchain price oracle to calculate the amountOutMinimum."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantMevAndFeesPool.sol", "L170-L173"]], "vuln": "Sender transferring GiantMevAndFeesPool tokens can afterward experience pool DOS and orphaning of future rewards", "severity": "HIGH", "mitigation": "Reduce claimed[] when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[]."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantPoolBase.sol", "L52-L64"]], "vuln": "Reentrancy vulnerability in GiantMevAndFeesPool.withdrawETH", "severity": "HIGH", "mitigation": "Change to\n```diff\nfunction withdrawETH(uint256 _amount) external nonReentrant {\n    require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n    require(lpTokenETH.balanceOf(msg.sender) >= _amount, \"Invalid balance\");\n    require(idleETH >= _amount, \"Come back later or withdraw less ETH\");\n\n-  idleETH -= _amount;\n\n    lpTokenETH.burn(msg.sender, _amount);\n+  idleETH -= _amount;\n\n    (bool success,) = msg.sender.call{value: _amount}(\"\");\n    require(success, \"Failed to transfer ETH\");\n\n    emit LPBurnedForETH(msg.sender, _amount);\n}\n```"}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantMevAndFeesPool.sol", "L126"]], "vuln": "bringUnusedETHBackIntoGiantPool in GiantMevAndFeesPool can be used to steal LPTokens", "severity": "HIGH", "mitigation": "Always passing liquid staking manager address, checking its real and then requesting either the savETH vault or staking funds vault is a good idea to prove the validity of vaults."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantSavETHVaultPool.sol", "L66"]], "vuln": "dETH / ETH / LPTokenETH can become depegged due to ETH 2.0 reward slashing", "severity": "MEDIUM", "mitigation": "We recommand the protocol to add mechanism to ensure the dETH is pegged via burning if case the ETH got slashed.\n\nand consider when the node do not maintain a minmum 32 ETH staking balance, who is charge of adding the ETH balance to increase\n\nthe staking balance or withdraw the ETH and distribute the fund."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/LiquidStakingManager.sol", "L435"]], "vuln": "Address.isContract() is not a reliable way of checking if the input is an EOA", "severity": "MEDIUM", "mitigation": "It is generally not recommended to enforce an address to be only EOA and AFAIK, this is impossible to enforce due to the aforementioned cases. I recommend the protocol team to take a closer look at this and build the protocol with the assumption that `_eoaRepresentative == EOA`."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/LiquidStakingManager.sol", "L948-L955"]], "vuln": "Node runners can lose all their stake rewards due to how the DAO commissions can be set to a 100%", "severity": "MEDIUM", "mitigation": "There should be maximum cap on how much commission DAO can take from node runners."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/StakingFundsVault.sol", "L218"]], "vuln": "Funds are not claimed from syndicate for valid BLS keys of first key is invalid (no longer part of syndicate).", "severity": "MEDIUM", "mitigation": "Drop the i==0 requirement, which was intended to make sure the claim isn't called multiple times. Use a hasClaimed boolean instead."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/StakingFundsVault.sol", "L224"]], "vuln": "User receives less rewards than they are eligible for if first passed BLS key is inactive", "severity": "MEDIUM", "mitigation": "Call updateAccumulatedETHPerLP() at the start of the function."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantMevAndFeesPool.sol", "L105"]], "vuln": "Giant pools are prone to user griefing, preventing their holdings from being staked", "severity": "MEDIUM", "mitigation": "Three options:\n1. batchRotateLPTokens should have logic to enforce that this specific rotation is logical\n2. only DAO or some priviledged user can perform Giant pool operations\n3. Make the caller have something to lose from behaving maliciously, unlike the current status."}
{"locs": [["code-423n4/2022-11-non-fungible", "323b7cbf607425dd81da96c0777c8b12e800305d", "contracts/Exchange.sol", "L378"]], "vuln": "All orders which use expirationTime == 0 to support oracle cancellation are not executable", "severity": "MEDIUM", "mitigation": "Implement the checks the same way as they were in the previous version of Exchange."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantPoolBase.sol", "L53"]], "vuln": "GiantPool should not check ETH amount on withdrawal", "severity": "MEDIUM", "mitigation": "The `require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");` statement should just be removed. It does not serve any purpose anyway."}
{"locs": [["code-423n4/2022-11-stakehouse", "main", "contracts/liquid-staking/LiquidStakingManager.sol", "L356-L377"]], "vuln": "DAO or lsdn owner can steal funds from node runner", "severity": "MEDIUM", "mitigation": "Send back outstanding ETH and rewards that belongs to node runner if swapping is needed."}
{"locs": [["code-423n4/2022-11-stakehouse", "a0558ed7b12e1ace1fe5c07970c7fc07eb00eebd", "contracts/liquid-staking/LiquidStakingManager.sol", "L469"]], "vuln": "Banned BLS public keys can still be registered", "severity": "MEDIUM", "mitigation": "Use `isBLSPublicKeyBanned` instead of `isBLSPublicKeyPartOfLSDNetwork`."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantMevAndFeesPool.sol", "L146-L148"]], "vuln": "When users transfer GiantLP, some rewards may be lost", "severity": "MEDIUM", "mitigation": "Consider claiming the latest rewards from StakingFundsVault before the GiantMevAndFeesPool.beforeTokenTransfer calls updateAccumulatedETHPerLP()"}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantPoolBase.sol", "L93-L97"]], "vuln": "Incorrect checking in _assertUserHasEnoughGiantLPToClaimVaultLP", "severity": "MEDIUM", "mitigation": "The LPToken being operated on should be checked for lastInteractedTimestamp rather than lpTokenETH.\n\n```\ndiff --git a/contracts/liquid-staking/GiantPoolBase.sol b/contracts/liquid-staking/GiantPoolBase.sol\nindex 8a8ff70..5c009d9 100644\n--- a/contracts/liquid-staking/GiantPoolBase.sol\n+++ b/contracts/liquid-staking/GiantPoolBase.sol\n@@ -93,7 +93,7 @@ contract GiantPoolBase is ReentrancyGuard {\n     function _assertUserHasEnoughGiantLPToClaimVaultLP(LPToken _token, uint256 _amount) internal view {\n         require(_amount >= MIN_STAKING_AMOUNT, \"Invalid amount\");\n         require(_token.balanceOf(address(this)) >= _amount, \"Pool does not own specified LP\");\n-        require(lpTokenETH.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n+        require(_token.lastInteractedTimestamp(msg.sender) + 1 days < block.timestamp, \"Too new\");\n     }\n\n     /// @dev Allow an inheriting contract to have a hook for performing operations post depositing ETH\n```"}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/ETHPoolLPFactory.sol", "L111"]], "vuln": "Vaults can be griefed to not be able to be used for deposits", "severity": "MEDIUM", "mitigation": "Handle the case where the remaining amount to be completed is smaller than MIN_STAKING_AMOUNT, and allow the deposit in that case."}
{"locs": [["code-423n4/2022-11-stakehouse", "4b6828e9c807f2f7c569e6d721ca1289f7cf7112", "contracts/liquid-staking/GiantSavETHVaultPool.sol", "L62-L102"]], "vuln": "Possible reentrancy and fund theft in withdrawDETH() of GiantSavETHVaultPool because there is no whitelist check for user provided Vaults and there is no reentrancy defense", "severity": "HIGH", "mitigation": "check the provided addresses and also have some reentrancy defence mechanisim."}
{"locs": [["code-423n4/2022-09-vtvl", "main", "contracts/token/VariableSupplyERC20Token.sol", "L36-L46"]], "vuln": "Yul call return value not checked", "severity": "MEDIUM", "mitigation": "Treat `2 ** 256 - 1` as infinity instead of `0`."}
{"locs": [["code-423n4/2022-11-non-fungible", "323b7cbf607425dd81da96c0777c8b12e800305d", "contracts/Pool.sol", "L13"]], "vuln": "Pool designed to be upgradeable but does not set owner, making it un-upgradeable", "severity": "MEDIUM", "mitigation": "Implement an initializer for Pool similarly to the Exchange.sol contract."}
{"locs": [["code-423n4/2022-11-non-fungible", "323b7cbf607425dd81da96c0777c8b12e800305d", "contracts/Exchange.sol", "L212-L227"]], "vuln": "Yul call return value not checked", "severity": "MEDIUM", "mitigation": "```diff\n+    error ReturnDustFail();\n+\n     function _returnDust() private {\n         uint256 _remainingETH = remainingETH;\n+        bool success;\n         assembly {\n             if gt(_remainingETH, 0) {\n-                let callStatus := call(\n+                success := call(\n                     gas(),\n                     caller(),\n                     selfbalance(),\n                     0,\n                     0,\n                     0,\n                     0\n                 )\n             }\n         }\n+        if (!success) revert ReturnDustFail();\n     }\n```"}
{"locs": [["code-423n4/2022-11-non-fungible", "323b7cbf607425dd81da96c0777c8b12e800305d", "contracts/Exchange.sol", "L212-L227)<br>"]], "vuln": "Yul `call` return value not checked", "severity": "MEDIUM", "mitigation": "```diff\n+    error ReturnDustFail();\n+\nfunction _returnDust() private {\nuint256 _remainingETH = remainingETH;\n+        bool success;\nassembly {\nif gt(_remainingETH, 0) {\n-                let callStatus := call(\n+                success := call(\ngas(),\ncaller(),\nselfbalance(),\n0,\n0,\n0,\n0\n)\n}\n}\n+        if (!success) revert ReturnDustFail();\n}\n```"}
{"locs": [["code-423n4/2022-11-non-fungible", "323b7cbf607425dd81da96c0777c8b12e800305d", "contracts/Exchange.sol", "L378)<br>"]], "vuln": "All orders which use `expirationTime == 0` to support oracle cancellation are not executable", "severity": "MEDIUM", "mitigation": "Implement the checks the same way as they were in the previous version of Exchange."}
{"locs": [["code-423n4/2022-11-looksrare", "e3b2c053f722b0ca2dce3a3eb06f64859b8b7a6f", "contracts/proxies/SeaportProxy.sol", "L136-L147>"]], "vuln": "Too much fee charged when Seaport is partially filled", "severity": "MEDIUM", "mitigation": "Consider charging fees based on the user's actual filled price."}
{"locs": [["code-423n4/2022-11-size", "706a77e585d0852eae6ba0dca73dc73eb37f8fb6", "src/SizeSealed.sol", "L140-L142) in the `bid()` function where the bidder cannot submit a bid with the same address as the one used while creating the auction it is trivial to use another address to submit bids."]], "vuln": "Seller's ability to decrypt bids before reveal could result in a much higher clearing price than anticpated and make buyers distrust the system", "severity": "MEDIUM", "mitigation": "A possible mitigation would be to introduce a 2 step reveal where the bidders also encrypt their bid with their own private key and only reveal their key after the seller has revealed theirs.\nThis would however create another attack vector where bidders try and game the auction and only reveal their bid(s) when and if the result would be in their best interest.\nThis in turn could be mitigated by bidders losing (part of) their quote tokens when not revealing their bids."}
{"locs": [["debtdao/Line-of-Credit", "f32cb3eeb08663f2456bf6e2fba21e964da3e8ae", "contracts/utils/SpigotLib.sol", "L87"]], "vuln": "Non-existing revenue contract can be passed to claimRevenue to send all tokens to treasury", "severity": "HIGH", "mitigation": "Check that a revenue contract was registered before, revert if it does not."}
{"locs": [["debtdao/Line-of-Credit", "e8aa08b44f6132a5ed901f8daa231700c5afeb3a", "contracts/modules/credit/LineOfCredit.sol", "L389"]], "vuln": "Borrower can close a credit without repaying debt", "severity": "HIGH", "mitigation": "In the `close` function of `LineOfCredit`, consider ensuring that a credit with the user-supplied ID exists, before closing it."}
{"locs": [["debtdao/Line-of-Credit", "e8aa08b44f6132a5ed901f8daa231700c5afeb3a", "contracts/modules/credit/LineOfCredit.sol", "L516-L538"]], "vuln": "Borrower can craft a borrow that cannot be liquidated, even by arbiter. ", "severity": "HIGH", "mitigation": "When sorting new borrows into the ids queue, do not skip any elements."}
{"locs": [["debtdao/Line-of-Credit", "e8aa08b44f6132a5ed901f8daa231700c5afeb3a", "contracts/modules/credit/LineOfCredit.sol", "L487"]], "vuln": "Reentrancy bug allows lender to steal other lenders funds", "severity": "MEDIUM", "mitigation": "Send tokens only at the end of `_close(Credit memory credit, bytes32 id)` or add a reentrancyGuard."}
{"locs": [["debtdao/Line-of-Credit", "e8aa08b44f6132a5ed901f8daa231700c5afeb3a", "contracts/utils/LineLib.sol", "L59-L74"]], "vuln": "Mistakenly sent eth could be locked", "severity": "MEDIUM", "mitigation": "In the ERC20 part, add check for `msg.value` to ensure no eth is sent:\n```solidity\n        if(token != Denominations.ETH) { // ERC20\n            if (msg.value > 0) { revert TransferFailed(); }\n            IERC20(token).safeTransferFrom(sender, address(this), amount);\n        } else { // ETH\n```"}
{"locs": [["code-423n4/2022-10-zksync", "456078b53a6d09636b84522ac8f3e8049e4e3af5", "ethereum/contracts/zksync/Config.sol", "L47)<br>"]], "vuln": "`BLOCK_PERIOD` is incorrect", "severity": "MEDIUM", "mitigation": "Change the block period to be 12 seconds\n\n```sol\nuint256 constant BLOCK_PERIOD = 12 seconds;\n```"}
{"locs": [["code-423n4/2022-10-inverse", "cc281e5800d5860c816138980f08b84225e430fe", "src/Market.sol", "L464"]], "vuln": "ERC777 reentrancy when withdrawing can be used to withdraw all collateral", "severity": "MEDIUM", "mitigation": "Mark these functions as `nonReentrant`."}
{"locs": [["code-423n4/2022-10-inverse", "main", "src/Oracle.sol", "L124"]], "vuln": "Oracle\u2019s two-day feature can be gamed", "severity": "MEDIUM", "mitigation": "If you increase it to a three-day interval you can fix this issue. Then, the oracle has to be manipulated for at least 24 hours."}
{"locs": [["code-423n4/2022-10-inverse", "main", "src/DBR.sol", "L287"]], "vuln": "Users can avoid paying fees if they manage to update their accrued fees periodically", "severity": "MEDIUM", "mitigation": "* Document the risks transparently and prominently.\n* Re-evaluate the risks according to the specific network parameters of every network you want to deploy to.\n* Do not update the `lastUpdated` timestamp of the user if the computed accrued amount was zero."}
{"locs": [["code-423n4/2022-10-inverse", "main", "src/Market.sol", "L567"]], "vuln": "User can borrow DOLA indefinitely without settling DBR deficit by keeping their debt close to the allowed maximum", "severity": "MEDIUM", "mitigation": "Allow replenishing to push the debt under the water and disallow repaying the debt with an outstanding DBR deficit. E.g.:\n```\ndiff --git a/src/Market.sol b/src/Market.sol\nindex 9585b85..d69b599 100644\n--- a/src/Market.sol\n+++ b/src/Market.sol\n@@ -531,6 +531,7 @@ contract Market {\n     function repay(address user, uint amount) public {\n         uint debt = debts[user];\n         require(debt >= amount, \"Insufficient debt\");\n+        require(dbr.deficitOf(user) == 0, \"DBR Deficit\");\n         debts[user] -= amount;\n         totalDebt -= amount;\n         dbr.onRepay(user, amount);\n@@ -563,8 +564,6 @@ contract Market {\n         uint replenishmentCost = amount * dbr.replenishmentPriceBps() / 10000;\n         uint replenisherReward = replenishmentCost * replenishmentIncentiveBps / 10000;\n         debts[user] += replenishmentCost;\n-        uint collateralValue = getCollateralValueInternal(user);\n-        require(collateralValue >= debts[user], \"Exceeded collateral value\");\n         totalDebt += replenishmentCost;\n         dbr.onForceReplenish(user, amount);\n         dola.transfer(msg.sender, replenisherReward);\n```"}
{"locs": [["code-423n4/2022-10-inverse", "main", "src/Market.sol", "L605-L610"]], "vuln": "User can free from liquidation fee if its escrow balance is less than the calculated liquidation fee", "severity": "MEDIUM", "mitigation": "User should pay all the remaining escrow balance if the calculated liquidation fee is greater than its escrow balance.\n\n```solidity\n        if(liquidationFeeBps > 0) {\n            uint liquidationFee = repaidDebt * 1 ether / price * liquidationFeeBps / 10000;\n            if(escrow.balance() >= liquidationFee) {\n                escrow.pay(gov, liquidationFee);\n            } else {\n                escrow.pay(gov, escrow.balance());\n            }\n        }\n```"}
{"locs": [["code-423n4/2022-10-inverse", "main", "src/Market.sol", "L281-L283"]], "vuln": "Avoidable misconfiguration could lead to INVEscrow contract not minting xINV tokens", "severity": "MEDIUM", "mitigation": "Either make **callOnDepositCallback** a configurable parameter in Market.sol or always call the **onDeposit** callback (just get rid of the **callOnDepositCallback** variable) and leave it empty in case there's no extra functionality that needs to be executed for that escrow. In the case that the same escrow has to execute the callback for some markets and not for others, this solution would imply that there should be two escrows, one with the callback to be executed and another with the callback empty."}
{"locs": [["code-423n4/2022-10-inverse", "3e81f0f5908ea99b36e6ab72f13488bbfe622183", "src/Oracle.sol", "L91"]], "vuln": "viewPrice doesn\u2019t always report dampened price", "severity": "MEDIUM", "mitigation": "Consider this change:\n```diff\n--- a/src/Oracle.sol\n+++ b/src/Oracle.sol\n@@ -89,6 +89,9 @@ contract Oracle {\n             uint day = block.timestamp / 1 days;\n             // get today's low\n             uint todaysLow = dailyLows[token][day];\n+            if(todaysLow == 0 || normalizedPrice < todaysLow) {\n+                todaysLow = normalizedPrice;\n+            }\n             // get yesterday's low\n             uint yesterdaysLow = dailyLows[token][day - 1];\n             // calculate new borrowing power based on collateral factor\n```"}
{"locs": [["code-423n4/2022-10-inverse", "main", "src/Market.sol", "L566"]], "vuln": " Users could get some DOLA even if they are on liquidation position", "severity": "MEDIUM", "mitigation": "Use `getCreditLimitInternal()` rather than `getCollateralValueInternal()`."}
{"locs": [["code-423n4/2022-10-inverse", "main", "src/Market.sol", "L562"]], "vuln": "Market::forceReplenish can be DoSed", "severity": "MEDIUM", "mitigation": "Use `min(deficit,amount)` as amount to replenish"}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/HolographOperator.sol", "L415)<br>"]], "vuln": "An attacker can lock operator out of the pod by setting gas limit that's higher than the block gas limit of dest chain", "severity": "HIGH", "mitigation": "Limit the `gasLimit` to the maximum realistic amount that can be used on the dest chain (including the gas used up to the point where it's checked)."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/HolographOperator.sol", "L354)<br>"]], "vuln": "MEV: Operator can bribe miner and steal honest operator's bond amount if gas price went high", "severity": "HIGH", "mitigation": "Do not use current tx.gasprice amount to infer gas price in a previous block.<br>\nProbably best to use gas price oracle."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/HolographOperator.sol", "L354)<br>"]], "vuln": "Gas price spikes cause the selected operator to be vulnerable to frontrunning and be slashed", "severity": "HIGH", "mitigation": "Modify your operator node software to queue transactions immediately with `gasPrice in bridgeInRequestPayload` if a gas price spike happened. Or allow gas fee loss tradeoff to prevent being slashed."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/enforcer/HolographERC721.sol", "L467)<br>"]], "vuln": "Incorrect implementation of ERC721 may have bad consequences for receiver", "severity": "MEDIUM", "mitigation": "Pass the msg.sender parameter, as the ERC721 standard requires."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/HolographOperator.sol", "L491-L511)<br>"]], "vuln": "Bad source of randomness", "severity": "MEDIUM", "mitigation": "Consider using a decentralized oracle for the generation of random numbers, such as [Chainlinks VRF](https://docs.chain.link/docs/vrf/v2/introduction/).\n\nIt should be noted, that in this case there is a prerequirement of the layer-zero endpoint being compromised, which confines the risk quite a bit, so using a normally unrecommended source of randomness could be acceptable here, considering the tradeoffs of integrating a decentralized oracle."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/HolographOperator.sol", "L875)<br>"]], "vuln": " Attacker can force chaotic operator behavior", "severity": "MEDIUM", "mitigation": "It is important to pay special attention to the scheduling algorithm, to make sure different pods are given execution time according to the desired heuristics."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/enforcer/HolographERC20.sol", "L539)<br>"]], "vuln": "`HolographERC20` breaks composability by forcing usage of draft proposal EIP-4524", "severity": "MEDIUM", "mitigation": "Remove the EIP-4524 requirements altogether."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/HolographFactory.sol", "L234-L246)). A source contract, however, has excessive privileges in the Holographed ERC721. Specifically, it can burn and transfer users' NFTs without their approval ([HolographERC721.sol#L500](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L500), [HolographERC721.sol#L577](https://github.com/code-423n4/2022-10-holograph/blob/f8c2eae866280a1acfdc8a8352401ed031be1373/contracts/enforcer/HolographERC721.sol#L577)):"]], "vuln": "Source contract can steal NFTs from users", "severity": "MEDIUM", "mitigation": "Consider removing the `sourceBurn` and `sourceTransfer` functions of `HolographERC721` and requiring user approval to transfer or burn their tokens (`burn` and `safeTransferFrom` can be called by a source contract instead of `sourceBurn` and `sourceTransfer`)."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/enforcer/PA1D.sol", "L665-L675)<br>"]], "vuln": "PA1D#bidSharesForToken returns incorrect `bidShares.creator.value`", "severity": "MEDIUM", "mitigation": "To return the proper value, basis points returned need to be adjusted. Convert from basis points to percentage by dividing by 10 &ast;&ast; 2 (100) then scale to 18 decimals. The final result it to multiple the basis point by 10 &ast;&ast; (18 - 2) or 10 &ast;&ast; 16:\n\n    function bidSharesForToken(uint256 tokenId) public view returns (ZoraBidShares memory bidShares) {\n        // this information is outside of the scope of our\n        bidShares.prevOwner.value = 0;\n        bidShares.owner.value = 0;\n        if (_getReceiver(tokenId) == address(0)) {\n    -       bidShares.creator.value = _getDefaultBp();\n    +       bidShares.creator.value = _getDefaultBp() * (10 ** 16);\n        } else {\n    -       bidShares.creator.value = _getBp(tokenId);\n    +       bidShares.creator.value = _getBp(tokenId) * (10 ** 16);\n        }\n        return bidShares;\n    }"}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "src/enforcer/HolographERC721.sol", "L392)<br>"]], "vuln": "`ApprovalAll` event is missing parameters", "severity": "MEDIUM", "mitigation": "Add parameter: owner\n\n    interface HolographedERC721 {\n    ...\n\n    - function beforeApprovalAll(address _to, bool _approved) external returns (bool success);\n    + function beforeApprovalAll(address owner, address _to, bool _approved) external returns (bool success);\n\n    - function afterApprovalAll(address _to, bool _approved) external returns (bool success);\n    + function afterApprovalAll(address owner, address _to, bool _approved) external returns (bool success);\n\n<!---->\n\n      function setApprovalForAll(address to, bool approved) external {\n\n        if (_isEventRegistered(HolographERC721Event.beforeApprovalAll)) {\n    -     require(SourceERC721().beforeApprovalAll(to, approved)); \n    +     require(SourceERC721().beforeApprovalAll(msg.sender,to, approved)); \n        }  \n\n        _operatorApprovals[msg.sender][to] = approved;\n\n        if (_isEventRegistered(HolographERC721Event.afterApprovalAll)) {\n    -      require(SourceERC721().afterApprovalAll(to, approved));\n    +      require(SourceERC721().afterApprovalAll(msg.sender,to, approved));\n        }\n      }"}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/HolographOperator.sol", "L374-L382)"]], "vuln": "Wrong slashing calculation rewards for operator that did not do his job", "severity": "MEDIUM", "mitigation": "Implement the correct percentage of slashing and include a mapping to note down the number of slashes that an operator has."}
{"locs": [["code-423n4/2022-10-holograph", "f8c2eae866280a1acfdc8a8352401ed031be1373", "contracts/enforcer/HolographERC721.sol", "L962)<br>"]], "vuln": "Leak of value when interacting with an ERC721 enforcer contract", "severity": "MEDIUM", "mitigation": "Funnel receive() empty calls down to the implementation."}
{"locs": [["code-423n4/2022-10-holograph", "24bc4d8dfeb6e4328d2c6291d20553b1d3eff00b", "src/enforcer/HolographERC721.sol", "L272)<br>"]], "vuln": "`HolographERC721.approve` not EIP-721 compliant", "severity": "MEDIUM", "mitigation": "Follow the EIP, i.e. do not allow approved addresses to approve other addresses."}
{"locs": [["jbx-protocol/juice-nft-rewards", "f9893b1497098241dd3a664956d8016ff0d0efd0", "contracts/JBTiered721Delegate.sol", "L524-L590)"]], "vuln": "Making a payment to the protocol with `_dontMint` parameter will result in lost fund for user.", "severity": "HIGH", "mitigation": "Update the `creditsOf[]` in the `if(_dontMint)` check.\n\n```diff\n- if(_dontMint) return;\n+ if(_dontMint){ creditsOf[_data.beneficiary] += _value; }\n```"}
{"locs": [["jbx-protocol/juice-nft-rewards", "f9893b1497098241dd3a664956d8016ff0d0efd0", "contracts/JBTiered721Delegate.sol", "L221) and increase `creditsOf` of anyone [JBTiered721Delegate.sol:587](https://github.com/jbx-protocol/juice-nft-rewards/blob/f9893b1497098241dd3a664956d8016ff0d0efd0/contracts/JBTiered721Delegate.sol#L587) without touching any `store` call."]], "vuln": "Multiples initializations of `JBTiered721Delegate`", "severity": "MEDIUM", "mitigation": "Ensure that the `store` address is not empty."}
{"locs": [["code-423n4/2022-10-traderjoe", "e81b78ddb7cc17f0ece921fbaef2c2521727094b", "src/LBRouter.sol", "L291"]], "vuln": "LBRouter.removeLiquidity returning wrong values", "severity": "MEDIUM", "mitigation": "Add the following statement in the end:\n```solidity\nif (_tokenX != _LBPair.tokenX()) {\n\treturn (amountY, amountX);\n}\n```"}
{"locs": [["code-423n4/2022-10-traderjoe", "37258d595d596c195507234f795fa34e319b0a68", "src/LBToken.sol", "L237"]], "vuln": "beforeTokenTransfer called with wrong parameters in LBToken._burn", "severity": "MEDIUM", "mitigation": "Call the hook correctly:\n```solidity\n_beforeTokenTransfer(_account, address(0), _id, _amount);\n```"}
{"locs": [["code-423n4/2022-10-traderjoe", "79f25d48b907f9d0379dd803fc2abc9c5f57db93", "src/libraries/FeeHelper.sol", "L58-L72)<br>"]], "vuln": "Attacker can keep fees max at no cost", "severity": "MEDIUM", "mitigation": "Several options:\n\n1. Decay linearly to the time since last swap when T < Tf.\n\n2. Don't update \\_tf.time if swap did not affect Vr\n\n3. If `T<Tf`, only skip Vr update if swap amount is not negligible. This will make the attack not worth it, as protocol will accrue enough fees to offset the lack of user activity.\n\n#"}
{"locs": [["code-423n4/2022-10-thegraph", "309a188f7215fa42c745b136357702400f91b4ff", "contracts/gateway/L1GraphTokenGateway.sol", "L236"]], "vuln": "If L1GraphTokenGateway\u2019s outboundTransfer is called by a contract, the entire msg.value is blackholed, whether the ticket got redeemed or not", "severity": "MEDIUM", "mitigation": "A possible fix is to add an `isContract` flag. If sender is a contract, require the flag to be true.\n\nAnother option is to add a `refundAddr` address parameter to the API."}
{"locs": [["code-423n4/2022-10-thegraph", "309a188f7215fa42c745b136357702400f91b4ff", "contracts/l2/gateway/L2GraphTokenGateway.sol", "L70"]], "vuln": "After proposed 0.8.0 upgrade kicks in, L2 finalizeInboundTransfer might not work", "severity": "MEDIUM", "mitigation": "Wrap the calculation in an unchecked block, which will make it behave correctly."}
{"locs": [["code-423n4/2022-09-vtvl", "f68b7f3e61dad0d873b5b5a1e8126b839afeab5f", "contracts/VTVLVesting.sol", "L176"]], "vuln": "Permanent freeze of vested tokens due to overflow in _baseVestedAmount", "severity": "HIGH", "mitigation": "Perform the intermediate calculation of linearVestAmount using the uint256 type.\n```\nuint112 linearVestAmount = uint112( uint256(_claim.linearVestAmount) * truncatedCurrentVestingDurationSecs / finalVestingDurationSecs);\n```"}
{"locs": [["code-423n4/2022-09-vtvl", "main", "contracts/token/VariableSupplyERC20Token.sol", "L36-L46"]], "vuln": "Supply cap of VariableSupplyERC20Token is not properly enforced", "severity": "MEDIUM", "mitigation": "Treat `2 ** 256 - 1` as infinity instead of `0`."}
{"locs": [["code-423n4/2022-09-vtvl", "f68b7f3e61dad0d873b5b5a1e8126b839afeab5f", "contracts/VTVLVesting.sol", "L245-L304"]], "vuln": "Vesting Schedule Start and End Time can be Set in the Past ", "severity": "MEDIUM", "mitigation": "Add following check in `VTVLVesting.sol:_createClaimUnchecked` function.\n```\nrequire(_startTimestamp > uint40(block.timestamp), \"INVALID_START_TIMESTAMP\")\n```"}
{"locs": [["code-423n4/2022-09-vtvl", "f68b7f3e61dad0d873b5b5a1e8126b839afeab5f", "contracts/VTVLVesting.sol", "L446-L451"]], "vuln": "Two address tokens can be withdrawn by the admin even if they are vested", "severity": "MEDIUM", "mitigation": "Replace the address check with a balance check - record the vesting token balance of the contract before and after the transfer and assert that they are equal."}
{"locs": [["code-423n4/2022-09-vtvl", "f68b7f3e61dad0d873b5b5a1e8126b839afeab5f", "contracts/VTVLVesting.sol", "L245-L304"]], "vuln": "_releaseIntervalSecs is not validated", "severity": "MEDIUM", "mitigation": "The `_releaseIntervalSecs` should be validated comparing to user's  `_linearVestAmount` and `_startTimestamp` `_endTimestamp`."}
{"locs": [["code-423n4/2022-09-vtvl", "main", "contracts/VTVLVesting.sol", "L394-L411"]], "vuln": "Reentrancy may allow an admin to steal funds", "severity": "MEDIUM", "mitigation": "Add `ReentrancyGuard`'s `nonReentrant` to the `withdrawAdmin` function."}
{"locs": [["code-423n4/2022-09-artgobblers", "d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe", "src/ArtGobblers.sol", "L560-L567)<br>"]], "vuln": "Possible centralization issue around RandProvider", "severity": "MEDIUM", "mitigation": "The inclusion of a voting and governance mechanism should be considered for protocol critical functions. This could for example take the form of each Gobbler representing 1 vote, with legendary Gobblers having more weight (literally) based on the amount of consumed Gobblers."}
{"locs": [["code-423n4/2022-09-artgobblers", "d2087c5a8a6a4f1b9784520e7fe75afa3a9cbdbe", "src/ArtGobblers.sol", "L458)<br>"]], "vuln": "Wrong `balanceOf` user after minting legendary gobbler", "severity": "MEDIUM", "mitigation": "Consider remove adding 1 when calculating `gobblersOwned`\n\n```solidity\ngetUserData[msg.sender].gobblersOwned = uint32(getUserData[msg.sender].gobblersOwned - cost);\n```"}
{"locs": [["code-423n4/2022-09-y2k-finance", "2175c044af98509261e4147edeb48e1036773771", "src/oracles/PegOracle.sol", "L78)( and then re-multiplied by `uint256 decimals = 10**(18-(priceFeed.decimals()));` ([Controller.sol#L299-L300](https://github.com/code-423n4/2022-09-y2k-finance/blob/2175c044af98509261e4147edeb48e1036773771/src/Controller.sol#L299-L300))  it leads to loss of precision. This behavior will make the relative price between the assets incorrect."]], "vuln": "LOSS OF PRECISION RESULTING IN WRONG VALUE FOR PRICE RATIO", "severity": "HIGH", "mitigation": "Since the 2 assets are required to having the same amount of decimals a formula that transforms the relative price to 1e18 could be:\n`x * 1e18 / y` .\n\nAn example that Chainlink implements, that includes a `scalePrice` function, in order to find a different price denominator could be found [here](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination)."}
{"locs": [["code-423n4/2022-09-y2k-finance", "ac3e86f07bc2f1f51148d2265cc897e8b494adf7", "src/rewards/StakingRewards.sol", "L213-L223>"]], "vuln": "StakingRewards: recoverERC20() can be used as a backdoor by the owner to retrieve rewardsToken", "severity": "MEDIUM", "mitigation": "Add an additional check\n\n            require(\n                tokenAddress != address(rewardsToken),\n                \"Cannot withdraw the rewards token\"\n            );"}
{"locs": [["code-423n4/2022-09-y2k-finance", "ac3e86f07bc2f1f51148d2265cc897e8b494adf7", "src/rewards/StakingRewards.sol", "L201-L205>"]], "vuln": "StakingRewards.sol#notifyRewardAmount() Improper reward balance checks can make some users unable to withdraw their rewards", "severity": "MEDIUM", "mitigation": "Consider changing the function notifyRewardAmount to addRward and use transferFrom to transfer rewardsToken into the contract:\n\n    function addRward(uint256 reward)\n        external\n        updateReward(address(0))\n    {\n        require(\n            msg.sender == rewardsDistribution,\n            \"Caller is not RewardsDistribution contract\"\n        );\n\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward / rewardsDuration;\n        } else {\n            uint256 remaining = periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / rewardsDuration;\n        }\n\n        rewardsToken.safeTransferFrom(msg.sender, address(this), reward);\n\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp + rewardsDuration;\n        emit RewardAdded(reward);\n    }"}
{"locs": [["code-423n4/2022-09-y2k-finance", "ac3e86f07bc2f1f51148d2265cc897e8b494adf7", "src/rewards/StakingRewards.sol", "L183-L195>"]], "vuln": "StakingRewards reward rate can be dragged out and diluted", "severity": "MEDIUM", "mitigation": "The rewardRate should never decrease by a notifyRewardAmount call.\nConsider not extending the reward payouts by rewardsDuration on every call.\nperiodFinish probably shouldn't change at all, the rewardRate should just increase by rewardRate += reward / (periodFinish - block.timestamp).\n\nAlternatively, consider keeping the rewardRate constant but extend periodFinish time by += reward / rewardRate."}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/proposals/ProposalExecutionEngine.sol", "L183-L202"]], "vuln": "ArbitraryCallsProposal.sol and ListOnOpenseaProposal.sol safeguards can be bypassed by cancelling in-progress proposal allowing the majority to steal NFT", "severity": "HIGH", "mitigation": "When a proposal is canceled, it should call a proposal specific function that makes sure everything is cleaned up. NFTs delisted, approvals revoked, etc."}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/crowdfund/BuyCrowdfund.sol", "L98-L116"]], "vuln": "Attacker can DOS private party by donating ETH then calling buy", "severity": "HIGH", "mitigation": "Permission to call BuyCrowdFund.sol#buy should be gated if there is a gatekeeper"}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/party/PartyGovernance.sol", "L594"]], "vuln": "PartyGovernance: Can vote multiple times by transferring NFT in same block as proposal", "severity": "HIGH", "mitigation": "You should query the voting power at `values.proposedTime - 1`. This value is already finalized when the proposal is created and therefore cannot be manipulated by repeatedly transferring the voting power to different wallets."}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/proposals/ListOnZoraProposal.sol", "L176-L183"]], "vuln": "A majority attack can easily bypass Zora auction stage in OpenseaProposal and steal the NFT from the party.", "severity": "HIGH", "mitigation": "_settleZoraAuction is called from both ListOnZoraProposal and ListOnOpenseaProposal. If the auction was cancelled due to a failed transfer, as is described in the comment, we would like to handle it differently for each proposal type. For ListOnZoraProposal, it should indeed return false, in order to finish executing the proposal and not to hang the engine. For ListOnOpenseaProposal, the desired behavior is to *revert* in the case of a failed transfer. This is because the next stage is risky and defense against the mentioned attack is required. Therefore, pass a revertOnFail flag to _settleZoraAuction, which will be used like so:\n```\n// Check whether auction cancelled due to a failed transfer during\n// settlement by seeing if we now possess the NFT.\nif (token.safeOwnerOf(tokenId) == address(this)) {\n\tif (revertOnFail) {\n\t\trevert(\"Zora auction failed because of transfer to bidder\")\n\t}\n           emit ZoraAuctionFailed(auctionId);\n           return false;\n}\n```"}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/crowdfund/BuyCrowdfundBase.sol", "L117-L118"]], "vuln": "Attacker can list an NFT they own and inflate to zero all users\u2019 contributions, keeping the NFT and all the money", "severity": "MEDIUM", "mitigation": "Disable the option to have unlimited maximumPrice for BuyCrowdfund and CollectionBuyCrowdfund contracts. AuctionCrowdfund is already safe by not allowing a zero maximumBid."}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/crowdfund/AuctionCrowdfund.sol", "L166-L167"]], "vuln": "Attacker can force AuctionCrowdfunds to bid their entire contribution up to maxBid", "severity": "MEDIUM", "mitigation": "Introduce a new option variable to AuctionCrowdfunds called speedBump. Inside the bid() function, calculate seconds since last bid, multiplied by the price change factor. This product must be smaller than the chosen speedBump. Using this scheme, the protocol would have resistance to sudden bid spikes. Optionally, allow a majority funder to override the speed bump."}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/crowdfund/BuyCrowdfundBase.sol", "L114-L135"]], "vuln": "Early contributor can always become majority of crowdfund leading to rugging risks.", "severity": "MEDIUM", "mitigation": "Add a Crowdfund property called minimumPrice, which will be visible to all. Buy() function should not accept NFT price < minimumPrice. Users now have assurances that are not susceptible to majority rule if they deposited enough ETH below the minimumPrice."}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/crowdfund/Crowdfund.sol", "L147"]], "vuln": "Possibility to burn all ETH in Crowdfund under some circumstances", "severity": "HIGH", "mitigation": "Do not allow an initial contribution when `opts.initialContributor` is not set."}
{"locs": [["PartyDAO/party-contracts-c4", "main", "contracts/crowdfund/AuctionCrowdfund.sol", "L236"]], "vuln": "NFT Owner can stuck Crowdfund user funds", "severity": "MEDIUM", "mitigation": "Remove the line lastBid_ = totalContributions; and let it be the last bid amount which crowdfund users actually bided with."}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/crowdfund/BuyCrowdfundBase.sol", "L122"]], "vuln": "The settledPrice maybe exceed maximumPrice", "severity": "MEDIUM", "mitigation": "add check\n\n```\n    function _buy(\n        IERC721 token,\n        uint256 tokenId,\n        address payable callTarget,\n        uint96 callValue,\n        bytes calldata callData,\n        FixedGovernanceOpts memory governanceOpts\n    )\n    ...\n            settledPrice_ = callValue == 0 ? totalContributions : callValue;\n            if (settledPrice_ == 0) {\n                // Still zero, which means no contributions.\n                revert NoContributionsError();\n            }\n\n+++         if (maximumPrice_ != 0 && settledPrice_ > maximumPrice_) {\n+++                settledPrice_ = maximumPrice_;\n+++         }\n\n            settledPrice = settledPrice_;    \n```"}
{"locs": [["PartyDAO/party-contracts-c4", "3896577b8f0fa16cba129dc2867aba786b730c1b", "contracts/crowdfund/AuctionCrowdfund.sol", "L233-L242"]], "vuln": "AuctionCrowdfund: If the contract was bid on before the NFT was gifted to the contract, lastBid will not be totalContributions", "severity": "MEDIUM", "mitigation": "Whether or not NFT is free to get should be determined using whether the contract balance is greater than totalContributions"}
{"locs": [["PartyDAO/party-contracts-c4", "main", "contracts/crowdfund/AuctionCrowdfund.sol", "L149"]], "vuln": "Maximum bid will always be used in Auction", "severity": "MEDIUM", "mitigation": "maximumbid concept can easily be bypassed as shown above and will not make sense. Either remove it completely\n   OR\nbid function should only be callable via crowdfund members then attacker would be afraid if new bid will come or not and there should be a consensus between crowdfund members before bidding which will protect this scenario"}
{"locs": [["PartyDAO/party-contracts-c4", "main", "contracts/proposals/ArbitraryCallsProposal.sol", "L72"]], "vuln": "Excess eth is not refunded", "severity": "MEDIUM", "mitigation": "At the end of _executeArbitraryCalls function, refund the remaining ethAvailable back to the user"}
{"locs": [["code-423n4/2022-09-tribe", "769b0586b4975270b669d7d1581aa5672d6999d5", "contracts/shutdown/redeem/TribeRedeemer.sol", "L44-L61"]], "vuln": "A malicious user can send tokens to the TribeRedeemer contract to make the redeem function work, and other users may lose assets as a result", "severity": "MEDIUM", "mitigation": "Consider making the TribeRedeemer contract inherit the Pausable contract and allow users to redeem when a sufficient number of tokens have been sent to the contract"}
{"locs": [["code-423n4/2022-09-nouns-builder", "7e9fddbbacdd7d7812e912a369cfd862ee67dc03", "src/lib/token/ERC721Votes.sol", "L268"]], "vuln": "User can get unlimited votes", "severity": "HIGH", "mitigation": "Change delegate transfer in `afterTokenTransfer` to \n\n```\n        _moveDelegateVotes(delegates(_from), delegates(_to), 1);\n```"}
{"locs": [["code-423n4/2022-09-nouns-builder", "7e9fddbbacdd7d7812e912a369cfd862ee67dc03", "src/auction/Auction.sol", "L248-L254"]], "vuln": "Highest bid in first auction can get irretrievably stuck in the protocol", "severity": "MEDIUM", "mitigation": "Remove the block in `unpause()` that transfers ownership and creates an auction if `auction.tokenId == 0` and trigger those actions manually in the deployment flow."}
{"locs": [["code-423n4/2022-09-nouns-builder", "7e9fddbbacdd7d7812e912a369cfd862ee67dc03", "src/token/Token.sol", "L179"]], "vuln": "Token:mint: infinite loop if the founders\u2019 shares sum up to 100", "severity": "MEDIUM", "mitigation": "use `_tokenId` instead of `baseTokenId`.\n\n<!-- zzzitron H01 -->"}
{"locs": [["code-423n4/2022-09-nouns-builder", "7e9fddbbacdd7d7812e912a369cfd862ee67dc03", "src/token/Token.sol", "L118"]], "vuln": "Founders can receive less tokens that expected", "severity": "MEDIUM", "mitigation": "Replace the line 118 of `Token.sol` by `baseTokenId = (baseTokenId + schedule) % 100;`."}
{"locs": [["code-423n4/2022-09-nouns-builder", "main", "src/governance/governor/Governor.sol", "L588"]], "vuln": "Proposals can be bricked and Auctions stalled by bad settings", "severity": "MEDIUM", "mitigation": "Implement reasonable range bounds reverting where appropriate. In particular for the above apply:\n- Governor settings `quorumThresholdBps` <= 10_000\n- Governor settings `proposalThresholdBps` <= 10_000\n- Treasury settings `delay` <= 6 months\n- Auction settings `duration` <= 6 months\n- Auction settings `timeBuffer` <= 6 months\n\nAdd these checks to the `initialize()` functions and in the setter / update functions where these individual settings properties can be updated."}
{"locs": [["code-423n4/2022-09-nouns-builder", "main", "src/lib/token/ERC721Votes.sol", "L179-L190"]], "vuln": "Delegation should not be allowed to address(0)", "severity": "MEDIUM", "mitigation": "Either:\n1. Don't allow delegation to address(0) by adding a check\nor\n2. If someone tries to delegate to address(0), delegate to the NFT owner instead"}
{"locs": [["code-423n4/2022-09-nouns-builder", "main", "src/token/metadata/MetadataRenderer.sol", "L188-L198"]], "vuln": "Index out of bounds error when properties length is more than attributes length breaks minting", "severity": "MEDIUM", "mitigation": "The maximum amount of properties an owner can add should be less than the maximum amount of attributes any token can have. Consider either limiting the ```properties``` variable in ```MetadataRenderer.sol``` to 15 or allow any number of attributes to be added to a token."}
{"locs": [["code-423n4/2022-09-nouns-builder", "7e9fddbbacdd7d7812e912a369cfd862ee67dc03", "src/auction/Auction.sol", "L234"]], "vuln": "Try-catch block at Auction._createAuction() will only catch string errors", "severity": "MEDIUM", "mitigation": "Remove the `Error` so that it'll catch any kind of revert:\n\n```diff\n             // Pause the contract if token minting failed\n-        } catch Error(string memory) {\n+        } catch  {\n             _pause();\n         }\n     }\n```"}
{"locs": [["code-423n4/2022-09-nouns-builder", "main", "src/governance/governor/Governor.sol", "L385-L405"]], "vuln": "Compromised or malicious vetoer can veto any proposals with unrestricted power", "severity": "MEDIUM", "mitigation": "A token supply threshold governance configuration can be added. Before the token supply exceeds this threshold, the vetoer can remain in full power for protecting against the 51% attack on the deployed DAO while the token supply is low.\n\nAfter the token supply exceeds this threshold, the following changes can be considered for restricting the vetoer's power.\n1. The vetoer is only allowed to veto a proposal during a defined period after the voting is done. The proposal is not allowed to be executed during this period.\n2. The vetoer is only allowed to veto the passed proposal when the number of support and against votes are very close or the number of support votes is much higher than the against votes."}
{"locs": [["code-423n4/2022-09-nouns-builder", "7e9fddbbacdd7d7812e912a369cfd862ee67dc03", "src/auction/Auction.sol", "L307-L335"]], "vuln": "Auction parameters can be changed during ongoing auction", "severity": "MEDIUM", "mitigation": "- do not apply changed parameters on ongoing auctions \n- add a timelock for the changes"}
{"locs": [["code-423n4/2022-09-nouns-builder", "7e9fddbbacdd7d7812e912a369cfd862ee67dc03", "src/governance/governor/Governor.sol", "L465-L477"]], "vuln": "Precision is not enough for proposalThreshold and quorum. Collections with at least 20000 NFTs in total supply may have some trouble.", "severity": "MEDIUM", "mitigation": "Increase division to a more precise value such as 1e18 to allow high total supply NFT to always set threshold as 1\n\n```\n    /// @notice The current number of votes required to submit a proposal\n    function proposalThreshold() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.proposalThresholdBps) / 1e18;\n        }\n    }\n\n    /// @notice The current number of votes required to be in favor of a proposal in order to reach quorum\n    function quorum() public view returns (uint256) {\n        unchecked {\n            return (settings.token.totalSupply() * settings.quorumThresholdBps) / 1e18;\n        }\n    }\n```"}
{"locs": [["code-423n4/2022-09-nouns-builder", "debe9b792cc70510eadf9b3728cde5b0f2ec9a1f", "src/token/Token.sol", "L110"]], "vuln": "Token: Founder percentages not always respected", "severity": "MEDIUM", "mitigation": "Consider using another distribution scheme. Instead of the current \"greedy\" scheme (minting until a slot is free), it would make sense to mint the tokens for the founders every 100 tokens, i.e. everytime when `tokenId % 100 == 0`. Like that, it is ensured that the actual percentages are equal to the desired percentages."}
{"locs": [["code-423n4/2022-08-olympus", "b5e139d732eb4c07102f149fb9426d356af617aa", "src/policies/Governance.sol", "L205-L262><br>"]], "vuln": "`activateProposal()` need time delay", "severity": "MEDIUM", "mitigation": "Add time delay when activating a proposal, so that users can be aware of that and vote for the current one within the time window."}
{"locs": [["code-423n4/2022-08-olympus", "main", "src/modules/PRICE.sol", "L165-L171><br>"]], "vuln": "Inconsistency in staleness checks between OHM and reserve token oracles", "severity": "MEDIUM", "mitigation": "Change the line 171 to\n\n                if (updatedAt < block.timestamp - 3 * uint256(observationFrequency))\n\nlike line 165."}
{"locs": [["code-423n4/2022-08-olympus", "main", "src/modules/TRSRY.sol", "L64-L102><br>"]], "vuln": "TRSRY susceptible to loan / withdraw confusion", "severity": "MEDIUM", "mitigation": "A separate mapping called loanApproval should be implemented, and setLoanApprovalFor() will set it, getLoan() will reduce loanApproval balance."}
{"locs": [["code-423n4/2022-08-olympus", "b5e139d732eb4c07102f149fb9426d356af617aa", "src/policies/Operator.sol", "L363-L469><br>"]], "vuln": "Cushion bond markets are opened at wall price rather than current price", "severity": "MEDIUM", "mitigation": "Initial price should be updated to open bond market at current price rather than wall price."}
{"locs": [["code-423n4/2022-08-olympus", "b5e139d732eb4c07102f149fb9426d356af617aa", "src/policies/TreasuryCustodian.sol", "L53-L67><br>"]], "vuln": "Griefing/DOS of withdrawals by EOAs from treasury (TRSRY) possible", "severity": "MEDIUM", "mitigation": "A partial but insufficient fix would be to check if the address passed to the function contains code and hence is not an EOA. A better approach might be to add a mapping(address => bool) of all addresses that have been active policies some time in the past to the kernel, something like this:\n\nAs a public variable in Kernel.sol\n`mapping(address => bool) public isRegisteredPolicy;`\n\nin Kernel.activatePolicy():\n`isRegisteredPolicy[address(policy_)] ) = true;`\n\nand finally in TreasuryCustodian.revokePolicyApprovals():\n`if(!kernel.isRegisteredPolicy(policy_) revert NotARegisteredPolicy`"}
{"locs": [["code-423n4/2022-08-olympus", "main", "src/Kernel.sol", "L325>"]], "vuln": "Missing checks in `Kernel._deactivatePolicy`", "severity": "MEDIUM", "mitigation": "Adding `require(activePolicies[idx] == policy_, \"Unregistered policy\");` will prevent this, where `idx = getPolicyIndex[policy_]`.\n\n**NOTE:** The issue is less likely to happen as this is handled solely by the executor, but having safeguards in the contract is always better than relying on an external factor."}
{"locs": [["code-423n4/2022-08-olympus", "b5e139d732eb4c07102f149fb9426d356af617aa", "src/policies/Governance.sol", "L268-L269)"]], "vuln": "No Cap on Amount of VOTES means the `voter_admin` can get any proposal to pass", "severity": "MEDIUM", "mitigation": "Add a total supply cap to `VOTES`."}
{"locs": [["code-423n4/2022-08-olympus", "2a0b515012b4a40076f6eac487f7816aafb8724a", "src/policies/Governance.sol", "L265-L289>"]], "vuln": "OlympusGovernance - active proposal does not expire", "severity": "MEDIUM", "mitigation": "It is recommended to add expiration for the active proposal for example 2 weeks. After that time it should be possible to reject proposal and users should be able to reclaim VOTES tokens."}
{"locs": [["code-423n4/2022-08-olympus", "main", "src/modules/TRSRY.sol", "L60><br>"]], "vuln": "Low market bonds/swaps not working after loan is taken from treasury", "severity": "MEDIUM", "mitigation": "Determine capacity from actual tokens held by treasury."}
{"locs": [["code-423n4/2022-08-olympus", "main", "src/modules/TRSRY.sol", "L108-L112><br>"]], "vuln": "Treasury module is vulnerable to cross-contract reentrancy", "severity": "MEDIUM", "mitigation": "Add a function used to pull a token to the contract and mark it nonReentrant. Any transfer of tokens to the treasury should be done through that function."}
{"locs": [["code-423n4/2022-08-olympus", "549b96bcf8b97807738572605f6b1e26b33ef411", "src/modules/INSTR.sol", "L61><br>"]], "vuln": "Unexecutable proposals when `Actions.MigrateKernel` is not last instruction", "severity": "MEDIUM", "mitigation": "Perform the same check for `MigrateKernel`."}
{"locs": [["code-423n4/2022-08-olympus", "549b96bcf8b97807738572605f6b1e26b33ef411", "src/Kernel.sol", "L296><br>"]], "vuln": "Activating same Policy multiple times in Kernel possible", "severity": "MEDIUM", "mitigation": "Check `getPolicyIndex[policy_] != 0` instead of relying on a value of an untrusted contract."}
{"locs": [["code-423n4/2022-08-fiatdao", "fece3bdb79ccacb501099c24b60312cd0b2e4bb2", "contracts/VotingEscrow.sol", "L526-L625"]], "vuln": "Delegators can Avoid Lock Commitments if they can Reliably get Themselves Blocked when Needed", "severity": "HIGH", "mitigation": "`forceUndelegate()` could be made to set `locked_.end = fromLocked.end`. This would mean that blocked users are still locked into the system for the period they delegated for. However, this does have the downside of tokens being locked in the system without the full rights of the system which other users enjoy.\nAlternatively, this might be addressable through not blocking users that seem to be doing this, but of course that might have other undersirable consequences.\n\n#"}
{"locs": [["code-423n4/2022-08-fiatdao", "fece3bdb79ccacb501099c24b60312cd0b2e4bb2", "contracts/VotingEscrow.sol", "L418"]], "vuln": "The current implementation of the VotingEscrow contract doesn\u2019t support fee on transfer tokens", "severity": "MEDIUM", "mitigation": "Calculate the amount to add to the locked amount by the difference between the balances before and after the transfer instead of using the supplied value."}
{"locs": [["code-423n4/2022-08-fiatdao", "main", "contracts/VotingEscrow.sol", "L513-L514"]], "vuln": "Error in Updating _checkpoint in the increaseUnlockTime Function", "severity": "MEDIUM", "mitigation": "The line 513 in the VotingEscrow.sol contract :\n\n```\n      513      oldLocked.end = unlock_time;\n```\n\nNeed to be replaced with the following :\n\n```\n      513      oldLocked.end = oldUnlockTime;\n```"}
{"locs": [["code-423n4/2022-08-fiatdao", "fece3bdb79ccacb501099c24b60312cd0b2e4bb2", "contracts/VotingEscrow.sol", "L418"]], "vuln": "Unsafe casting from int128 can cause wrong accounting of locked amounts", "severity": "MEDIUM", "mitigation": "Make sure that the values fit in the variables you are trying to assign them to when casting variables to smaller types."}
{"locs": [["code-423n4/2022-08-fiatdao", "fece3bdb79ccacb501099c24b60312cd0b2e4bb2", "contracts/VotingEscrow.sol", "L632-L659"]], "vuln": "Attackers can abuse the quitLock function to get a very large amount of votes", "severity": "MEDIUM", "mitigation": "Think about implementing a mechanism that prevents users from creating a lock and quitting it in the same transaction, that way attackers won't be able to use flashloan in order to achieve large voting power. However, regular loans will still be a problem with that fix, and if this isn't a wanted behavior addition fix is needed to be thought of."}
{"locs": [["code-423n4/2022-08-frax", "c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f", "src/contracts/FraxlendPair.sol", "L206)"]], "vuln": "Owner of `FraxlendPair` can set arbitrary time lock contract address to circumvent time lock", "severity": "MEDIUM", "mitigation": "Currently, the owner `COMPTROLLER_ADDRESS` address is trustworthy, however, nothing prevents the above-described scenario. To protect users from sudden protocol fee changes, consider using a minimal time lock implementation directly implemented in the contract without trusting any external contract."}
{"locs": [["code-423n4/2022-08-frax", "c4189a3a98b38c8c962c5ea72f1a322fbc2ae45f", "src/contracts/FraxlendPairDeployer.sol", "L405)"]], "vuln": "Denial of service in globalPause by wrong logic", "severity": "MEDIUM", "mitigation": "Initialize the `_updatedAddresses` array like shown below:\n\n```diff\n    function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {\n        require(msg.sender == CIRCUIT_BREAKER_ADDRESS, \"Circuit Breaker only\");\n        address _pairAddress;\n        uint256 _lengthOfArray = _addresses.length;\n+       _updatedAddresses = new address[](_lengthOfArray);\n        for (uint256 i = 0; i < _lengthOfArray; ) {\n            _pairAddress = _addresses[i];\n            try IFraxlendPair(_pairAddress).pause() {\n                _updatedAddresses[i] = _addresses[i];\n            } catch {}\n            unchecked {\n                i = i + 1;\n            }\n        }\n    }\n```"}
{"locs": [["code-423n4/2022-08-foundation", "792e00df429b0df9ee5d909a0a5a6e72bd07cf79", "contracts/mixins/shared/MarketFees.sol", "L130)"]], "vuln": "NFT creator sales revenue recipients can steal gas", "severity": "MEDIUM", "mitigation": "Consider only providing a higher amount of gas (`SEND_VALUE_GAS_LIMIT_MULTIPLE_RECIPIENTS`) for the first creator recipient. For all following creator recipients, only forward the reduced amount of gas `SEND_VALUE_GAS_LIMIT_SINGLE_RECIPIENT`."}
{"locs": [["mimo-capital/2022-08-mimo", "5186ef4be23f9dda81c8474096edb1f0594d70c3", "contracts/actions/automated/MIMOAutoRebalance.sol", "L59) to the `rebalance` function. An [integration test](https://github.com/mimo-capital/2022-08-mimo/blob/5186ef4be23f9dda81c8474096edb1f0594d70c3/test/02_integration/automated/MIMOAutoActionSecurity.test.ts#L137) demonstrates that the function is protected against reentrancy."]], "vuln": "Vault rebalancing can be exploited if two vaults rebalance into the same vault", "severity": "MEDIUM", "mitigation": "Add nonReentrant modifier to MIMOAutomatedRebalnce.sol#rebalance."}
{"locs": [["mimo-capital/2022-08-mimo", "5186ef4be23f9dda81c8474096edb1f0594d70c3", "contracts/actions/managed/MIMOManagedRebalance.sol", "L61) to calculate the rebalance amount in PAR using a price feed."]], "vuln": "MIMOManagedRebalance.sol#rebalance calculates managerFee incorrectly", "severity": "MEDIUM", "mitigation": "varFee should be calculated against the PAR of the rebalance like it is in MIMOAutoRebalance.sol:\n\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(rbData.vaultId);\n\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, flData.amount);\n    uint256 managerFee = managedVault.fixedFee + rebalanceValue.wadMul(managedVault.varFee);"}
{"locs": [["code-423n4/2022-08-mimo", "eb1a5016b69f72bc1e4fd3600a65e908bd228f13", "contracts/actions/MIMOEmptyVault.sol", "L96-L100"]], "vuln": "`MIMOEmptyVault.sol executeOperation()` does not transfer the Vault leftover assets to the owner, it is locked in the `MIMOEmptyVault`", "severity": "HIGH", "mitigation": "```\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n\n    ....\n    ....\n\n    require(flashloanRepayAmount <= vaultCollateral.balanceOf(address(this)), Errors.CANNOT_REPAY_FLASHLOAN);\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    //****transfer the remaining balance back to mimoProxy or owner ***//\n    ++++ vaultCollateral.safeTransfer(address(mimoProxy), vaultCollateral.balanceOf(address(this)) - flashloanRepayAmount);\n\n    return true;\n  }\n\n```"}
{"locs": [["mimo-capital/2022-08-mimo", "4e579420ecbe3fc3e770996610e6ab66b0c8d15b", "contracts/proxy/MIMOProxyFactory.sol", "L47) for deploying a proxy is now to call `MIMOProxyFactory#deploy`."]], "vuln": "ProxyFactory can circumvent ProxyRegistry", "severity": "MEDIUM", "mitigation": "Adding access control to ensure that the factory deployFor function is called from the proxy registry would mitigate this issue."}
{"locs": [["code-423n4/2022-08-rigor", "5ab7ea84a1516cb726421ef690af5bc41029f88f", "contracts/Community.sol", "L685-L686)<br>"]], "vuln": "Builder can halve the interest paid to a community owner due to arithmetic rounding", "severity": "HIGH", "mitigation": "There are two possible mitigations:\n\n1.  Add a scalar to `noOfDays` so that any rounding which occurs is negligible\n\ni.e.\n\n```solidity\n        uint256 _noOfDays = (block.timestamp -\n            _communityProject.lastTimestamp) * SCALAR / 86400; // 24*60*60\n\n        /// Interest formula = (principal * APR * days) / (365 * 1000)\n        // prettier-ignore\n        uint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                _noOfDays /\n                365000 /\n                SCALAR;\n```\n\n2.  Remove the `noOfDays` calculation and calculate interest in one equation which reduces arithmetic rounding\n\n```solidity\nuint256 _unclaimedInterest = \n                _lentAmount *\n                _communities[_communityID].projectDetails[_project].apr *\n                (block.timestamp -\n            _communityProject.lastTimestamp) /\n                365000 /\n                86400;\n```"}
{"locs": [["code-423n4/2022-08-rigor", "e35f5f61be9ff4b8dc5153e313419ac42964d1fd", "contracts/Community.sol", "L267)<br>"]], "vuln": "Wrong APR can be used when project is unpublished and published again", "severity": "HIGH", "mitigation": "When publishing a project, if the `lentAmount` for the community is non-zero, calculate the interest before updating the APR."}
{"locs": [["code-423n4/2022-08-rigor", "f2498c86dbd0e265f82ec76d9ec576442e896a87", "contracts/Project.sol", "L859)<br>"]], "vuln": "Hash approval not possible when contractor == subcontractor", "severity": "MEDIUM", "mitigation": "Delete the approval only when all checks are done."}
{"locs": [["code-423n4/2022-08-rigor", "main", "contracts/Community.sol", "L206-L282)<br>"]], "vuln": "It should not submit a project with no total budget. Requires at least one task with cost > 0", "severity": "MEDIUM", "mitigation": "Add a new `require` which will check if the first task (which is at index 1), its cost is > 0.\n\n      // Local instance of variables. For saving gas.\n      IProject _projectInstance = IProject(_project);\n      ...\n\n      // Revert if project doesn't have one task with budget > 0\n      require(_projectInstance.tasks[1].cost > 0, \"First task > 0\");"}
{"locs": [["code-423n4/2022-08-rigor", "5ab7ea84a1516cb726421ef690af5bc41029f88f", "contracts/HomeFi.sol", "L225)<br>"]], "vuln": "Owner of project NFT has no purpose", "severity": "MEDIUM", "mitigation": "Consider preventing transferring the project NFT to a different address for now as long as there is no use-case for the NFT owner/holder or use the actual NFT owner as the `builder` of a project."}
{"locs": [["code-423n4/2022-07-axelar", "a1205d2ba78e0db583d136f8563e8097860a110f", "xc20/contracts/XC20Wrapper.sol", "L66)<br>"]], "vuln": "`removeWrapping` can be called when there are still wrapped tokens", "severity": "MEDIUM", "mitigation": "Track how many wrapped tokens are in circulation, only allow the removal of a wrapped tokens when there are 0 to ensure for users that they will always be able to unwrap."}
{"locs": [["code-423n4/2022-07-axelar", "a46fa61e73dd0f3469c0263bc6818e682d62fb5f", "contracts/deposit-service/DepositReceiver.sol", "L25)<br>"]], "vuln": "System will not work anymore after EIP-4758", "severity": "MEDIUM", "mitigation": "To avoid that Axelar simply stops working one day, the architecture should be changed. Instead of generating addresses for every user, the user could directly interact with the deposit service and the deposit service would need to keep track of funds and provide refunds directly."}
{"locs": [["code-423n4/2022-07-golom", "8f198624b97addbbe9602a451c908ea51bd3357c", "contracts/vote-escrow/VoteEscrowDelegation.sol", "L80)<br>"]], "vuln": "Old delegatee not deleted when delegating to new tokenId", "severity": "HIGH", "mitigation": "Remove the entry in `delegatedTokenIds` of the old delegatee or simply call `removeDelegation` first."}
{"locs": [["code-423n4/2022-07-golom", "e5efa8f9d6dda92a90b8b2c4902320acf0c26816", "contracts/rewards/RewardDistributor.sol", "L98-L138)"]], "vuln": "`addFee` will stop accumulating fee once `rewardToken` has reached max supply", "severity": "HIGH", "mitigation": "Modify `addFee` so that the check won't skip accruing trade fees:\n\n    function addFee(address[2] memory addr, uint256 fee) public onlyTrader {\n        if (block.timestamp > startTime + (epoch) * secsInDay) {\n            uint256 previousEpochFee = epochTotalFee[epoch];\n            epoch = epoch + 1;\n\n            if (rewardToken.totalSupply() > 1000000000 * 10**18) {\n                emit NewEpoch(epoch, 0, 0, previousEpochFee);\n            } else {\n                uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /\n                    rewardToken.totalSupply();\n                uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();\n\n                rewardStaker[epoch] = stakerReward;\n                rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;\n                rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;\n                rewardToken.mint(address(this), tokenToEmit);\n                epochBeginTime[epoch] = block.number;\n                if (previousEpochFee > 0) {\n                    if (epoch == 1){\n                        epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.\n                        weth.deposit{value: address(this).balance}();  \n                    }else{\n                        weth.deposit{value: previousEpochFee}();\n                    }\n                }\n                emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);\n            }\n        }\n        feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;\n        feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;\n        epochTotalFee[epoch] = epochTotalFee[epoch] + fee;\n        return;\n    }"}
{"locs": [["golom-protocol/contracts", "4e84d5c2115d163ca54a1729da46164e8cf4df6d", "contracts/vote-escrow/VoteEscrowDelegation.sol", "L101-L108)<br>"]], "vuln": "`_writeCheckpoint` does not write to storage on same block", "severity": "HIGH", "mitigation": "Define the `oldCheckpoint` variable as a `storage` pointer:\n\n`Checkpoint storage oldCheckpoint = checkpoints[toTokenId][nCheckpoints - 1];`"}
{"locs": [["code-423n4/2022-07-golom", "e5efa8f9d6dda92a90b8b2c4902320acf0c26816", "contracts/vote-escrow/VoteEscrowDelegation.sol", "L213)<br>"]], "vuln": "Cannot remove delegation from a token to another token", "severity": "HIGH", "mitigation": "Two fixes are proposed:\n\n1.  Add the delegatee as an argument to `removeDelegation` and remove `tokenId` from its list of delegators:\n\n```diff\n-   function removeDelegation(uint256 tokenId) external {\n+   function removeDelegation(uint256 tokenId, uint256 toTokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n-       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n+       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n```\n\nor\n\n2.  Load the delegatee from the mapping `delegates` which maps each delegator to its current delegatee:\n\n```diff\n    function removeDelegation(uint256 tokenId) external {\n        require(ownerOf(tokenId) == msg.sender, 'VEDelegation: Not allowed');\n+       uint256 toTokenId = delegates[tokenId];\n        uint256 nCheckpoints = numCheckpoints[tokenId];\n-       Checkpoint storage checkpoint = checkpoints[tokenId][nCheckpoints - 1];\n+       Checkpoint storage checkpoint = checkpoints[toTokenId][nCheckpoints - 1];\n        removeElement(checkpoint.delegatedTokenIds, tokenId);\n        _writeCheckpoint(tokenId, nCheckpoints, checkpoint.delegatedTokenIds);\n    }\n```"}
{"locs": [["code-423n4/2022-07-golom", "7bbb55fca61e6bae29e57133c1e45806cbb17aa4", "contracts/core/GolomTrader.sol", "L98)<br>"]], "vuln": "Replay attack in case of hard fork", "severity": "MEDIUM", "mitigation": "The EIP712\\_DOMAIN_TYPEHASH variable should be recomputed everytime by placing current value of chainId."}
{"locs": [["code-423n4/2022-07-golom", "e5efa8f9d6dda92a90b8b2c4902320acf0c26816", "contracts/core/GolomTrader.sol", "L312-L317)<br>"]], "vuln": "Orders with `tokenAmt` of `type(uint256).max` cannot be cancelled by `GolomTrader.sol#cancelOrder`", "severity": "MEDIUM", "mitigation": "I don't see any reason why 1 should be added to `o.tokenAmt`, change to:\n\n        filled[hashStruct] = o.tokenAmt;"}
{"locs": [["code-423n4/2022-07-golom", "7bbb55fca61e6bae29e57133c1e45806cbb17aa4", "contracts/governance/GolomToken.sol", "L14-L73)<br>"]], "vuln": "`GolomToken.sol` doesn't contain a function to mint treasury tokens", "severity": "MEDIUM", "mitigation": "Add a function to GolomToken.sol to mint the treasury tokens similar to the `mintAirdrop()` and `mintGenesisReward()` functions."}
{"locs": [["code-423n4/2022-07-golom", "e5efa8f9d6dda92a90b8b2c4902320acf0c26816", "contracts/vote-escrow/VoteEscrowCore.sol", "L1226-L1236)<br>"]], "vuln": "Delegated NFTs that are withdrawn while still delegated will remain delegated even after burn", "severity": "MEDIUM", "mitigation": "Override \\_burn in VoteEscrowDelegation and add this.removeDelegation(\\_tokenId), similar to how it was done in \\_transferFrom."}
{"locs": [["code-423n4/2022-07-golom", "e5efa8f9d6dda92a90b8b2c4902320acf0c26816", "contracts/rewards/RewardDistributor.sol", "L172-L210)<br>"]], "vuln": "Rewards owed burned NFT in `RewardDistributor.sol` become irretrievable", "severity": "MEDIUM", "mitigation": "Implement a clawback clause inside the multiStakerClaim function. If the token is burned (i.e. owned by address(0)) the rewards should be transferred to different address. These rewards could be claimed to the treasury or burned, etc.\n\n        if (tokenowner == address(0){\n            rewardToken.transfer(treasury, reward);\n            weth.transfer(treasury, rewardEth);\n        }"}
{"locs": [["code-423n4/2022-07-golom", "e5efa8f9d6dda92a90b8b2c4902320acf0c26816", "contracts/core/GolomTrader.sol", "L176-L177>"]], "vuln": "`GolomTrader`: `validateOrder` function does not check if ecrecover return value is 0", "severity": "MEDIUM", "mitigation": "Use the recover function from OpenZeppelin's ECDSA library for signature verification."}
{"locs": [["code-423n4/2022-07-golom", "7bbb55fca61e6bae29e57133c1e45806cbb17aa4", "contracts/vote-escrow/VoteEscrowDelegation.sol", "L212-L213>"]], "vuln": "NFTs that don't have a checkpoint can't be transferred", "severity": "MEDIUM", "mitigation": "Make removeDelegation simply return if `nCheckpoints = 0`."}
{"locs": [["code-423n4/2022-07-golom", "e5efa8f9d6dda92a90b8b2c4902320acf0c26816", "contracts/core/GolomTrader.sol", "L217)<br>"]], "vuln": "`fillAsk()` Allows for `msg.value` to be larger than require locking the excess in the contract", "severity": "MEDIUM", "mitigation": "To avoid this issue consider enforcing a strict equality.\n\n```solidity\n        require(msg.value == o.totalAmt * amount + p.paymentAmt, 'mgmtm');\n```"}
{"locs": [["code-423n4/2022-07-golom", "7bbb55fca61e6bae29e57133c1e45806cbb17aa4", "contracts/core/GolomTrader.sol", "L236)<br>"]], "vuln": "Use `safeTransferFrom` Instead of `transferFrom` for ERC721", "severity": "MEDIUM", "mitigation": "I recommend to call the `safeTransferFrom()` method instead of `transferFrom()` for NFT transfers."}
{"locs": [["code-423n4/2022-07-swivel", "daf72892d8a8d6eaa43b9e7d1924ccb0e612ee3c", "VaultTracker/VaultTracker.sol", "L123-L132>"]], "vuln": "Loss of funds in an underlying protocol would cause catostrophic loss of funds for swivel", "severity": "MEDIUM", "mitigation": "The impact of such an event could be decreased with changes. In splitUnderlying add:\n\n`require(block.timestamp < m)`\n\nThis prevents nTokens from being created after expiration which dramatically reduces the ability to take advantage of the opportunity. As for redeemInterest, add the following line after L124:\n\n`vlt.notional = 0`\n\nThis would clear the notional balance of the user when redeeming after maturity, making it impossible to call repeatedly and reduces the chances that any users have a notional balance to exploit it should an event like this happen."}
{"locs": [["code-423n4/2022-07-ens", "ff6e59b9415d0ead7daf31c2ed06e86d9061ae22", "contracts/dnssec-oracle/BytesUtils.sol", "L66-L70)<br>"]], "vuln": "`BytesUtil.compare` returns wrong result on some strings longer than 32 characters", "severity": "MEDIUM", "mitigation": "In addition to the incorrect condition, the mask calculation formula: `32 - shortest + idx` will also overflow since `shortest` can be more than `32`, so addition should be performed before subtractions.\n\n                if (shortest - idx >= 32) {\n                    mask = type(uint256).max;\n                } else {\n                    mask = ~(2 ** (8 * (idx + 32 - shortest)) - 1);\n                }"}
{"locs": [["code-423n4/2022-07-ens", "main", "contracts/dnssec-oracle/DNSSECImpl.sol", "L186-L190)<br>"]], "vuln": "`DNSSECImpl.verifySignature` compares strings incorrectly, allowing malicious zones to forge DNSSEC trust chain", "severity": "MEDIUM", "mitigation": "Check label by label instead of comparing the entire name.<br>\nTo actually meet all requirements specified in RFC4034 and RFC4035, there are still a lot to do, but we will discuss that in a separate issue for clarity."}
{"locs": [["code-423n4/2022-07-ens", "ff6e59b9415d0ead7daf31c2ed06e86d9061ae22", "contracts/wrapper/NameWrapper.sol", "L955-L961)<br>"]], "vuln": "If `PARENT_CANNOT_CONTROL` is set on subdomain, it can be unwrapped then wrapped by its owner and then parent can control it again before the expiry", "severity": "MEDIUM", "mitigation": "Burning any fuse (including `PARENT_CANNOT_CONTROL`) must require `CANNOT_UNWRAP` fuse to be burned (because otherwise it's possible to unwrap+wrap to clear that fuse).\n\nIn `NameWrapper._canFusesBeBurned`, condition should be different:\n\n        if (\n            fuses & ~CANNOT_UNWRAP != 0 &&\n            fuses & (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP) !=\n            (PARENT_CANNOT_CONTROL | CANNOT_UNWRAP)\n        ) {\n            revert OperationProhibited(node);\n        }"}
{"locs": [["code-423n4/2022-07-ens", "ff6e59b9415d0ead7daf31c2ed06e86d9061ae22", "contracts/dnssec-oracle/BytesUtils.sol", "L115-L127)<br>"]], "vuln": "Wrong Equals Logic", "severity": "MEDIUM", "mitigation": "```diff\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\n-       return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\n+       return self.length == offset + other.length && equals(self, offset, other, 0, other.length);\n    }\n```"}
{"locs": [["code-423n4/2022-07-ens", "ff6e59b9415d0ead7daf31c2ed06e86d9061ae22", "contracts/wrapper/NameWrapper.sol", "L327-L346)<br>"]], "vuln": "The `unwrapETH2LD` use `transferFrom` instead of `safeTransferFrom` to transfer ERC721 token", "severity": "MEDIUM", "mitigation": "```diff\n    function unwrapETH2LD(\n        bytes32 labelhash,\n        address newRegistrant,\n        address newController\n    ) public override onlyTokenOwner(_makeNode(ETH_NODE, labelhash)) {\n        _unwrap(_makeNode(ETH_NODE, labelhash), newController);\n-       registrar.transferFrom(\n+       registrar.safeTransferFrom(\n            address(this),\n            newRegistrant,\n            uint256(labelhash)\n        );\n    }\n```"}
{"locs": [["code-423n4/2022-07-ens", "main", "contracts/dnssec-oracle/RRUtils.sol", "L266-L268)<br>"]], "vuln": "Incorrect implementation of `RRUtils.serialNumberGte`", "severity": "MEDIUM", "mitigation": "Use the naive implementation instead<br>\n`return (i1 == i2) || ((i1 < i2) && ((i2 - i1) > (2**31))) || ((i1 > i2) && ((i1 - i2) < (2**31)));`"}
{"locs": [["code-423n4/2022-07-ens", "ff6e59b9415d0ead7daf31c2ed06e86d9061ae22", "contracts/wrapper/ERC1155Fuse.sol", "L274-L284"]], "vuln": "`ERC1155Fuse`: `_transfer` does not revert when sent to the old owner", "severity": "MEDIUM", "mitigation": "Revert even if the `to` address already owns the token."}
{"locs": [["code-423n4/2022-07-fractional", "8f2697ae727c60c93ea47276f8fa128369abfe51", "src/modules/Migration.sol", "L471-L472>"]], "vuln": "Users can lose fractions to precision loss during migraction if _newFractionSupply is set very low", "severity": "HIGH", "mitigation": "When calling propose require that `\\_newFractionSupply` is greater than some value (i.e. 1E18)."}
{"locs": [["code-423n4/2022-07-fractional", "8f2697ae727c60c93ea47276f8fa128369abfe51", "src/modules/Migration.sol", "L194>"]], "vuln": "Failed proposal can be committed again", "severity": "HIGH", "mitigation": "Change the length of either the migration period or the buyout period to match so that a proposal can't be replayed."}
{"locs": [["code-423n4/2022-07-fractional", "8f2697ae727c60c93ea47276f8fa128369abfe51", "src/modules/Buyout.sol", "L224-L238>"]], "vuln": "Forced buyouts can be performed by malicious buyers", "severity": "HIGH", "mitigation": "Consider saving the status of the proposer after a failed buyout and implementing functions to allow the proposer to withdraw the ERC1155 tokens and eth."}
{"locs": [["code-423n4/2022-07-fractional", "8f2697ae727c60c93ea47276f8fa128369abfe51", "src/modules/Buyout.sol", "L268-L269)), Eve can cash-out `10 ether` from the `Buyout` contract."]], "vuln": "Cash-out from a successful buyout allows an attacker to drain Ether from the `Buyout` contract", "severity": "HIGH", "mitigation": "Decrement `ethBalance` from buyout info `buyoutInfo[_vault].ethBalance -= buyoutShare;` in `Buyout.cash` (see `@audit-info` annotation):\n\n```solidity\nfunction cash(address _vault, bytes32[] calldata _burnProof) external {\n    // Reverts if address is not a registered vault\n    (address token, uint256 id) = IVaultRegistry(registry).vaultToToken(\n        _vault\n    );\n    if (id == 0) revert NotVault(_vault);\n    // Reverts if auction state is not successful\n    (, , State current, , uint256 ethBalance, ) = this.buyoutInfo(_vault);\n    State required = State.SUCCESS;\n    if (current != required) revert InvalidState(required, current);\n    // Reverts if caller has a balance of zero fractional tokens\n    uint256 tokenBalance = IERC1155(token).balanceOf(msg.sender, id);\n    if (tokenBalance == 0) revert NoFractions();\n\n    // Initializes vault transaction\n    bytes memory data = abi.encodeCall(\n        ISupply.burn,\n        (msg.sender, tokenBalance)\n    );\n    // Executes burn of fractional tokens from caller\n    IVault(payable(_vault)).execute(supply, data, _burnProof);\n\n    // Transfers buyout share amount to caller based on total supply\n    uint256 totalSupply = IVaultRegistry(registry).totalSupply(_vault);\n    uint256 buyoutShare = (tokenBalance * ethBalance) /\n        (totalSupply + tokenBalance);\n    buyoutInfo[_vault].ethBalance -= buyoutShare; // @audit-info decrement `ethBalance` by `buyoutShare`\n    _sendEthOrWeth(msg.sender, buyoutShare);\n    // Emits event for cashing out of buyout pool\n    emit Cash(_vault, msg.sender, buyoutShare);\n}\n```"}
{"locs": [["code-423n4/2022-07-fractional", "e2c5a962a94106f9495eb96769d7f60f7d5b14c9", "src/modules/Buyout.sol", "L86>) both values manipulated by the attacker.*"]], "vuln": "Steal NFTs from a Vault, and ETH + Fractional tokens from users.", "severity": "HIGH", "mitigation": "Update the `proposal.totalEth` and `proposal.totalFractions` in the `withdrawContribution` function."}
{"locs": [["code-423n4/2022-07-fractional", "main", "src/modules/Migration.sol", "L141) anywhere whether `proposal.isCommited == true`."]], "vuln": "Migration's `leave` function allows leaving a committed proposal", "severity": "HIGH", "mitigation": "Revert in `leave` if `proposal.isCommited == true`.\nYou might be also able to merge the functionality of `leave` and `withdrawContribution`, but that depends on how you will implement the fix for `withdrawContribution`."}
{"locs": [["jbx-protocol/juice-contracts-v2-code4rena", "828bf2f3e719873daa08081cfa0d0a6deaa5ace5", "contracts/JBChainlinkV3PriceFeed.sol", "L44"]], "vuln": "Unhandled chainlink revert would lock all price oracle access", "severity": "MEDIUM", "mitigation": "Surround the call to `latestRoundData()` with `try/catch` instead of calling it directly. In a scenario where the call reverts, the catch block can be used to call a fallback oracle or handle the error in any other suitable way."}
{"locs": [["jbx-protocol/juice-contracts-v2-code4rena", "828bf2f3e719873daa08081cfa0d0a6deaa5ace5", "contracts/JBPrices.sol", "L109-L122"]], "vuln": "addFeedFor should check if inverse feed already exists", "severity": "MEDIUM", "mitigation": "Change L115 to:\nif (feedFor[_currency][_base] != IJBPriceFeed(address(0)) || feedFor[_base][_currency] != IJBPriceFeed(address(0))) revert PRICE_FEED_ALREADY_EXISTS()"}
{"locs": [["jbx-protocol/juice-contracts-v2-code4rena", "828bf2f3e719873daa08081cfa0d0a6deaa5ace5", "contracts/JBSplitsStore.sol", "L211-L221"]], "vuln": "Duplicated locked splits can be discarded", "severity": "MEDIUM", "mitigation": "Either prevent duplicates in the splits or track the matches while checking the locked splits."}
{"locs": [["jbx-protocol/juice-contracts-v2-code4rena", "828bf2f3e719873daa08081cfa0d0a6deaa5ace5", "contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol", "L817-L856"]], "vuln": "Code credits fee-on-transfer tokens for amount stated, not amount transferred", "severity": "MEDIUM", "mitigation": "Measure the contract balance before and after the call to `transfer()`/`transferFrom()` in `JBERC20PaymentTerminal._transferFrom()`, and use the difference between the two as the amount, rather than the amount stated"}
{"locs": [["jbx-protocol/juice-contracts-v2-code4rena", "828bf2f3e719873daa08081cfa0d0a6deaa5ace5", "contracts/abstract/JBPayoutRedemptionPaymentTerminal.sol", "L1150"]], "vuln": "Grieffer beneficiary can cause DOS", "severity": "MEDIUM", "mitigation": "Have beneficiaries withdraw their benefit instead of sending it to them."}
{"locs": [["jbx-protocol/juice-contracts-v2-code4rena/", "828bf2f3e719873daa08081cfa0d0a6deaa5ace5", "contracts/JBController.sol", "L588-L606"]], "vuln": "changeTokenOf makes it impossible for holders of oldToken to redeem the overflowed assets.", "severity": "MEDIUM", "mitigation": "Consider adding a delay to changeTokenOf, or adding a function to convert oldToken to newToken"}
{"locs": [["jbx-protocol/juice-contracts-v2-code4rena/", "828bf2f3e719873daa08081cfa0d0a6deaa5ace5", "contracts/JBToken.sol", "L106-L114"]], "vuln": "JBToken: mint function could mint arbitrary amount of tokens", "severity": "MEDIUM", "mitigation": "Consider setting minter as the JBTokenStore contract and adding the onlyminter modifier to the mint function"}
{"locs": [["code-423n4/2022-06-putty", "3b6b844bc39e897bd0bbb69897f2deff12dc3893", "contracts/src/PuttyV2.sol", "L500"]], "vuln": "[Denial-of-Service Contract Owner Could Block Users From Withdrawing Their Strike", "severity": "MEDIUM", "mitigation": "It is recommended to adopt a [withdrawal pattern](https://docs.soliditylang.org/en/v0.8.15/common-patterns.html#withdrawal-from-contracts) for retrieving owner fee.\n\nInstead of transferring the fee directly to owner address during withdrawal, save the amount of fee that the owner is entitled to in a state variable. Then, implement a new function that allows the owner to withdraw the fee from the `PuttyV2` contract.\n\nConsider the following implementation. In the following example, there is no way for the owner to perform denial-of-user because the outcome of the fee transfer (succeed or fail) to the owner will not affect the user's strike withdrawal process. \n\nThis will give users more assurance and confidence about the security of their funds stored within Putty.\n\n```solidity\nmapping(address => uint256) public ownerFees;\n\nfunction withdraw(Order memory order) public {\n\t..SNIP..\n    // transfer strike to owner if put is expired or call is exercised\n    if ((order.isCall && isExercised) || (!order.isCall && !isExercised)) {\n        // send the fee to the admin/DAO if fee is greater than 0%\n        uint256 feeAmount = 0;\n        if (fee > 0) {\n            feeAmount = (order.strike * fee) / 1000;\n            ownerFees[order.baseAsset] += feeAmount\n        }\n\n        ERC20(order.baseAsset).safeTransfer(msg.sender, order.strike - feeAmount);\n\n        return;\n    }\n    ..SNIP..\n}\n\nfunction withdrawFee(address baseAsset) public onlyOwner {\n\tuint256 _feeAmount = ownerFees[baseAsset];\n\townerFees[baseAsset] = 0;\n\tERC20(baseAsset).safeTransfer(owner(), _feeAmount);\n}\n```"}
{"locs": [["code-423n4/2022-06-putty", "3b6b844bc39e897bd0bbb69897f2deff12dc3893", "contracts/src/PuttyV2.sol", "L453-L454"]], "vuln": "Put option sellers can prevent exercise by specifying zero amounts, or non-existant tokens", "severity": "MEDIUM", "mitigation": "Verify the asset amounts and addresses during `fillOrder()`, and allow exercise if the token no longer exists at that point in time"}
{"locs": [["code-423n4/2022-06-putty", "3b6b844bc39e897bd0bbb69897f2deff12dc3893", "contracts/src/PuttyV2.sol", "L573-L584"]], "vuln": "acceptCounterOffer() May Result In Both Orders Being Filled", "severity": "HIGH", "mitigation": "Consider having `cancel()` revert if an order has already been filled. This can be done by adding the following line `require(_ownerOf[uint256(orderHash)] == 0)`."}
{"locs": [["code-423n4/2022-06-putty", "3b6b844bc39e897bd0bbb69897f2deff12dc3893", "contracts/src/PuttyV2.sol", "L435-L437"]], "vuln": "Zero strike call options can be systemically used to steal premium from the taker", "severity": "HIGH", "mitigation": "Consider checking that strike is positive before transfer in all the cases, for example:\n\n```solidity\n            } else {\n+               if (order.strike > 0) {\n                    ERC20(order.baseAsset).safeTransferFrom(msg.sender, address(this), order.strike);\n+               }\n            }\n```"}
{"locs": [["code-423n4/2022-06-putty", "3b6b844bc39e897bd0bbb69897f2deff12dc3893", "contracts/src/PuttyV2.sol", "L343-L346"]], "vuln": "An attacker can create a short put option order on an NFT that does not support ERC721 (like cryptopunk), and the user can fulfill the order, but cannot exercise the option", "severity": "MEDIUM", "mitigation": "Consider adding a whitelist to nfts in the order, or consider supporting exercising on cryptopunk."}
{"locs": [["code-423n4/2022-06-putty", "main", "contracts/src/PuttyV2.sol", "L287"]], "vuln": "Order duration can be set to 0 by Malicious maker", "severity": "MEDIUM", "mitigation": "Enforce atleast x days of duration"}
{"locs": [["code-423n4/2022-06-putty", "3b6b844bc39e897bd0bbb69897f2deff12dc3893", "contracts/src/PuttyV2.sol", "L2"]], "vuln": "Use of Solidity version 0.8.13 which has two known issues applicable to PuttyV2", "severity": "MEDIUM", "mitigation": "Use recent Solidity version 0.8.15 which has the fix for these issues"}
{"locs": [["Plex-Engineer/lending-market-v2", "ea5840de72eab58bec837bb51986ac73712fcfde", "contracts/Stableswap/BaseV1-core.sol", "L72>"]], "vuln": "Oracle `periodSize` is very low allowing the TWAP price to be easily manipulated", "severity": "HIGH", "mitigation": "Increase periodSize to be greater than 0, 1800 is typically standard."}
{"locs": [["Plex-Engineer/lending-market-v2", "ea5840de72eab58bec837bb51986ac73712fcfde", "contracts/Accountant/AccountantDelegate.sol", "L80-L99>"]], "vuln": "AccountantDelegate: The sweepInterest function sweeps an incorrect number of cnote", "severity": "HIGH", "mitigation": "```diff\n\t\tuint amtToSweep = sub_(cNoteAmt, noteDiff); // amount to sweep in Note, \n\t\tuint cNoteToSweep = div_(amtToSweep, exRate); // amount of cNote to sweep = amtToSweep(Note) / exRate\n\n\t\tcNoteToSweep = (cNoteToSweep > cNoteBal) ? cNoteBal :  cNoteToSweep; \n-\t\tbool success = cnote.transfer(treasury, amtToSweep);\n+               bool success = cnote.transfer(treasury, cNoteToSweep);\n\t\tif (!success) {\n-\t\t\trevert  SweepError(treasury , amtToSweep); //handles if transfer of tokens is not successful\n+                       revert  SweepError(treasury , cNoteToSweep); //handles if transfer of tokens is not successful\n\t\t}\n\n\t\tTreasuryInterface Treas = TreasuryInterface(treasury);\n-\t\tTreas.redeem(address(cnote),amtToSweep);\n+               Treas.redeem(address(cnote),cNoteToSweep);\n```"}
{"locs": [["Plex-Engineer/lending-market-v2", "2646a7676b721db8a7754bf5503dcd712eab2f8a", "contracts/NoteInterest.sol", "L99><br>"]], "vuln": "Multiple initialization in `NoteInterest`", "severity": "MEDIUM", "mitigation": "Add a require to check that was not already initialized."}
{"locs": [["code-423n4/2022-06-nibbl", "8c3dbd6adf350f35c58b31723d42117765644110", "contracts/NibblVault.sol", "L443"]], "vuln": "User Could Change The State Of The System While In Pause Mode", "severity": "MEDIUM", "mitigation": "Ensure that the `NibblVault.updateVault` function cannot be called when the system is in `Pause` mode.\n\nAdd the `whenNotPaused` modifier to the function.\n\n```solidity\n/// @notice Updates the TWAV when in buyout\n/// @dev TWAV can be updated only in buyout state\nfunction updateTWAV() external override whenNotPaused {\n    require(status == Status.buyout, \"NibblVault: Status!=Buyout\");\n    uint32 _blockTimestamp = uint32(block.timestamp % 2**32);\n    if (_blockTimestamp != lastBlockTimeStamp) {\n        _updateTWAV(getCurrentValuation(), _blockTimestamp);   \n        _rejectBuyout(); //For the case when TWAV goes up when updated externally\n    }\n}\n```"}
{"locs": [["code-423n4/2022-06-nibbl", "8c3dbd6adf350f35c58b31723d42117765644110", "contracts/Twav/Twav.sol", "L11"]], "vuln": "Ineffective TWAV Implementation", "severity": "MEDIUM", "mitigation": "Implement a proper TWAV that provides the average value of a security over a specified time. The time period/windows of the TWAV must be explicitly defined (e.g. 15 minutes, 1 hour, 24 hours) in the contract.\n\nThere are trade offs when choosing the length of the period of time to calculate a TWAP. Longer periods are better to protect against price manipulation, but come at the expense of a slower, and potentially less accurate, price. Thus, the team should determine the optimal period.\n\nConsider referencing the popular Uniswap V2 TWAP design (https://docs.uniswap.org/protocol/V2/concepts/core-concepts/oracles)"}
{"locs": [["code-423n4/2022-06-nibbl", "main", "contracts/NibblVault.sol", "L195"]], "vuln": "Lack of sanity check on _initialTokenSupply and _initialTokenPrice can lead to a seller losing his NFT", "severity": "MEDIUM", "mitigation": "Add some sanity checks to ensure a sane expected value for `_initialTokenSupply` and `_initialTokenPrice`. There were multiple instances when a user tried to interact with a contract but entered a wrong value because they are not aware they needed to include decimals. A recent example of this is [https://cointelegraph.com/news/1-million-rock-nft-sells-for-a-penny-in-all-ore-nothing-error](https://cointelegraph.com/news/1-million-rock-nft-sells-for-a-penny-in-all-ore-nothing-error).\n\n---\n\n*Note: Normally, I would categorise issues like this as medium severity since it is a loss predicated on having met certain conditions but because there is also a lack of sanity check on `_minBuyoutTime`, it is entirely possible for a seller to lose his NFT immediately once the vault is created. There are many monsters waiting in the dark forest, all it takes is one mistake. That said, I will defer the final judgement to the judges & sponsors.*"}
{"locs": [["code-423n4/2022-06-nibbl", "8c3dbd6adf350f35c58b31723d42117765644110", "contracts/NibblVault.sol", "L314-L323"]], "vuln": "NibblVault: In the buy function, users can avoid paying fees", "severity": "MEDIUM", "mitigation": "The fee for the SecondaryCurve part is complex to charge. I implemented the _caculateFeeSecondaryCurve and _reverseFeeSecondaryCurve functions to do the relevant calculations.\nThe _caculateFeeSecondaryCurve function is used to calculate the value after the fee is charged, but not to actually charge the fee. The _reverseFeeSecondaryCurve function is used to calculate the value before the fee is charged.\n```\n            if (_lowerCurveDiff >= _caculateFeeSecondaryCurve(msg.value)) {\n                _purchaseReturn = _buySecondaryCurve(msg.value, _totalSupply);\n            } else {\n                //Gas Optimization\n                _purchaseReturn = _initialTokenSupply - _totalSupply;\n                secondaryReserveBalance += _lowerCurveDiff;\n                uint256 _amount = _reverseFeeSecondaryCurve(_lowerCurveDiff);\n                _chargeFeeSecondaryCurve(_amount);\n                // _purchaseReturn = _buySecondaryCurve(_to, _lowerCurveDiff);\n                _purchaseReturn += _buyPrimaryCurve(msg.value - _amount, _totalSupply + _purchaseReturn);\n            } \n```\n\n```\n\n    function _caculateFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        uint256 _feeAdmin = (_amount * _adminFeeAmt) / SCALE ;\n        uint256 _feeCurator = (_amount * curatorFee) / SCALE ;\n        return _amount - (_feeAdmin + _feeCurator);\n    }\n    function _reverseFeeSecondaryCurve(uint256 _amount) private returns(uint256) {\n       address payable _factory = factory;\n        uint256 _adminFeeAmt = NibblVaultFactory(_factory).feeAdmin();\n        return _amount * SCALE / (SCALE - (_adminFeeAmt + curatorFee));\n    }\n```"}
{"locs": [["code-423n4/2022-06-nibbl", "8c3dbd6adf350f35c58b31723d42117765644110", "contracts/Twav/Twav.sol", "L36"]], "vuln": "Twav.getTwav() will return a wrong result when twavObservations[TWAVBLOCK_NUMBERS - 1].timestamp = 0.", "severity": "MEDIUM", "mitigation": "I see \"cumulativeValuation\" is increasing all the time and recommend replacing \"timestamp\" with \"cumulativeValuation\".\n```\nif (twavObservations[TWAV_BLOCK_NUMBERS - 1].cumulativeValuation != 0) {\n```"}
{"locs": [["Tokemak/tokemak-smart-contracts-public", "2f54689d5d16ddfd1751493b161a049d6c98c382", "contracts/pools/EthPool.sol", "L94) or also when looking at the deployed code of the [ETH pool](https://etherscan.io/address/0xb104A7fA1041168556218DDb40Fe2516F88246d5#code). Compare that to e.g. the [USDC pool](https://etherscan.io/address/0xca5e07804beef19b6e71b9db18327d215cd58d4e#code), which does not have this parameter."]], "vuln": "No withdrawal possible for ETH TOKE pool", "severity": "HIGH", "mitigation": "Handle the case where the underlying asset is WETH / ETH separately and pass this boolean in that case."}
{"locs": [["code-423n4/2022-06-yieldy", "8400e637d9259b7917bde259a5a2fbbeb5946d45", "src/contracts/Yieldy.sol", "L212)"]], "vuln": "Unsecure `transferFrom`", "severity": "MEDIUM", "mitigation": "*   Check that the from account has a `creditAmount` balance."}
{"locs": [["code-423n4/2022-06-yieldy", "main", "src/contracts/Yieldy.sol", "L91>"]], "vuln": "Incorrect rebase percentage calculation", "severity": "MEDIUM", "mitigation": "Use below:\n\n```\nif (updatedTotalSupply > MAX_SUPPLY) {\n_profit=_profit - (updatedTotalSupply-MAX_SUPPLY);\n                updatedTotalSupply = MAX_SUPPLY;\n\t\t\t\t\n            }\n```"}
{"locs": [["code-423n4/2022-06-yieldy", "524f3b83522125fb7d4677fa7a7e5ba5a2c0fe67", "src/contracts/Staking.sol", "L701-L719>"]], "vuln": "Staking: rebase() does not rebase according to the status of the current epoch.", "severity": "MEDIUM", "mitigation": "Put `IYieldy(YIELDY_TOKEN).rebase` after epoch.distribute update\n\n        function rebase() public {\n            // we know about the issues surrounding block.timestamp, using it here will not cause any problems\n            if (epoch.endTime <= block.timestamp) {\n                uint256 balance = contractBalance();\n                uint256 staked = IYieldy(YIELDY_TOKEN).totalSupply();\n\n                if (balance <= staked) {\n                    epoch.distribute = 0;\n                } else {\n                    epoch.distribute = balance - staked;\n                }\n                IYieldy(YIELDY_TOKEN).rebase(epoch.distribute, epoch.number);\n\n                epoch.endTime = epoch.endTime + epoch.duration;\n                epoch.timestamp = block.timestamp;\n                epoch.number++;\n            }\n        }"}
{"locs": [["code-423n4/2022-06-illuminate", "main", "lender/Lender.sol", "L465:#L469) is how the `lend` method calculates the amount of iPT tokens to mint:"]], "vuln": "Tempus lend method wrongly calculates amount of iPT tokens to mint", "severity": "HIGH", "mitigation": "I believe that what you intended to do is to check how many Tempus principal tokens the contract received.\n\nSo you need to check Lender's `x.tempusPool().principalShare()` before and after the swap, and the delta is the amount received."}
{"locs": [["code-423n4/2022-06-illuminate", "main", "redeemer/Redeemer.sol", "L253:#L262) is how Sense market is being redeemed:"]], "vuln": "Redeem Sense can be bricked", "severity": "HIGH", "mitigation": "I think you should either use a whitelisted Sense address, or send to `ISense(d).redeem` Redeemer's whole principal balance."}
{"locs": [["code-423n4/2022-06-illuminate", "main", "marketplace/ERC5095.sol", "L100) and [`redeem`](https://github.com/code-423n4/2022-06-illuminate/blob/main/marketplace/ERC5095.sol#L116) functions check that the msg.sender has enough approvals to redeem the tokens:"]], "vuln": "ERC5095 redeem/withdraw does not update allowances", "severity": "HIGH", "mitigation": "Update the allowances upon spending."}
{"locs": [["code-423n4/2022-06-illuminate", "main", "lender/Lender.sol", "L172) whether the supplied market is paused."]], "vuln": "Lender: no check for paused market on mint", "severity": "HIGH", "mitigation": "Check in `mint` that the market is not paused."}
{"locs": [["code-423n4/2022-06-illuminate", "912be2a90ded4a557f121fe565d12ec48d0c4684", "lender/Lender.sol", "L247-L305>"]], "vuln": "Easily bypassing admins 'pause' for swivel", "severity": "MEDIUM", "mitigation": "Add this check at the beginning of the function (just like in similar functions of this solution)\n`        if (p != uint8(MarketPlace.Principals.Swivel)) {\n            revert Invalid('principal');\n        } `"}
{"locs": [["infinitydotxyz/exchange-contracts-v2", "c51b7e8af6f95cc0a3b5489369cbc7cee060434b", "contracts/core/InfinityOrderBookComplication.sol", "L192) `areNumItemsValid()`, there is a wrong checking will lead to wrong logic in `matchOrders()` function."]], "vuln": "Sellers may lose NFTs when orders are matched with `matchOrders()`", "severity": "HIGH", "mitigation": "Replace check `buy.constraints[0] <= sell.constraints[0]` with `numConstructedItems <= sell.constraints[0]`"}
{"locs": [["Plex-Engineer/lending-market", "755424c1f9ab3f9f0408443e6606f94e4f08a990", "contracts/NoteInterest.sol", "L118-L129>"]], "vuln": "Anyone can set the `baseRatePerYear` after the `updateFrequency` has passed", "severity": "HIGH", "mitigation": "I have trouble understanding the intention of this function. It appears that the rate should only be able to be set by the admin, so the `_setBaseRatePerYear()` function seems sufficient. Otherwise, add access control for only trusted parties."}
{"locs": [["Plex-Engineer/lending-market", "755424c1f9ab3f9f0408443e6606f94e4f08a990", "contracts/WETH.sol", "L85>"]], "vuln": "Stealing Wrapped Manifest in WETH.sol", "severity": "HIGH", "mitigation": "I believe there is no need for this function. There is another approve(address guy, uint wad) function that uses msg.sender to approve allowance. There should be no need for someone to approve another user's allowance.\n\nRemove the approve(address owner, address spender) function."}
{"locs": [["Plex-Engineer/zeroswap", "03507a80322112f4f3c723fc68bed0f138702836", "contracts/uniswapv2/libraries/UniswapV2Library.sol", "L20-L28><br>"]], "vuln": "`zeroswap/UniswapV2Library.sol` Wrong init code hash in `UniswapV2Library.pairFor()` will break `UniswapV2Oracle`, `UniswapV2Router02`, `SushiRoll`", "severity": "HIGH", "mitigation": "Update the init code hash from `hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303'` to the value of `UniswapV2Factory.pairCodeHash()`."}
{"locs": [["Plex-Engineer/lending-market", "ab31a612be354e252d72faead63d86b844172761", "contracts/WETH.sol", "L47>"]], "vuln": "WETH.sol computes the wrong `totalSupply()`", "severity": "HIGH", "mitigation": "```jsx\nfunction totalSupply() public view returns (uint) {\n    return address(this).balance\n}\n```"}
{"locs": [["Plex-Engineer/lending-market", "ab31a612be354e252d72faead63d86b844172761", "contracts/WETH.sol", "L104>"]], "vuln": "`WETH.allowance()` returns wrong result", "severity": "HIGH", "mitigation": "L104 should be changed like below.\n\n    return _allowance[owner][spender];"}
{"locs": [["Plex-Engineer/lending-market", "755424c1f9ab3f9f0408443e6606f94e4f08a990", "contracts/Accountant/AccountantDelegate.sol", "L20>"]], "vuln": "Missing zero address check can set treasury to zero address", "severity": "MEDIUM", "mitigation": "Add a require() check for zero address for the treasury parameter before changing the treasury address in the initialize function."}
{"locs": [["Plex-Engineer/lending-market", "755424c1f9ab3f9f0408443e6606f94e4f08a990", "contracts/Governance/GovernorBravoDelegate.sol", "L115>"]], "vuln": "Only the `state()` of the latest proposal can be checked", "severity": "MEDIUM", "mitigation": "Change above function to `proposalCount <= proposalId` (assuming `proposalId` is set linearly, which currently is not enforced by code)."}
{"locs": [["Plex-Engineer/lending-market", "755424c1f9ab3f9f0408443e6606f94e4f08a990", "contracts/CNote.sol", "L129><br>"]], "vuln": "Incorrect amount taken", "severity": "MEDIUM", "mitigation": "Revise CNote.sol#L129 to below:\n\n    uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);"}
{"locs": [["Plex-Engineer/zeroswap", "03507a80322112f4f3c723fc68bed0f138702836", "contracts/Migrator.sol", "L28-L46>"]], "vuln": "`zeroswap/UniswapV2Pair.sol` Token reserves per lp token can be manipulated due to lack of `MINIMUM_LIQUIDITY` when minting the first liquidity with `migrator`", "severity": "MEDIUM", "mitigation": "Given the fact that zeroswap will be a DEX that does not need a feature to migrate liquidity from other DEXs, consider removing the migrator."}
{"locs": [["Plex-Engineer/lending-market", "755424c1f9ab3f9f0408443e6606f94e4f08a990", "contracts/Governance/GovernorBravoDelegate.sol", "L135><br>"]], "vuln": "Incorrect condition always bound to fail", "severity": "MEDIUM", "mitigation": "Remove initialProposalId = proposalCount; in the `_initiate` function."}
{"locs": [["Plex-Engineer/lending-market", "ab31a612be354e252d72faead63d86b844172761", "contracts/CNote.sol", "L14>"]], "vuln": "In `Cnote.sol`, anyone can initially become both accountant and admin", "severity": "MEDIUM", "mitigation": "The function should:\n\n1.  have a guard that regulates access control\n2.  not set the `admin` too, which is dangerous and out of scope"}
{"locs": [["code-423n4/2022-06-connext", "main", "contracts/contracts/core/connext/facets/PortalFacet.sol", "L80-L113)<br>"]], "vuln": "`PortcalFacet.repayAavePortal()` can trigger an underflow of `routerBalances`", "severity": "HIGH", "mitigation": "After the call to `swapFromLocalAssetIfNeededForExactOut()` you should add the following check:\n\n```sol\nif (_local == adopted) {\n  require(routerBalance >= amountIn);\n}\n```"}
{"locs": [["code-423n4/2022-06-connext", "b4532655071566b33c41eac46e75be29b4a381ed", "contracts/contracts/core/connext/libraries/SwapUtils.sol", "L1053-L1062)<br>"]], "vuln": "Wrong implementation of `withdrawAdminFees()` can cause the `adminFees` to be charged multiple times and therefore cause users' fund loss", "severity": "HIGH", "mitigation": "Change to:\n\n```solidity\nfunction withdrawAdminFees(Swap storage self, address to) internal {\n  IERC20[] memory pooledTokens = self.pooledTokens;\n  for (uint256 i = 0; i < pooledTokens.length; i++) {\n    IERC20 token = pooledTokens[i];\n    uint256 balance = self.adminFees[i];\n    if (balance != 0) {\n      self.adminFees[i] = 0;\n      token.safeTransfer(to, balance);\n    }\n  }\n}\n```"}
{"locs": [["code-423n4/2022-06-connext", "4dd6149748b635f95460d4c3924c7e3fb6716967", "contracts/contracts/core/connext/facets/BridgeFacet.sol", "L636)<br>"]], "vuln": "Malicious Relayers Could Favor Their Routers", "severity": "MEDIUM", "mitigation": "It is recommended to devise a way for the Connext's destination bridge to verify that the execute calldata received from the relayer is valid and has not been altered. Ideally, the hash of the original execute calldata sent by seqencer should be compared with the hash of the execute calldata received from relayer so that a mismatch would indicate that the calldata has been modified along the way, and some action should be taken.\n\nFor instance, consider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer's address and this will be detected by 0x's Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.\n\nPer good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.\n\nFor instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.\n\n##"}
{"locs": [["code-423n4/2022-06-connext", "b4532655071566b33c41eac46e75be29b4a381ed", "contracts/contracts/core/connext/facets/StableSwapFacet.sol", "L279-L286)<br>"]], "vuln": "Missing `whenNotPaused` modifier", "severity": "MEDIUM", "mitigation": "Add the `whenNotPaused` modifier to all functions that perform swaps or liquidity additions."}
{"locs": [["code-423n4/2022-06-connext", "4dd6149748b635f95460d4c3924c7e3fb6716967", "contracts/contracts/core/connext/facets/BridgeFacet.sol", "L819)<br>"]], "vuln": "Single Error Within `SponsorVault` Contract Could Cause Entire Cross-Chain Communication To Break Down", "severity": "MEDIUM", "mitigation": "This is a problem commonly encountered whenever a method of a smart contract calls another contract \u2013 we cannot rely on the other contract to work 100% of the time, and it is dangerous to assume that the external call will always be successful. Additionally, external smart contract might be vulnerable and compromised by an attacker. Even if the team has audited or review the SponsorVault before whitelisting them, some risk might still exist.\n\nTherefore, it is recommended to implement a fail-safe design where failure of an external call to SponsorVault will not disrupt the cross-chain communication. Consider implementing a try-catch block as shown below. If there is any issue with the external ` SponsorVault  ` contract, no funds are reimbursed to the users in the worst case scenario, but the issue will not cause any impact to the cross-chain communication.\n\n```diff\nfunction _handleExecuteTransaction(\n\tExecuteArgs calldata _args,\n\tuint256 _amount,\n\taddress _asset, // adopted (or local if specified)\n\tbytes32 _transferId,\n\tbool _reconciled\n) private returns (uint256) {\n\t// If the domain if sponsored\n\tif (address(s.sponsorVault) != address(0)) {\n\t  // fast liquidity path\n\t  if (!_reconciled) {\n\t\t// Vault will return the amount of the fee they sponsored in the native fee\n\t\t// NOTE: some considerations here around fee on transfer tokens and ensuring\n\t\t// there are no malicious `Vaults` that do not transfer the correct amount. Should likely do a\n\t\t// balance read about it\n\n\t\tuint256 starting = IERC20(_asset).balanceOf(address(this));\n+\t\ttry s.sponsorVault.reimburseLiquidityFees(_asset, _args.amount, _args.params.to) returns (uint256 sponsored) {\n+\t\t\t// Validate correct amounts are transferred\n+\t\t\tif (IERC20(_asset).balanceOf(address(this)) != starting + sponsored) {\n+\t\t\t  revert BridgeFacet__handleExecuteTransaction_invalidSponsoredAmount();\n+\t\t\t}\n+\n+\t\t\t_amount = _amount + sponsored;\n+\t\t} catch {}\n\t  }\n\n\t  // Should dust the recipient with the lesser of a vault-defined cap or the converted relayer fee\n\t  // If there is no conversion available (i.e. no oracles for origin domain asset <> dest asset pair),\n\t  // then the vault should just pay out the configured constant\n+\t  try s.sponsorVault.reimburseRelayerFees(_args.params.originDomain, payable(_args.params.to), _args.params.relayerFee) {} catch {}\n\t..SNIP..\n```"}
{"locs": [["code-423n4/2022-06-connext", "b4532655071566b33c41eac46e75be29b4a381ed", "contracts/contracts/core/promise/PromiseRouter.sol", "L226-L262)<br>"]], "vuln": "Attacker can perform griefing for `process()` in `PromiseRouter` by reverting calls to `callback()` in `callbackAddress`", "severity": "MEDIUM", "mitigation": "Change the code so it won't revert if call to `callbackAddress` reverts."}
{"locs": [["code-423n4/2022-06-connext", "b4532655071566b33c41eac46e75be29b4a381ed", "contracts/contracts/core/connext/helpers/SponsorVault.sol", "L187-L220)<br>"]], "vuln": "In `reimburseLiquidityFees()` of `SponserVault` contract swaps tokens without slippage limit so its possible to perform sandwich attack and it create MEV", "severity": "MEDIUM", "mitigation": "Specify slippage when calling swap tokens."}
{"locs": [["code-423n4/2022-06-notional-coop", "6f8c325f604e2576e2fe257b6b57892ca181509a", "index-coop-notional-trade-module/contracts/protocol/modules/v1/NotionalTradeModule.sol", "L526>"]], "vuln": "Silent overflow of `_fCashAmount`", "severity": "MEDIUM", "mitigation": "```solidity\n// Use a safe downcast function e.g. wfCashLogic::_safeUint88\nfunction _safeUint88(uint256 x) internal pure returns (uint88) {hil\n    require(x <= uint256(type(uint88).max));\n    return uint88(x);\n}\n```"}
{"locs": [["code-423n4/2022-05-backd", "2a5664d35cde5b036074edef3c1369b984d10010", "protocol/contracts/tokenomics/KeeperGauge.sol", "L88) are increased, then, because [`keeperRecords[beneficiary].nextEpochToClaim`](https://github.com/code-423n4/2022-05-backd/blob/2a5664d35cde5b036074edef3c1369b984d10010/protocol/contracts/tokenomics/KeeperGauge.sol#L136`) will include the empty epoch, the `beneficiary` will not be able to receive fees."]], "vuln": "DoS on KeeperGauge due to division by zero", "severity": "MEDIUM", "mitigation": "Generate a behavior for the case that perPeriodTotalFees\\[i] == 0."}
{"locs": [["code-423n4/2022-05-backd", "2a5664d35cde5b036074edef3c1369b984d10010", "protocol/contracts/BkdLocker.sol", "L53-L64"]], "vuln": "it\u2019s possible to initialize contract BkdLocker for multiple times by sending startBoost=0 and each time different values for other parameters", "severity": "MEDIUM", "mitigation": "add some other variable to check the status of initialization of contract."}
{"locs": [["code-423n4/2022-05-vetoken", "2d7cd1f6780a9bcc8387dea8fecfbd758462c152", "README.md", "L20) does include BAL and for that reason I think the finding is Valid and of Medium Severity."]], "vuln": "VE3DRewardPool.sol is incompatible with Bal/veBal", "severity": "MEDIUM", "mitigation": "Exclude veBal/Bal as a supported asset or create a special wrapper for Bal that adds the Bal as one sided liquidity then stakes the LP."}
{"locs": [["code-423n4/2022-05-vetoken", "2d7cd1f6780a9bcc8387dea8fecfbd758462c152", "contracts/VeTokenMinter.sol", "L77-L81>"]], "vuln": "compromised `owner` can drain funds from`VeTokenMinter.sol`", "severity": "MEDIUM", "mitigation": "Consider implementing a timelock on `VeTokenMinter.withdraw()` and changing the `destination` to an address that `owner` has no control over.\n\nExample of similar issues illustrating the severity of the finding can be found [here (H-09)](https://code4rena.com/reports/2022-01-insure)."}
{"locs": [["AngleProtocol/angle-core", "main", "contracts/staking/LiquidityGaugeV4UpgradedToken.vy), gauge contracts are upgradable, so interfaces and underlying LP tokens are subject to change, blocking and freezing the system. Note that this is not hypothetic as it happened a few weeks ago: see this [snapshot vote](https://snapshot.org/", "/anglegovernance.eth/proposal/0x1adb0a958220b3dcb54d2cb426ca19110486a598a41a75b3b37c51bfbd299513). Therefore, the system should be robust to a change in the pair gauge / token."]], "vuln": "Contracts should be robust to upgrades of underlying gauges and eventually changes of the underlying tokens", "severity": "MEDIUM", "mitigation": "To deal with upgradeable contracts, either the `VoterProxy` needs to be upgradable to deal with any situation that may arise, either you need to add upgradeable \u201cintermediate\u201d contracts between the `staker` and the gauge that could be changed to preserve the logic."}
{"locs": [["code-423n4/2022-05-rubicon", "521d50b22b41b1f52ff9a67ea68ed8012c618da9", "contracts/rubiconPools/BathToken.sol", "L199-L210"]], "vuln": "Wrong DOMAIN_SEPARATOR", "severity": "MEDIUM", "mitigation": "- Set the `name` before use it."}
{"locs": [["code-423n4/2022-05-rubicon", "8c312a63a91193c6a192a9aab44ff980fbfd7741", "contracts/RubiconRouter.sol", "L383-L409"]], "vuln": "RubiconRouter: Offers created through offerWithETH() can be cancelled by anyone", "severity": "HIGH", "mitigation": "Set the owner of offer_id to msg.sender in offerWithETH function and check it in cancelForETH function"}
{"locs": [["code-423n4/2022-05-rubicon", "8c312a63a91193c6a192a9aab44ff980fbfd7741", "contracts/RubiconRouter.sol", "L412-L437"]], "vuln": "RubiconRouter: Offers created through offerForETH cannot be cancelled", "severity": "HIGH", "mitigation": "Implement cancelForERC function to cancel this offer. And set the owner of offer_id to msg.sender in offerForETH function and check it in cancelForERC function"}
{"locs": [["code-423n4/2022-05-rubicon", "8c312a63a91193c6a192a9aab44ff980fbfd7741", "contracts/rubiconPools/BathToken.sol", "L629"]], "vuln": "BathToken LPs Unable To Receive Bonus Token Due To Lack Of Wallet Setter Method", "severity": "HIGH", "mitigation": "Implement a setter method for the `rewardsVestingWallet` state variable in the contracts so that it can be initialised with BathBuddy Vesting Wallet address."}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/RubiconRouter.sol", "L229:#L244"]], "vuln": "RubiconRouter _swap does not pass whole amount to RubiconMarket", "severity": "HIGH", "mitigation": "Change the parameter to the abovementioned one."}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/RubiconRouter.sol", "L267_L287"]], "vuln": "RubiconRouter.swapEntireBalance() doesn\u2019t handle the slippage check properly", "severity": "HIGH", "mitigation": "pass `buy_amt_min` directly to `_swap()`"}
{"locs": [["code-423n4/2022-05-rubicon", "8c312a63a91193c6a192a9aab44ff980fbfd7741", "contracts/RubiconRouter.sol", "L325-L339"]], "vuln": "RubiconRouter: Excess ether did not return to the user", "severity": "MEDIUM", "mitigation": "Return excess ether to msg.sender, or require msg.value == max_fill_withFee/pay_amt/amount/amtWithFee"}
{"locs": [["code-423n4/2022-05-rubicon", "8c312a63a91193c6a192a9aab44ff980fbfd7741", "contracts/rubiconPools/BathToken.sol", "L557"]], "vuln": "Inconsistent Order Book Accounting When Working With Transfer-On-Fee or Deflationary Tokens", "severity": "MEDIUM", "mitigation": "In the `offer` function, get the actual received amount by calculating the difference of token balance before and after the transfer, and set the `info.pay_amt` to the actual received amount.\n\nAlternatively, the team might want to consider implementing whitelisting mechanism so that deflationary tokens will not be supported if the risk of allowing permissionless creation of pool with arbitrary token deems to be significant. A DAO may be formed in the future to manage the whitelisting."}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/peripheral_contracts/BathBuddy.sol", "L69"]], "vuln": "BathBuddy locks up Ether it receives", "severity": "MEDIUM", "mitigation": "Remove the `receive()` function if the contract isn't supposed to handle ETH. Otherwise, add the necessary logic to release the ETH it gets."}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/rubiconPools/BathToken.sol", "L499"]], "vuln": "previewWithdraw calculates shares wrongly", "severity": "MEDIUM", "mitigation": "The amount of shares that `previewWithdraw` should return is:\n`convertToShares(assets.add(assets.mul(feeBPS).div((10000.sub(feeBPS))))`\nI prove this mathematically in [this](https://i.ibb.co/hX41vzV/c4wd.jpg) image."}
{"locs": [["code-423n4/2022-05-rubicon", "521d50b22b41b1f52ff9a67ea68ed8012c618da9", "contracts/rubiconPools/BathToken.sol", "L346-L369"]], "vuln": "Centralized risks allows rogue pool behavior in BathToken.", "severity": "MEDIUM", "mitigation": "- Use timeLock, or avoid admin accounts."}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/rubiconPools/BathPair.sol", "L324"]], "vuln": "Strategist can transfer user funds to themselves", "severity": "MEDIUM", "mitigation": "There's no easy way to fix this since it's a big part of the protocol. You'd have to overhaul the whole thing.\n\nYou could minimize the dmg by limiting the amount of funds a strategist has access to"}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/rubiconPools/BathHouse.sol", "L264"]], "vuln": "Strategists can\u2019t be removed", "severity": "MEDIUM", "mitigation": "Add a function / change the function and allow setting strategist's access to false."}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/RubiconRouter.sol", "L519"]], "vuln": "User will loose funds", "severity": "MEDIUM", "mitigation": "Add below check \n\n```\nrequire(route.length>1, \"Invalid route param\");\n```"}
{"locs": [["code-423n4/2022-05-rubicon", "main", "contracts/RubiconMarket.sol", "L664-L669"]], "vuln": "Deprecated variables may cause DoS", "severity": "MEDIUM", "mitigation": "Delete deprecated code, but reserve variable declaration for slots if using upgradable contracts."}
{"locs": [["code-423n4/2022-05-rubicon", "8c312a63a91193c6a192a9aab44ff980fbfd7741", "contracts/RubiconRouter.sol", "L307"]], "vuln": "RubiconRouter maxSellAllAmount does not transfer user\u2019s fund into its address, causing calls to always revert", "severity": "MEDIUM", "mitigation": "Add a transfer of fund to the function\n```solidity\n    /// @dev this function takes a user's entire balance for the trade in case they want to do a max trade so there's no leftover dust\n    function maxSellAllAmount(\n        ERC20 pay_gem,\n        ERC20 buy_gem,\n        uint256 min_fill_amount\n    ) external returns (uint256 fill) {\n        //swaps msg.sender entire balance in the trade\n        uint256 maxAmount = ERC20(buy_gem).balanceOf(msg.sender);\n        ERC20(buy_gem).safeTransferFrom(msg.sender, address(this), maxAmount);\n        fill = RubiconMarket(RubiconMarketAddress).sellAllAmount(\n            pay_gem,\n            maxAmount,\n            buy_gem,\n            min_fill_amount\n        );\n        ERC20(buy_gem).transfer(msg.sender, fill);\n    }\n```"}
{"locs": [["code-423n4/2022-05-velodrome", "7fda97c570b758bbfa7dd6724a336c43d4041740", "contracts/contracts/VeloGovernor.sol", "L44-L48)<br>"]], "vuln": "`VeloGovernor`: `proposalNumerator` and team are updated by team, not governance", "severity": "MEDIUM", "mitigation": "Allow governance to call setProposalNumerator and setTeam functions."}
{"locs": [["code-423n4/2022-05-velodrome", "main", "contracts/contracts/redeem/RedemptionSender.sol", "L43)<br>"]], "vuln": "`RedemptionSender` should estimate fees to prevent failed transactions", "severity": "MEDIUM", "mitigation": "Use the `estimateFees()` endpoint."}
{"locs": [["code-423n4/2022-05-velodrome", "7fda97c570b758bbfa7dd6724a336c43d4041740", "contracts/contracts/Gauge.sol", "L548-L561)<br>"]], "vuln": "Rewards aren't updated before user's balance change in Gauge's `withdrawToken`", "severity": "MEDIUM", "mitigation": "Consider moving rewards update to withdrawToken(), since it is called by withdraw() anyway:\n\n```solidity\n    function withdraw(uint amount) public {\n-       _updateRewardForAllTokens();\n\n        uint tokenId = 0;\n        if (amount == balanceOf[msg.sender]) {\n            tokenId = tokenIds[msg.sender];\n        }\n        withdrawToken(amount, tokenId);\n    }\n\n    function withdrawToken(uint amount, uint tokenId) public lock {\n+    \t_updateRewardForAllTokens();\n\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n```\n\nOr, if the intent is to keep withdrawToken() as is, consider making it private, so no direct usage be possible:\n\n```solidity\n\n-    function withdrawToken(uint amount, uint tokenId) public lock {\n+    function withdrawToken(uint amount, uint tokenId) private lock {\n\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;\n        _safeTransfer(stake, msg.sender, amount);\n```"}
{"locs": [["code-423n4/2022-05-velodrome", "7fda97c570b758bbfa7dd6724a336c43d4041740", "contracts/contracts/Voter.sol", "L315-L329)<br>"]], "vuln": "Rewards can be locked in Bribe contract because distributing them depends on base token reward amount and `Gauge.deliverBribes()` is not always called by `Voter.distribute()`", "severity": "MEDIUM", "mitigation": "Move the line `IGauge(_gauge).deliverBribes();` out of `If` in `Voter.distribute()`."}
{"locs": [["code-423n4/2022-05-velodrome", "7fda97c570b758bbfa7dd6724a336c43d4041740", "contracts/contracts/Bribe.sol", "L83-L90)<br>"]], "vuln": "Wrong reward distribution in Bribe because `deliverReward()` won't set `tokenRewardsPerEpoch[token][epochStart]` to 0", "severity": "MEDIUM", "mitigation": "Set `tokenRewardsPerEpoch[token][epochStart]` to `0` in `deliverReward`."}
{"locs": [["code-423n4/2022-05-sturdy", "78f51a7a74ebe8adfd055bdbaedfddc05632566f", "smart-contracts/LidoVault.sol", "L142)<br>"]], "vuln": "The check for value transfer success is made after the return statement in `_withdrawFromYieldPool` of `LidoVault`", "severity": "HIGH", "mitigation": "Return the function after the success check"}
{"locs": [["code-423n4/2022-05-sturdy", "78f51a7a74ebe8adfd055bdbaedfddc05632566f", "smart-contracts/YieldManager.sol", "L48), `UNISWAP_FEE` is hardcoded, which reduce significantly the possibilities and will lead to non optimal routes. In particular, all swaps using ETH path will use the wrong pool as it will use the ETH / USDC 1% one due to this [line](https://github.com/sturdyfi/code4rena-may-2022/blob/d53f4f5f0b7b33a66e0081294be6117f6d6e17b4/contracts/protocol/libraries/swap/UniswapAdapter.sol#L50)."]], "vuln": "`UNISWAP_FEE` is hardcoded which will lead to significant losses compared to optimal routing", "severity": "MEDIUM", "mitigation": "Basic mitigation would be to hardcode in advance the best Uniswap paths in a mapping like it\u2019s done for Curve pools, then pass this path already computed to the swapping library. This would allow for complex route and save gas costs as you would avoid computing them in `swapExactTokensForTokens`.\n\nThen, speaking from experience, as `distributeYield` is `onlyAdmin`, you may want to add the possibility to do the swaps through an efficient aggregator like 1Inch or Paraswap, it will be way more optimal."}
{"locs": [["code-423n4/2022-05-aura", "main", "contracts/ExtraRewardsDistributor.sol", "L127)<br>"]], "vuln": "User can forfeit other user rewards", "severity": "HIGH", "mitigation": "Do not allow users to call getReward function for other users."}
{"locs": [["code-423n4/2022-05-aura", "main", "contracts/AuraLocker.sol", "L396:#L405) is the section that calculates the kick reward if all locks have expired:"]], "vuln": "`AuraLocker` kick reward only takes last locked amount into consideration, instead of whole balance", "severity": "MEDIUM", "mitigation": "Change the last line in the code above to:\n\n                    reward = uint256(locked).mul(rRate).div(denominator);\n\nThis will keep the low gas consumption of this flow, while giving a more accurate result."}
{"locs": [["code-423n4/2022-05-aura", "4989a2077546a5394e3650bf3c224669a0f7e690", "contracts/ExtraRewardsDistributor.sol", "L74)"]], "vuln": "Users can grief reward distribution", "severity": "MEDIUM", "mitigation": "Allow the backdating of rewards, which will cost more gas"}
{"locs": [["code-423n4/2022-05-aura", "main", "contracts/AuraVestedEscrow.sol", "L96)<br>"]], "vuln": "Reward can be vested even after endTime", "severity": "MEDIUM", "mitigation": "Add below check\n\n    require(block.timestamp<=endTime, \"Reward vesting period over\");"}
{"locs": [["code-423n4/2022-05-aura", "4989a2077546a5394e3650bf3c224669a0f7e690", "contracts/AuraLocker.sol", "L258-L295)<br>"]], "vuln": "Increase voting power by tokenizing the address that locks the token", "severity": "MEDIUM", "mitigation": "It would be best to check whether the locker is the smart contract or the wallet and, if the protocol wants the smart contract to be the locker, it can implement the whitelist or blacklist."}
{"locs": [["code-423n4/2022-05-aura", "main", "contracts/AuraClaimZap.sol", "L224-L226)<br>"]], "vuln": "User will lose funds", "severity": "MEDIUM", "mitigation": "The condition should check if user has enabled lock for cvx, otherwise cvx should not be transferred from user\n\n    if (depositCvxMaxAmount > 0 && _checkOption(options, uint256(Options.LockCvx))) {\n              uint256 cvxBalance = IERC20(cvx).balanceOf(msg.sender).sub(removeCvxBalance);\n              cvxBalance = AuraMath.min(cvxBalance, depositCvxMaxAmount);\n              if (cvxBalance > 0) {\n                  //pull cvx\n                  IERC20(cvx).safeTransferFrom(msg.sender, address(this), cvxBalance);\n\n                      IAuraLocker(locker).lock(msg.sender, cvxBalance);\n              }\n          }"}
{"locs": [["code-423n4/2022-05-aura", "4989a2077546a5394e3650bf3c224669a0f7e690", "convex-platform/contracts/contracts/ConvexMasterChef.sol", "L299-L306)"]], "vuln": "`ConvexMasterChef`: `safeRewardTransfer` can cause loss of funds", "severity": "MEDIUM", "mitigation": "Use usual safeTransfer instead of safeRewardTransfer."}
{"locs": [["code-423n4/2022-05-aura", "main", "convex-platform/contracts/contracts/ConvexMasterChef.sol", "L178-L183)<br>"]], "vuln": "`massUpdatePools()` is susceptible to DoS with block gas limit", "severity": "MEDIUM", "mitigation": "I suggest to limit the max number of loop iterations to prevent hitting block gas limit."}
{"locs": [["code-423n4/2022-05-aura", "4989a2077546a5394e3650bf3c224669a0f7e690", "convex-platform/contracts/contracts/ConvexMasterChef.sol", "L96-L138)<br>"]], "vuln": " `ConvexMasterChef`: When using `add()` and `set()`, it should always call `massUpdatePools()` to update all pools", "severity": "MEDIUM", "mitigation": "Removing the \\_withUpdate variable in the add() and set() functions and always calling the massUpdatePools() function before updating totalAllocPoint variable."}
{"locs": [["code-423n4/2022-05-aura", "main", "convex-platform/contracts/contracts/ConvexMasterChef.sol", "L96)<br>"]], "vuln": "Duplicate LP token could lead to incorrect reward distribution", "severity": "MEDIUM", "mitigation": "Add a global variable keeping track of all lpToken added for pool. In case of duplicate lpToken add function should fail."}
{"locs": [["code-423n4/2022-05-cally", "main", "contracts/src/Cally.sol", "L198-L200>"]], "vuln": "no-revert-on-transfer ERC20 tokens can be drained", "severity": "HIGH", "mitigation": "I think the easiest solution is to use `safeTransferFrom()` when the token is of type ERC721. Since the transfer is at the end of the function there shouldn't be any risk of reentrancy. If someone passes an ERC20 address with type ERC721, the `safeTransferFrom()` call would simply fail since that function signature shouldn't exist on ERC20 tokens."}
{"locs": [["code-423n4/2022-05-cally", "1849f9ee12434038aa80753266ce6a2f2b082c59", "contracts/src/Cally.sol", "L288-L289>"]], "vuln": "Owner can set the feeRate to be greater than 100% and cause all future calls to `exercise` to revert", "severity": "MEDIUM", "mitigation": "Add reasonable fee rate bounds checks in the `setFee()` function"}
{"locs": [["code-423n4/2022-05-alchemix", "de65c34c7b6e4e94662bf508e214dcbf327984f4", "contracts-full/adapters/yearn/YearnTokenAdapter.sol", "L30-L32)<br>"]], "vuln": "YearnTokenAdapter's wrap can become stuck as it uses one step approval for an arbitrary underlying", "severity": "MEDIUM", "mitigation": "As the most general approach consider approving zero before doing so for the amount:\n\n```solidity\n    function wrap(uint256 amount, address recipient) external override returns (uint256) {\n        TokenUtils.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n+      TokenUtils.safeApprove(underlyingToken, token, 0);\n        TokenUtils.safeApprove(underlyingToken, token, amount);\n```"}
{"locs": [["code-423n4/2022-05-alchemix", "de65c34c7b6e4e94662bf508e214dcbf327984f4", "contracts-full/TransmuterBuffer.sol", "L377-L379)<br>"]], "vuln": "registerAsset misuse can permanently disable TransmuterBuffer and break the system", "severity": "MEDIUM", "mitigation": "The issue is that there is no way to unregister the asset, so consider introducing a function to remove the underlying or simply delete the array so it can be reconstructed with a sequence of registerAsset calls."}
{"locs": [["code-423n4/2022-05-factorydao", "e22a562c01c533b8765229387894cc0cb9bed116", "contracts/SpeedBumpPriceGate.sol", "L65-L82"]], "vuln": "SpeedBumpPriceGate: Excess ether did not return to the user", "severity": "HIGH", "mitigation": "```\n-   function passThruGate(uint index, address) override external payable {\n+  function passThruGate(uint index, address payer) override external payable {\n        uint price = getCost(index);\n        require(msg.value >= price, 'Please send more ETH');\n\n        // bump up the price\n        Gate storage gate = gates[index];\n        // multiply by the price increase factor\n        gate.lastPrice = (price * gate.priceIncreaseFactor) / gate.priceIncreaseDenominator;\n        // move up the reference\n        gate.lastPurchaseBlock = block.number;\n\n        // pass thru the ether\n        if (msg.value > 0) {\n            // use .call so we can send to contracts, for example gnosis safe, re-entrance is not a threat here\n-           (bool sent, bytes memory data) = gate.beneficiary.call{value: msg.value}(\"\");\n+          (bool sent, bytes memory data) = gate.beneficiary.call{value: price}(\"\");\n            require(sent, 'ETH transfer failed');\n        }\n+      if (msg.value - price > 0){ \n+         (bool sent, bytes memory data) = payer.call{value: msg.value - price}(\"\");\n+          require(sent, 'ETH transfer failed');}\n    }\n```"}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/PermissionlessBasicPoolFactory.sol", "L245"]], "vuln": "DoS: Attacker may significantly increase the cost of withdrawExcessRewards() by creating a significant number of excess receipts", "severity": "MEDIUM", "mitigation": "Consider adding a minimum deposit amount for each pool that can be configured by the pool owner.\n\nAlternatively, allow the owner to call `withdrawExcessRewards()` given some other criteria such as \n- A fix period of time (e.g. 1 month) has passed since the end of the auction; and\n- 90% of the deposits have been withdrawn\nThese criteria can be customised as desired by the design team."}
{"locs": [["code-423n4/2022-05-factorydao", "main", "contracts/MerkleVesting.sol", "L173"]], "vuln": "MerkleVesting withdrawal does not verify that tokens were transferred successfully", "severity": "HIGH", "mitigation": "As done throughout the rest of the protocol, add a check that verifies that the transfer has succeeded."}
{"locs": [["code-423n4/2022-05-factorydao", "e22a562c01c533b8765229387894cc0cb9bed116", "contracts/PermissionlessBasicPoolFactory.sol", "L230"]], "vuln": "Malicious token reward could disable withdrawals", "severity": "MEDIUM", "mitigation": "Add an `emergencyWithdraw` function that ignores failed reward token transfers."}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/MerkleDropFactory.sol", "L68-L79"]], "vuln": "MerkleDropFactory.depositTokens()  does not require the tree to exist", "severity": "MEDIUM", "mitigation": "Consider adding the check to ensure `0 < treeIndex <= numTrees` in `depositTokens()`."}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/PermissionlessBasicPoolFactory.sol", "L156-L173"]], "vuln": "getRewards() in PermissionlessBasicPoolFactory calculate wrong reward amount for receiptId==0", "severity": "MEDIUM", "mitigation": "If you want to start from index `1` then add this line too to ensure `receipntId` is not `0` too:\n```\nrequire(receiptId > 0, 'Uninitialized receipt');\n```\nor we could check for uninitialized receipnts with `owner` field as non-zero."}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/MerkleVesting.sol", "L173"]], "vuln": "A transfer that is not validated its result.", "severity": "MEDIUM", "mitigation": "The recommendation is to wrap the transfer with a require, as is done in **MerkleDropFactory.sol** for example."}
{"locs": [["code-423n4/2022-05-factorydao", "e22a562c01c533b8765229387894cc0cb9bed116", "contracts/MerkleDropFactory.sol", "L72-L77"]], "vuln": "Rebasing tokens go to the pool owner, or remain locked in the various contracts", "severity": "MEDIUM", "mitigation": "Provide a function for the pool owner to withdraw excess deposited tokens and repay any associated taxes. In the case of the Merkle trees though, pro rata share amounts need to be calculated and tracked and updated with every withdrawal, which will require drastic changes to the code, making it much more expensive"}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/PermissionlessBasicPoolFactory.sol", "L224-L231"]], "vuln": "Unbounded loop in withdraw() may cause rewards to be locked in the contract", "severity": "MEDIUM", "mitigation": "Allow the specification of an offset and length to the `withdraw()` function, so that withdrawals can be broken up into smaller batches if required"}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/PermissionlessBasicPoolFactory.sol", "L258-L272"]], "vuln": "Pool owners can prevent the payment of taxes", "severity": "MEDIUM", "mitigation": "Force taxes to be paid during `withdraw()`"}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/PermissionlessBasicPoolFactory.sol", "L230-L234"]], "vuln": "Pool owners can prevent withdrawals of specific receipts", "severity": "MEDIUM", "mitigation": "Rather than reverting the whole withdrawal if only one transfer fails, return a boolean of whether all withdrawals were successful, and allow `withdraw()` to be called multiple times, keeping track of what has been transferred and what hasn't"}
{"locs": [["code-423n4/2022-05-factorydao", "e22a562c01c533b8765229387894cc0cb9bed116", "contracts/PermissionlessBasicPoolFactory.sol", "L137-L149"]], "vuln": "amount requires to be updated to contract balance increase (1)", "severity": "MEDIUM", "mitigation": "Recommended code:\n```solidity\nfunction fundPool(uint poolId) internal {\n    Pool storage pool = pools[poolId];\n    bool success = true;\n    uint amount;\n    for (uint i = 0; i < pool.rewardFunding.length; i++) {\n        amount = getMaximumRewards(poolId, i);\n        // transfer the tokens from pool-creator to this contract\n\n        uint256 balanceBefore = IERC20(pool.rewardTokens[i]).balanceOf(address(this)); // remembering asset balance before the transfer\n        IERC20(pool.rewardTokens[i]).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 newAmount = IERC20(pool.rewardTokens[i]).balanceOf(address(this)) - balanceBefore; // updating actual amount to the contract balance increase\n        success = success && newAmount == amount; // making sure amounts match\n\n        // bookkeeping to make sure pools don't share tokens\n        pool.rewardFunding[i] += amount;\n    }\n    require(success, 'Token deposits failed');\n}\n```"}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/MerkleDropFactory.sol", "L94"]], "vuln": "Merkle-tree-related contracts vulnerable to cross-chain-replay attacks", "severity": "MEDIUM", "mitigation": "Add EIP-712 protections and add a mechanism to allow tokens to be transferred to a different address using EIP-2612 `permit()`"}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/PermissionlessBasicPoolFactory.sol", "L261-L272"]], "vuln": "Owner of a pool may prevent any taxes being withdrawn", "severity": "MEDIUM", "mitigation": "There are a few mitigations to this issue.\n\nThe first is for the `withdrawTaxes()` function to take both `poolId` and `rewardIndex` as a parameters to allowing the tax beneficiary to only withdraw from certain reward tokens in the pool. This would allow the beneficiary to withdraw from all reward tokens except malicious ones.\n\nThe second mitigation is to implement a `try-catch` condition around the withdrawal of reward tokens. In the catch statement re-instate the `taxes[poolId][i] = tax` if the transfer fails. Alternatively just skip the reward tokens if the transfer fails though this would be undesirable if a token is paused for some reason."}
{"locs": [["code-423n4/2022-05-factorydao", "db415804c06143d8af6880bc4cda7222e5463c0e", "contracts/PermissionlessBasicPoolFactory.sol", "L314-L318"]], "vuln": "Centralisation Risk: Owner may abuse the tax rate to claim 99.9% of pools", "severity": "MEDIUM", "mitigation": "It is recommended to put some reasonable upper bounds on the tax rate. Consider setting the upper bounds for the tax rate to 5%."}
{"locs": [["code-423n4/2022-05-runes", "main", "contracts/ForgottenRunesWarriorsMinter.sol", "L275-L297)<br>"]], "vuln": "Many unbounded and under-constrained variables in the system can lead to unfair price or DoS", "severity": "MEDIUM", "mitigation": "Possible mitigation:\n\n1.  Bound and constrain variables.<br>\nFor example, daDropInterval should be less than daPriceCurveLength<br>\nAnother example: The total sum of each supply phase should not be bigger than `MAX_SUPPLY` in the NFT smart contract."}
{"locs": [["code-423n4/2022-05-runes", "060b4f82b79c8308fe65674a39a07c44fa586cd3", "contracts/ForgottenRunesWarriorsMinter.sol", "L616-L619)<br>"]], "vuln": "Contract may not have enough fund to cover refund", "severity": "MEDIUM", "mitigation": "Only allow owner to call `withdrawAll` after refund period."}
{"locs": [["code-423n4/2022-05-runes", "main", "contracts/ForgottenRunesWarriorsMinter.sol", "L257)<br>"]], "vuln": "The owner can mint all of the NFTs.", "severity": "MEDIUM", "mitigation": "Limit how many NFTs can the owner mint. So even if the private keys were compromised the attacker couldn't destroy the entire set by minting thousands of the NFTs to himself making the entire set worth nothing.\n\nI also think this will help with the trust of the protocol since the buyers will know exactly how many NFTs can the Dev Team mint for themselves."}
{"locs": [["bunkerfinance/bunker-protocol", "752126094691e7457d08fc62a6a5006df59bd2fe", "contracts/CNft.sol", "L204)<br>"]], "vuln": "`CNft.sol` - revert inside `safeTransferFrom` will break composability & standard behaviour", "severity": "MEDIUM", "mitigation": "Instead of revert, call function safeBatchTransferFrom with 1 item in the array, e.g.,\n\n> safeBatchTransferFrom(from, to, \\[id], \\[amount], data)"}
{"locs": [["bunkerfinance/bunker-protocol", "752126094691e7457d08fc62a6a5006df59bd2fe", "contracts/PriceOracleImplementation.sol", "L29-L30)<br>"]], "vuln": "Chainlink pricer is using a deprecated API", "severity": "MEDIUM", "mitigation": "Use the latestRoundData function to get the price instead. Add checks on the return data with proper revert messages if the price is stale or the round is uncomplete\n<https://docs.chain.link/docs/price-feeds-api-reference/>"}
{"locs": [["code-423n4/2022-05-cudos", "main", "solidity/contracts/Gravity.sol", "L175)<br>"]], "vuln": "The `Gravity.sol` should have pause/unpause functionality", "severity": "MEDIUM", "mitigation": "Pause functionality on the contract would have helped secure the funds quickly."}
{"locs": [["code-423n4/2022-05-cudos", "main", "solidity/contracts/Gravity.sol", "L600)<br>"]], "vuln": "Protocol doesn't handle fee on transfer tokens", "severity": "MEDIUM", "mitigation": "Change to\n\n```solidity\n\tfunction sendToCosmos(\n\t\taddress _tokenContract,\n\t\tbytes32 _destination,\n\t\tuint256 _amount\n\t) public nonReentrant  {\n                uint256 oldBalance = IERC20(_tokenContract).balanceOf(address(this));\n\t\tIERC20(_tokenContract).safeTransferFrom(msg.sender, address(this), _amount);\n                uint256 receivedAmout = IERC20(_tokenContract).balanceOf(address(this)) - oldBalance;\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit SendToCosmosEvent(\n\t\t\t_tokenContract,\n\t\t\tmsg.sender,\n\t\t\t_destination,\n\t\t\treceivedAmout,\n\t\t\tstate_lastEventNonce\n\t\t);\n\t}\n```"}
{"locs": [["pooltogether/aave-v3-yield-source", "e63d1b0e396a5bce89f093630c282ca1c6627e44", "contracts/AaveV3YieldSource.sol", "L231-L242)<br>"]], "vuln": "`_depositAmount` requires to be updated to contract balance increase", "severity": "MEDIUM", "mitigation": "Recommended code:<br>\nfunction supplyTokenTo(uint256 \\_depositAmount, address \\_to) external override nonReentrant {<br>\nuint256 \\_shares = \\_tokenToShares(\\_depositAmount);<br>\nrequire(\\_shares > 0, \"AaveV3YS/shares-gt-zero\");<br>\n\n    address _underlyingAssetAddress = _tokenAddress();\n\n    uint256 balanceBefore = IERC20(_underlyingAssetAddress).balanceOf(address(this)); // remembering asset balance before the transfer\n    IERC20(_underlyingAssetAddress).safeTransferFrom(msg.sender, address(this), _depositAmount);\n    _depositAmount = IERC20(_underlyingAssetAddress).balanceOf(address(this)) - balanceBefore; // updating actual amount to the contract balance increase\n\n    _pool().supply(_underlyingAssetAddress, _depositAmount, address(this), REFERRAL_CODE);\n\n    _mint(_to, _shares);\n\n    emit SuppliedTokenTo(msg.sender, _shares, _depositAmount, _to);\n\n}"}
{"locs": [["pooltogether/aave-v3-yield-source", "e63d1b0e396a5bce89f093630c282ca1c6627e44", "contracts/AaveV3YieldSource.sol", "L275-L282)<br>"]], "vuln": "Owner or Managers can rug Aave rewards", "severity": "MEDIUM", "mitigation": "Use a `poolAddressesProviderRegistry`-like contract to determine where the rewards should go, instead of letting an address be passed in"}
{"locs": [["code-423n4/2022-04-abranft", "main", "contracts/NFTPairWithOracle.sol", "L316>"]], "vuln": "Mistake while checking LTV to lender accepted LTV", "severity": "HIGH", "mitigation": "The condition should be changed as:\n`params.ltvBPS <= accepted.ltvBPS`,"}
{"locs": [["fei-protocol/flywheel-v2", "77bfadf388db25cf5917d39cd9c0ad920f404aad", "src/token/ERC20Gauges.sol", "L257)<br>"]], "vuln": "`ERC20Gauges`: The `_incrementGaugeWeight` function does not check the gauge parameter enough, so the user may lose rewards", "severity": "MEDIUM", "mitigation": "function _incrementGaugeWeight(\n            address user,\n            address gauge,\n            uint112 weight,\n            uint32 cycle\n        ) internal {\n    -       if (_deprecatedGauges.contains(gauge)) revert InvalidGaugeError();\n    +       if (_deprecatedGauges.contains(gauge) || !_gauges.contains(gauge)) revert InvalidGaugeError();\n            unchecked {\n                if (cycle - block.timestamp <= incrementFreezeWindow) revert IncrementFreezeError();\n            }\n\n            bool added = _userGauges[user].add(gauge); // idempotent add\n            if (added && _userGauges[user].length() > maxGauges && !canContractExceedMaxGauges[user])\n                revert MaxGaugeError();\n\n            getUserGaugeWeight[user][gauge] += weight;\n\n            _writeGaugeWeight(_getGaugeWeight[gauge], _add, weight, cycle);\n\n     }"}
{"locs": [["Rari-Capital/solmate", "12421e3edee21cfb99bf5a6edd6169e6497511de", "src/mixins/ERC4626.sol", "L133) follow the formula: `assetDepositAmount * totalShareSupply / assetBalanceBeforeDeposit`."]], "vuln": "First xERC4626 deposit exploit can break share calculation", "severity": "MEDIUM", "mitigation": "This exploit is unique to contract similar to ERC4626. It only works if starting supply equal 0 or very small number and rewards cycle is very short. Or everyone withdraws, total share supply become 0.\n\nThis can be easily fix by making sure someone always deposited first so `totalSupply` become high enough that this exploit become irrelevant. Unless in unlikely case someone made arbitrage bot watching vault factory contract.<br>\nJust force deposit early token during vault construction as last resort."}
{"locs": [["fei-protocol/flywheel-v2", "77bfadf388db25cf5917d39cd9c0ad920f404aad", "src/token/ERC20Gauges.sol", "L547-L583)<br>"]], "vuln": "Incorrect accounting of free weight in `_decrementWeightUntilFree`", "severity": "MEDIUM", "mitigation": "No need to treat deprecated gauge separately."}
{"locs": [["code-423n4/2022-04-backd", "c856714a50437cb33240a5964b63687c9876275b", "backd/contracts/StakerVault.sol", "L112-L119)<br>"]], "vuln": "User can steal all rewards due to checkpoint after transfer", "severity": "HIGH", "mitigation": "In `StakerVault.transfer()`, move the call to `ILpGauge(lpGauge).userCheckpoint()` to before the balances are updated."}
{"locs": [["code-423n4/2022-04-backd", "c856714a50437cb33240a5964b63687c9876275b", "backd/contracts/actions/topup/TopUpAction.sol", "L57-L65)<br>"]], "vuln": "function `lockFunds` in `TopUpActionLibrary` can cause serious fund lose. fee and Capped bypass. It's not calling `stakerVault.increaseActionLockedBalance` when transfers stakes.", "severity": "HIGH", "mitigation": "Add this line to TopUpActionLibrary.lockFunds() after stakerVault.transferFrom():\n\nstakerVault.increaseActionLockedBalance(payer, amountLeft);"}
{"locs": [["code-423n4/2022-04-backd", "c856714a50437cb33240a5964b63687c9876275b", "backd/contracts/CvxCrvRewardsLocker.sol", "L247-L252)."]], "vuln": "`CvxCrvRewardsLocker` implements a swap without a slippage check that can result in a loss of funds through MEV", "severity": "MEDIUM", "mitigation": "Use a proper value for `minOut` instead of `0`."}
{"locs": [["code-423n4/2022-04-backd", "c856714a50437cb33240a5964b63687c9876275b", "backd/contracts/pool/LiquidityPool.sol", "L523)<br>"]], "vuln": "ERC777 tokens can bypass `depositCap` guard", "severity": "MEDIUM", "mitigation": "Add reentrancy guards to `depositFor`."}
{"locs": [["code-423n4/2022-04-backd", "c856714a50437cb33240a5964b63687c9876275b", "backd/contracts/pool/LiquidityPool.sol", "L790-L792)<br>"]], "vuln": "Griefer can extend period of higher withdrawal fees", "severity": "MEDIUM", "mitigation": "Instead of resetting `lastActionTimestamp` to the current time, scale it the same way the `feeRatio` is scaled. I understand that this would technically not be the timestamp of the last action, so the variable would probably need to be renamed."}
{"locs": [["code-423n4/2022-04-phuture", "main", "contracts/IndexLogic.sol", "L48)<br>"]], "vuln": "`IndexLogic`: An attacker can mint tokens for himself using assets deposited by other users", "severity": "HIGH", "mitigation": "Call the transferfrom function in the mint function of the IndexLogic contract to transfer the user's assets."}
{"locs": [["code-423n4/2022-04-phuture", "main", "contracts/ChainlinkPriceOracle.sol", "L83-L84)<br>"]], "vuln": "Chainlink's `latestRoundData` might return stale or incorrect results", "severity": "MEDIUM", "mitigation": "Consider adding missing checks for stale data.\n\nFor example:\n\n        (uint80 baseRoundID, int256 basePrice, , uint256 baseTimestamp, uint80 BaseAnsweredInRound) = baseAggregator.latestRoundData();\n        (uint80 quoteRoundID, int256 quotePrice, , uint256 quoteTimestamp, uint80 quoteAnsweredInRound) = assetInfo.aggregator.latestRoundData();\n        require(BaseAnsweredInRound >= baseRoundID && quoteAnsweredInRound >=  quoteRoundID, \"Stale price\");\n        require(baseTimestamp != 0 && quoteTimestamp != 0 ,\"Round not complete\");\n        require(basePrice > 0 && quotePrice > 0,\"Chainlink answer reporting 0\");"}
{"locs": [["code-423n4/2022-04-phuture", "main", "contracts/ChainlinkPriceOracle.sol", "L60)<br>"]], "vuln": "Asset Manager can update existing `_assetAggregator`", "severity": "MEDIUM", "mitigation": "addAsset should only work if assetInfoOf\\[\\_asset] value is empty."}
{"locs": [["code-423n4/2022-04-badger-citadel", "18f8c392b6fc303fe95602eba6303725023e53da", "src/KnightingRound.sol", "L162-L204>"]], "vuln": "KnightingRound tokenOutPrice changes", "severity": "MEDIUM", "mitigation": "It is recommended to add additional parameter `uint256 believedPrice` to `KnightingRound.buy` function and check if `believedPrice` is equal to `tokenOutPrice`."}
{"locs": [["code-423n4/2022-04-badger-citadel", "18f8c392b6fc303fe95602eba6303725023e53da", "src/Funding.sol", "L427-L437))"]], "vuln": "Stale price used when `citadelPriceFlag` is cleared", "severity": "MEDIUM", "mitigation": "Always set the `citadelPriceInAsset`"}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/vaults/yVault/yVault.sol", "L144-L145"]], "vuln": "Reentrancy issue in yVault.deposit", "severity": "HIGH", "mitigation": "The `safeTransferFrom` should be the last call in `deposit`."}
{"locs": [["code-423n4/2022-04-jpegd", "main", "package.json", "L18-L19)<br>"]], "vuln": "Update initializer modifier to prevent reentrancy during initialization", "severity": "HIGH", "mitigation": "Upgrade `@openzeppelin/contracts` and `@openzeppelin/contracts-upgradeable` to version 4.4.1 or higher."}
{"locs": [["code-423n4/2022-04-jpegd", "main", "contracts/farming/yVaultLPFarming.sol", "L169-L170"]], "vuln": "yVaultLPFarming: No guarantee JPEG currentBalance > previousBalance", "severity": "HIGH", "mitigation": "A simple fix would be to `return` if `currentBalance \u2264 previousBalance`. A full fix would properly handle potential shortfall.\n\n```jsx\nif (currentBalance <= previousBalance) return;\n```"}
{"locs": [["code-423n4/2022-04-jpegd", "main", "contracts/vaults/yVault/strategies/StrategyPUSDConvex.sol", "L234"]], "vuln": "StrategyPUSDConvex.balanceOfJPEG uses incorrect function signature while calling extraReward.earned, causing the function to unexpectedly revert everytime", "severity": "HIGH", "mitigation": "Pass `address(this)` as argument of `earned`.\n\nNotice how we modify the fetching of reward. This is reported in a separate bug report, but for completeness, the entire fix is shown in both report entries.\n\n```\n    function balanceOfJPEG() external view returns (uint256) {\n        uint256 availableBalance = jpeg.balanceOf(address(this));\n\n        IBaseRewardPool baseRewardPool = convexConfig.baseRewardPool;\n        availableBalance += baseRewardPool.earned(address(this));\n        uint256 length = baseRewardPool.extraRewardsLength();\n        for (uint256 i = 0; i < length; i++) {\n            IBaseRewardPool extraReward = IBaseRewardPool(baseRewardPool.extraRewards(i));\n            if (address(jpeg) == extraReward.rewardToken()) {\n                availableBalance += extraReward.earned(address(this));\n            }\n        }\n\n        return availableBalance;\n    }\n```"}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/vaults/NFTVault.sol", "L844-L851)<br>"]], "vuln": "Bad debts should not continue to accrue interest", "severity": "HIGH", "mitigation": "Consider adding a stored value to record the amount of bad debt, and add a public function that allows anyone to mark a bad debt to get some reward. and change `accrue` to:\n\n```solidity\nuint256 internal badDebtPortion;\n\nfunction accrue() public {\n    uint256 additionalInterest = _calculateAdditionalInterest();\n\n    totalDebtAccruedAt = block.timestamp;\n\n    totalDebtAmount += additionalInterest;\n\n    uint256 collectibleInterest = additionalInterest * (totalDebtPortion - badDebtPortion) / totalDebtPortion;\n    totalFeeCollected += collectibleInterest;\n}\n```"}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/vaults/NFTVault.sol", "L212"]], "vuln": "setDebtInterestApr should accrue debt first", "severity": "MEDIUM", "mitigation": "Call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`."}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/farming/LPFarming.sol", "L190"]], "vuln": "Rewards will be locked if user transfer directly to pool without using deposit function ", "severity": "MEDIUM", "mitigation": "Declare a new variable ```totalLPSupply``` to the struct ```PoolInfo```, and use it instead of ```pool.lpToken.balanceOf(address(this))```"}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/vaults/NFTVault.sol", "L590-L595)<br>"]], "vuln": "Division before Multiplication May Result In No Interest Being Accrued", "severity": "MEDIUM", "mitigation": "This issue may be resolved by performing the multiplication by `elapsedTime` before the division by the denominator or `365 days`.\n\n            uint256 interestAccrued = (elapsedTime * \n                totalDebtAmount *\n                settings.debtInterestApr.numerator) /\n                settings.debtInterestApr.denominator /\n                365 days;\n\n            return  interestAccrued;"}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/vaults/yVault/yVault.sol", "L144-L145)<br>"]], "vuln": "Reentrancy issue in `yVault.deposit`", "severity": "HIGH", "mitigation": "The `safeTransferFrom` should be the last call in `deposit`."}
{"locs": [["code-423n4/2022-04-jpegd", "main", "contracts/farming/yVaultLPFarming.sol", "L169-L170)<br>"]], "vuln": "`yVaultLPFarming`: No guarantee JPEG currentBalance > previousBalance", "severity": "HIGH", "mitigation": "A simple fix would be to `return` if `currentBalance \u2264 previousBalance`. A full fix would properly handle potential shortfall.\n\n```jsx\nif (currentBalance <= previousBalance) return;\n```"}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/vaults/NFTVault.sol", "L212)<br>"]], "vuln": "`setDebtInterestApr` should accrue debt first", "severity": "MEDIUM", "mitigation": "Call `accrue()` first in `setDebtInterestApr` before setting the new `settings.debtInterestApr`."}
{"locs": [["code-423n4/2022-04-jpegd", "e72861a9ccb707ced9015166fbded5c97c6991b6", "contracts/farming/LPFarming.sol", "L190)<br>"]], "vuln": "Rewards will be locked if user transfer directly to pool without using deposit function", "severity": "MEDIUM", "mitigation": "Declare a new variable `totalLPSupply` to the struct `PoolInfo`, and use it instead of `pool.lpToken.balanceOf(address(this))`."}
{"locs": [["code-423n4/2022-04-axelar", "dee2f2d352e8f20f20027977d511b19bfcca23a3", "src/AxelarGateway.sol", "L384-L389)<br>"]], "vuln": "User's funds can get lost when transferring to other chain", "severity": "MEDIUM", "mitigation": "Instead of reverting when the transfer is not successful, simply call the `callContractWithToken` with the source chain as the destination chain in order to return the user his funds."}
{"locs": [["code-423n4/2022-04-axelar", "main", "src/AxelarGateway.sol", "L284-L334)<br>"]], "vuln": "Unsupported fee-on-transfer tokens", "severity": "MEDIUM", "mitigation": "Consider getting the received amount by calculating the difference of token balance (using balanceOf) before and after the transferFrom."}
{"locs": [["code-423n4/2022-04-dualityfocus", "f21ef7708c9335ee1996142e2581cb8714a525c9", "contracts/compound_rari_fork/Comptroller.sol", "L1491"]], "vuln": "Undercollateralized loans possible", "severity": "MEDIUM", "mitigation": "Disable the possibility of ever having a collateral factor > 100% by checking:\n\n```diff\nfor (uint256 i = 0; i < pools.length; i++) {\n+   require(collateralFactorsMantissa[i] <= 1e18, \"CF > 100%\");\n    poolCollateralFactors[pools[i]] = collateralFactorsMantissa[i];\n}\n```"}
{"locs": [["code-423n4/2022-04-dualityfocus", "main", "contracts/compound_rari_fork/CToken.sol", "L1379"]], "vuln": "Dysfunctional CToken._acceptAdmin due to lack of function to assign pendingAdmin", "severity": "MEDIUM", "mitigation": "Add a `proposePendingAdmin` function where the current admin can propose successors.\n\n```\n    function _proposePendingAdmin(address newPendingAdmin) external {\n        if (msg.sender != admin) {\n            return fail(Error.UNAUTHORIZED, FailureInfo.PROPOSE_PENDING_ADMIN_CHECK);\n        }\n        address oldPendingAdmin = pendingAdmin;\n        pendingAdmin = newPendingAdmin;\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n        return uint256(Error.NO_ERROR)\n    }\n```"}
{"locs": [["code-423n4/2022-04-dualityfocus", "main", "contracts/compound_rari_fork/Comptroller.sol", "L1105"]], "vuln": "Comptroller._setUniV3LpVault will always cause in-use uniswapV3 positions to become stuck in UniV3LpVault", "severity": "MEDIUM", "mitigation": "Remove the option to change `Comptroller.uniV3LpVault` altogether, as this functionality is not really helpful for the overall protocol.\nAnother way to handle this is to forcefully evict all NFTs before changing the vault. However, this is extremely complex as it would potentially cause users to become severely under-collateralized, and would require more care in tracking and maintaining states."}
{"locs": [["code-423n4/2022-04-backed", "e8015d7c4b295af131f017e646ba1b99c8f608f0", "contracts/NFTLoanFacilitator.sol", "L148)<br>"]], "vuln": "Can force borrower to pay huge interest", "severity": "HIGH", "mitigation": "The loan amount should not have min amount semantics.\nWhen someone wants to get a loan, they specify a certain amount they need, they don't want to receive and pay interest on more than that."}
{"locs": [["code-423n4/2022-04-backed", "e8015d7c4b295af131f017e646ba1b99c8f608f0", "contracts/NFTLoanFacilitator.sol", "L155-L160)<br>"]], "vuln": "Protocol doesn't handle fee on transfer tokens", "severity": "MEDIUM", "mitigation": "Since the `originationFee` is calculated based on the `amount` sent by the lender, this calculation will always underflow given the example above. Instead, a potential solution would be to calculate the `originationFee` based on the requested loan amount, allowing the lender to send a greater value so that `feeOnTransfer <= originationFee`.\n\nOppositely, the protocol can instead calculate the amount received from the initial transfer and use this amount to calculate the `originationFee`. The issue with this option is that the borrower will receive less than the desired loan amount."}
{"locs": [["code-423n4/2022-03-volt", "f1210bf3151095e4d371c9e9d7682d9031860bbd", "contracts/utils/RateLimited.sol", "L142)<br>"]], "vuln": "Setting new buffer does not reduce current buffer to cap", "severity": "MEDIUM", "mitigation": "Update the buffer after setting the new cap:\n\n```diff\nfunction _setBufferCap(uint256 newBufferCap) internal {\n-   _updateBufferStored();\n    uint256 oldBufferCap = bufferCap;\n    bufferCap = newBufferCap;\n\n+   _updateBufferStored();\n\n    emit BufferCapUpdate(oldBufferCap, newBufferCap);\n}\n```"}
{"locs": [["code-423n4/2022-03-volt", "f1210bf3151095e4d371c9e9d7682d9031860bbd", "contracts/refs/OracleRef.sol", "L104)<br>"]], "vuln": "`OracleRef` assumes backup oracle uses the same normalizer as main oracle", "severity": "MEDIUM", "mitigation": "Should there be two scaling factors, one for each oracle?"}
{"locs": [["code-423n4/2022-03-volt", "f1210bf3151095e4d371c9e9d7682d9031860bbd", "contracts/utils/MultiRateLimited.sol", "L280)<br>"]], "vuln": "Updating rate limit for addresses restores their entire buffer amount", "severity": "MEDIUM", "mitigation": "Keep the old buffer value, capped by the new `bufferCap`:\n\n```diff\n+ uint256 newBuffer = individualBuffer(rateLimitedAddress);\n\n  rateLimitData.lastBufferUsedTime = block.timestamp.toUint32();\n  rateLimitData.bufferCap = _bufferCap;\n  rateLimitData.rateLimitPerSecond = _rateLimitPerSecond;\n- rateLimitData.bufferStored = _bufferCap;\n+ rateLimitData.bufferStored = min(_bufferCap, newBuffer);\n```"}
{"locs": [["code-423n4/2022-03-joyn", "main", "splits/contracts/Splitter.sol", "L149-L169>"]], "vuln": "Splitter: Anyone can call incrementWindow to steal the tokens in the contract", "severity": "HIGH", "mitigation": "Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function."}
{"locs": [["sublime-finance/sublime-v1", "46536a6d25df4264c1b217bd3232af30355dcb95", "contracts/PooledCreditLine/LenderPool.sol", "L404-L406)<br>"]], "vuln": "`PooledCreditLine`: termination likely fails because `_principleWithdrawable` is treated as shares", "severity": "HIGH", "mitigation": "The amount of shares to withdraw can simply be `_sharesHeld`.\n\nNote that this comes with the assumption that `terminate()` is only called when the credit line is `ACTIVE` or `EXPIRED` (consider ensuring this condition on-chain), because `_sharesHeld` **excludes principal withdrawals,** so the function will fail once a lender withdraws his principal.\n\n```jsx\nfunction terminate(uint256 _id, address _to) external override onlyPooledCreditLine nonReentrant {\n  address _strategy = pooledCLConstants[_id].borrowAssetStrategy;\n  address _borrowAsset = pooledCLConstants[_id].borrowAsset;\n  uint256 _sharesHeld = pooledCLVariables[_id].sharesHeld;\n\n  SAVINGS_ACCOUNT.withdrawShares(_borrowAsset, _strategy, _to, _sharesHeld, false);\n  delete pooledCLConstants[_id];\n  delete pooledCLVariables[_id];\n}\n```"}
{"locs": [["sublime-finance/sublime-v1", "46536a6d25df4264c1b217bd3232af30355dcb95", "contracts/PooledCreditLine/LenderPool.sol", "L327)<br>"]], "vuln": "Pool Credit Line May Not Able to Start When _borrowAsset is Non ERC20 Compliant Tokens", "severity": "MEDIUM", "mitigation": "Use .safeTransfer instead of .transfer\n\n`IERC20(_borrowAsset).safeTransfer(_to, _fee);`"}
{"locs": [["sublime-finance/sublime-v1", "46536a6d25df4264c1b217bd3232af30355dcb95", "contracts/PooledCreditLine/LenderPool.sol", "L442)<br>"]], "vuln": "Lack of access control allow anyone to `withdrawInterest()` for any lender", "severity": "MEDIUM", "mitigation": "Change to:\n\n```solidity\nfunction withdrawInterest(uint256 _id, address _lender) external nonReentrant {\n    require(msg.sender == _lender);\n    _withdrawInterest(_id, _lender);\n}\n```"}
{"locs": [["sublime-finance/sublime-v1", "46536a6d25df4264c1b217bd3232af30355dcb95", "contracts/PooledCreditLine/PooledCreditLine.sol", "L1215-L1221)<br>"]], "vuln": "Interest accrued could be zero for small decimal tokens", "severity": "MEDIUM", "mitigation": "Take caution when allowing an asset to be borrowed. Alternatively, scale the principal amount to precision (1e18) amounts."}
{"locs": [["code-423n4/2022-03-paladin", "9c26ec8556298fb1dc3cf71f471aadad3a5c74a0", "contracts/HolyPaladinToken.sol", "L715-L743)<br>"]], "vuln": "`DropPerSecond` is not updated homogeneously, the rewards emission can be much higher than expected in some cases", "severity": "HIGH", "mitigation": "Change to:\n\n```solidity\nfunction _updateDropPerSecond() internal returns (uint256){\n    // If no more need for monthly updates => decrease duration is over\n    if(block.timestamp > startDropTimestamp + dropDecreaseDuration) {\n        // Set the current DropPerSecond as the end value\n        // Plus allows to be updated if the end value is later updated\n        if(currentDropPerSecond != endDropPerSecond) {\n            currentDropPerSecond = endDropPerSecond;\n            lastDropUpdate = block.timestamp;\n        }\n\n        return endDropPerSecond;\n    }\n\n    if(block.timestamp < lastDropUpdate + MONTH) return currentDropPerSecond; // Update it once a month\n\n    uint256 dropDecreasePerMonth = (startDropPerSecond - endDropPerSecond) / (dropDecreaseDuration / MONTH);\n    uint256 nbMonthEllapsed = UNIT * (block.timestamp - lastDropUpdate) / MONTH;\n\n    uint256 dropPerSecondDecrease = dropDecreasePerMonth * nbMonthEllapsed / UNIT;\n\n    // We calculate the new dropPerSecond value\n    // We don't want to go under the endDropPerSecond\n    uint256 newDropPerSecond = currentDropPerSecond - dropPerSecondDecrease > endDropPerSecond ? currentDropPerSecond - dropPerSecondDecrease : endDropPerSecond;\n\n    currentDropPerSecond = newDropPerSecond;\n    lastDropUpdate = block.timestamp;\n\n    return newDropPerSecond;\n}\n```"}
{"locs": [["code-423n4/2022-03-paladin", "main", "contracts/open-zeppelin/ERC20.sol", "L149>"]], "vuln": "`HolyPaladinToken.sol` uses `ERC20` token with a highly unsafe pattern", "severity": "MEDIUM", "mitigation": "Be sure to follow the Checks Effects and Interactions safety pattern as the `transferFrom` function is one of the most important functions in any protocol.  Consider importing the Open Zeppelin `ERC20.sol` contract code directly as it is battle tested and safe code."}
{"locs": [["code-423n4/2022-03-paladin", "main", "contracts/HolyPaladinToken.sol", "L25)<br>"]], "vuln": "Incorrect number of seconds in `ONE_YEAR` variable", "severity": "MEDIUM", "mitigation": "The correct number of seconds in a year is 31\\_536\\_000 so the `ONE_YEAR` variable should be changed to `ONE_YEAR = 31_536_000`"}
{"locs": [["code-423n4/2022-03-paladin", "main", "contracts/HolyPaladinToken.sol", "L1131)"]], "vuln": "Users at `UNSTAKE_PERIOD` can assist other users in unstaking tokens.", "severity": "MEDIUM", "mitigation": "After calculation, we found that the number of tokens that users at the edge of UNSTAKE_PERIOD can assist in unstaking conforms to the following equation\nUNSTAKE_PERIOD/COOLDOWN_PERIOD = UNSTAKE_AMOUNT/USER_BALANCE, when COOLDOWN_PERIOD remains unchanged, the smaller the UNSTAKE_PERIOD, the less tokens the user can assist in unstaking, so UNSTAKE_PERIOD can be adjusted to alleviate this situation."}
{"locs": [["code-423n4/2022-03-paladin", "main", "contracts/HolyPaladinToken.sol", "L891-L905)"]], "vuln": "`cooldown` is set to 0 when the user sends all tokens to himself", "severity": "MEDIUM", "mitigation": "function _beforeTokenTransfer(\n          address from,\n          address to,\n          uint256 amount\n      ) internal virtual override {\n          if(from != address(0)) { //check must be skipped on minting\n              // Only allow the balance that is unlocked to be transfered\n              require(amount <= _availableBalanceOf(from), \"hPAL: Available balance too low\");\n          }\n\n          // Update user rewards before any change on their balance (staked and locked)\n          _updateUserRewards(from);\n\n          uint256 fromCooldown = cooldowns[from]; //If from is address 0x00...0, cooldown is always 0\n\n          if(from != to) {\n              // Update user rewards before any change on their balance (staked and locked)\n              _updateUserRewards(to);\n              // => we don't want a self-transfer to double count new claimable rewards\n              // + no need to update the cooldown on a self-transfer\n\n              uint256 previousToBalance = balanceOf(to);\n              cooldowns[to] = _getNewReceiverCooldown(fromCooldown, amount, to, previousToBalance);\n              // If from transfer all of its balance, reset the cooldown to 0\n              uint256 previousFromBalance = balanceOf(from);\n              if(previousFromBalance == amount && fromCooldown != 0) {\n                  cooldowns[from] = 0;\n              }\n          }\n      }"}
{"locs": [["code-423n4/2022-03-paladin", "9c26ec8556298fb1dc3cf71f471aadad3a5c74a0", "contracts/HolyPaladinToken.sol", "L228-L235)<br>"]], "vuln": "Function `cooldown()` is not protected when protocol in emergency mode", "severity": "MEDIUM", "mitigation": "Add checking for emergency mode for this function also.\n\n    if(emergency) revert EmergencyBlock();"}
{"locs": [["code-423n4/2022-03-paladin", "9c26ec8556298fb1dc3cf71f471aadad3a5c74a0", "contracts/HolyPaladinToken.sol", "L446-L468)<br>"]], "vuln": "`UserLock` information can be found during emergency mode", "severity": "MEDIUM", "mitigation": "Add checking for emergency mode for this function getUserPastLock.\n\n    if(emergency) revert EmergencyBlock();\n\nAdditional user access check can be added, so that the function returns correct value when the caller(msg.sender) is admin or owner."}
{"locs": [["code-423n4/2022-03-paladin", "9c26ec8556298fb1dc3cf71f471aadad3a5c74a0", "contracts/HolyPaladinToken.sol", "L1425)"]], "vuln": "Emergency mode enable/disable issue", "severity": "MEDIUM", "mitigation": "It is recommended to remove `bool trigger` parameter from `triggerEmergencyWithdraw` function and set `emergency` to `true` after successfully executing function."}
{"locs": [["code-423n4/2022-03-lifinance", "699c2305fcfb6fe8862b75b26d1d8a2f46a551e6", "src/Facets/GenericSwapFacet.sol", "L23-L30)<br>"]], "vuln": "Reliance on `lifiData.receivingAssetId` can cause loss of funds", "severity": "HIGH", "mitigation": "I recommend adding a check that `_lifiData.receivingAssetId` equals the `receivingAssetId` of the last index of the SwapData array, or simply use the `receivingAssetId` of the last index of the SwapData array for sending the final tokens to the user."}
{"locs": [["code-423n4/2022-03-lifinance", "main", "src/Facets/AnyswapFacet.sol", "L35-L53)<br>"]], "vuln": "`AnyswapFacet` can be exploited to approve arbitrary tokens.", "severity": "MEDIUM", "mitigation": "Consider whitelisting both Anyswap tokens and Anyswap routers (using two distinct whitelists) restricting the attackers ability to use malicious contracts for this attack.\n\nConsider also only calling `IAnyswapToken(_anyswapData.token).underlying()` once and passing this value to `_startBridge()`."}
{"locs": [["code-423n4/2022-03-lifinance", "main", "src/Libraries/LibSwap.sol", "L29-L48)<br>"]], "vuln": "Anyone can get swaps for free given certain conditions in `swap`.", "severity": "MEDIUM", "mitigation": "Ensure funds are always subtracted from users account in `swap`, even if LiFi has enough balance to do the swap."}
{"locs": [["code-423n4/2022-03-lifinance", "main", "src/Facets/CBridgeFacet.sol", "L68)"]], "vuln": "Should prevent users from sending more native tokens in the `startBridgeTokensViaCBridge` function", "severity": "MEDIUM", "mitigation": "Consider changing `>=` to `==` at line 68."}
{"locs": [["code-423n4/2022-03-prepo", "f63584133a0329781609e3f14c3004c1ca293e71", "contracts/core/Collateral.sol", "L97)<br>"]], "vuln": "Withdrawal delay can be circumvented", "severity": "HIGH", "mitigation": "If there's a withdrawal request for the token owner (`_accountToWithdrawalRequest[owner].blockNumber > 0`), disable their transfers for the time.\n\n```solidity\n// pseudo-code not tested\nbeforeTransfer(from, to, amount) {\n  super();\n  uint256 withdrawalStart =  _accountToWithdrawalRequest[from].blockNumber;\n  if(withdrawalStart > 0 && withdrawalStart + _delayedWithdrawalExpiry < block.number) {\n    revert(); // still in withdrawal window\n  }\n}\n```"}
{"locs": [["code-423n4/2022-03-prepo", "main", "contracts/core/SingleStrategyController.sol", "L51-L72)<br>"]], "vuln": "Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations", "severity": "HIGH", "mitigation": "The recommendation is to ensure that `require(_oldStrategy.totalValue() == 0)` after calling `_oldStrategy.withdraw()`. This ensures that no funds are left in the strategy. Consider the code example below.\n\n        function migrate(IStrategy _newStrategy)\n            external\n            override\n            onlyOwner\n            nonReentrant\n        {\n            uint256 _oldStrategyBalance;\n            IStrategy _oldStrategy = _strategy;\n            _strategy = _newStrategy;\n            _baseToken.approve(address(_newStrategy), type(uint256).max);\n            if (address(_oldStrategy) != address(0)) {\n                _baseToken.approve(address(_oldStrategy), 0);\n                _oldStrategyBalance = _oldStrategy.totalValue();\n                _oldStrategy.withdraw(address(this), _oldStrategyBalance);\n                require(_oldStrategy.totalValue() == 0)\n                _newStrategy.deposit(_baseToken.balanceOf(address(this)));\n            }\n            emit StrategyMigrated(\n                address(_oldStrategy),\n                address(_newStrategy),\n                _oldStrategyBalance\n            );\n        }"}
{"locs": [["code-423n4/2022-03-prepo", "main", "contracts/core/PrePOMarketFactory.sol", "L42)<br>"]], "vuln": "Duplicate  `_tokenNameSuffix` and `_tokenSymbolSuffix` will incorrectly update current Market", "severity": "MEDIUM", "mitigation": "Add below check:\n\n    require(_deployedMarkets[_salt]==address(0), \"Market already exists\");"}
{"locs": [["code-423n4/2022-03-prepo", "main", "contracts/core/PrePOMarket.sol", "L145-L156)<br>"]], "vuln": "Market expiry behaviour differs in implementation and documentation", "severity": "MEDIUM", "mitigation": "If the market is to settle at the lower valuation after expiry, then the following logic should be added:\n\n```jsx\n// market has expired\n// settle at lower bound\nif (block.timestamp > _expiryTime) {\n\tuint256 _shortPrice = MAX_PRICE - _floorLongPrice;\n\t_collateralOwed =\n\t\t(_floorLongPrice * _longAmount + _shortPrice * _shortAmount) /\n\t\tMAX_PRICE;\n} else if (_finalLongPrice <= MAX_PRICE) {\n\t...\n} else {\n\t...\n}\n```\n\nOtherwise, the documentation should be updated to reflect the default behaviour of 1:1 redemption."}
{"locs": [["code-423n4/2022-03-rolla", "main", "quant-protocol/contracts/options/CollateralToken.sol", "L101-L117"]], "vuln": "COLLATERAL_MINTER_ROLE can be granted by the deployer of QuantConfig and mint arbitrary amount of tokens", "severity": "MEDIUM", "mitigation": "Consider removing the COLLATERAL_MINTER_ROLE, make the CollateralToken only mintable by the owner, and make the Controller contract to be the owner and therefore the only minter."}
{"locs": [["code-423n4/2022-03-rolla", "efe4a3c1af8d77c5dfb5ba110c3507e67a061bdd", "quant-protocol/contracts/options/QTokenStringUtils.sol", "L115-L130"]], "vuln": "QTokens with the same symbol will lead to mistakes", "severity": "MEDIUM", "mitigation": "Include the full year in the token's symbol"}
{"locs": [["code-423n4/2022-03-rolla", "a06418c9cc847395f3699bdf684a9ac066651ed7", "quant-protocol/contracts/timelock/TimelockController.sol", "L414-L415"]], "vuln": "Low-level transfer via call() can fail silently", "severity": "MEDIUM", "mitigation": "Check for the account's existence prior to transferring."}
{"locs": [["code-423n4/2022-03-rolla", "main", "quant-protocol/contracts/Controller.sol", "L497-L516"]], "vuln": "Arbitrary code can be run with Controller as msg.sender", "severity": "MEDIUM", "mitigation": "Given that QToken can be called directly please examine the need for QTokenPermit ActionType.\n\nIf current approach is based on UI convenience and better be kept, consider probing for IOptionsFactory(optionsFactory).isQToken(_qToken) before calling the address provided."}
{"locs": [["maple-labs/loan", "main", "contracts/MapleLoanInternals.sol", "L332-L344)<br>"]], "vuln": "Incorrect implementation of Lender can result in lost tokens", "severity": "MEDIUM", "mitigation": "```solidity\nfunction _sendFee(address lookup_, bytes4 selector_, uint256 amount_) internal returns (bool success_) {\n    if (amount_ == uint256(0)) return true;\n\n    ( bool success , bytes memory data ) = lookup_.call(abi.encodeWithSelector(selector_));\n\n+       if (!success || data.length != uint256(32)) return false;\n\n    address destination = abi.decode(data, (address));\n\n    if (destination == address(0)) return false;\n\n    return ERC20Helper.transfer(_fundsAsset, destination, amount_);\n}\n```"}
{"locs": [["code-423n4/2022-03-biconomy", "db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a", "contracts/hyphen/LiquidityPool.sol", "L319-L322"]], "vuln": "Wrong formula when add fee incentivePool can lead to loss of funds.", "severity": "HIGH", "mitigation": "Fix the bug by change line 319-322 to:\n```\nincentivePool[tokenAddress] += (amount * (transferFeePerc - tokenManager.getTokensInfo(tokenAddress).equilibriumFee)) / BASE_DIVISOR;\n```"}
{"locs": [["code-423n4/2022-03-biconomy", "db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a", "contracts/hyphen/LiquidityPool.sol", "L151"]], "vuln": "Can deposit native token for free and steal funds", "severity": "HIGH", "mitigation": "Check `tokenAddress != NATIVE` in `depositErc20`."}
{"locs": [["code-423n4/2022-03-biconomy", "db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a", "contracts/hyphen/LiquidityProviders.sol", "L273"]], "vuln": "Unsupported tokens cannot be withdrawn", "severity": "MEDIUM", "mitigation": "Consider allowing withdrawals even if the token was unsupported to allow users to reclaim their funds."}
{"locs": [["code-423n4/2022-03-biconomy", "main", "contracts/hyphen/LiquidityFarming.sol", "L174-L192"]], "vuln": "Owners have absolute control over protocol", "severity": "MEDIUM", "mitigation": "Make executors decentralized. \nAdd TimeLock for parameter changes."}
{"locs": [["code-423n4/2022-03-biconomy", "04751283f85c9fc94fb644ff2b489ec339cd9ffc", "contracts/hyphen/WhitelistPeriodManager.sol", "L202-L208"]], "vuln": "Frontrunning of setPerTokenWalletCap edge case", "severity": "MEDIUM", "mitigation": "A programmatic solution is the only way to avoid these edge case scenarios, though it will increase gas consumption. To convert the manual calling of `getMaxCommunityLpPositon(_token)` to a programmatic solution, add the following require statement next to the existing require statement of the `setPerTokenWalletCap()` function:\n`require(_perTokenWalletCap <= getMaxCommunityLpPositon(_token), \"ERR_PWC_GT_MCLP\");`"}
{"locs": [["code-423n4/2022-03-biconomy", "db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a", "contracts/hyphen/LiquidityProviders.sol", "L171"]], "vuln": "LiquidityProviders: Setting new liquidity pool will break contract", "severity": "MEDIUM", "mitigation": "Changing the `liquidityPool` requires a sophisticated migration mechanism.\nOnly allow setting the `liquidityPool` contract once."}
{"locs": [["code-423n4/2022-03-biconomy", "db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a", "contracts/hyphen/LiquidityProviders.sol", "L116"]], "vuln": "LiquidityProviders: Setting new LP token will break contract", "severity": "MEDIUM", "mitigation": "Changing the `lpToken` requires a sophisticated migration mechanism.\nOnly allow setting the `lpToken` contract once."}
{"locs": [["code-423n4/2022-03-biconomy", "04751283f85c9fc94fb644ff2b489ec339cd9ffc", "contracts/hyphen/LiquidityProviders.sol", "L180-L186"]], "vuln": "wrong condition checking in price calculation", "severity": "MEDIUM", "mitigation": "The correct code should be:\n```sol\nfunction getTokenPriceInLPShares(address _baseToken) public view returns (uint256) {\n    uint256 reserve = totalReserve[_baseToken];\n    if (reserve > 0) {\n        return totalSharesMinted[_baseToken] / totalReserve[_baseToken];\n    }\n    return BASE_DIVISOR;\n}\n```"}
{"locs": [["code-423n4/2022-03-biconomy", "db8a1fdddd02e8cc209a4c73ffbb3de210e4a81a", "contracts/hyphen/LiquidityProviders.sol", "L192"]], "vuln": "sharesToTokenAmount: Division by zero", "severity": "MEDIUM", "mitigation": "Return 0 in case `totalSharesMinted[_tokenAddress]` is zero."}
{"locs": [["code-423n4/2022-03-timeswap", "00317d9a8319715a8e28361901ab14fe50d06172", "Timeswap/Core/contracts/TimeswapPair.sol", "L459-L490)<br>"]], "vuln": "Wrong timing of check allows users to withdraw collateral without paying for the debt", "severity": "HIGH", "mitigation": "Change to:\n\n```solidity\nfor (uint256 i; i < param.ids.length;) {\n    Due storage due = dues[param.ids[i]];\n    require(due.startBlock != BlockNumber.get(), 'E207');\n    if (param.owner != msg.sender) require(param.collateralsOut[i] == 0, 'E213');\n    due.debt -= param.assetsIn[i];\n    due.collateral -= param.collateralsOut[i];\n    assetIn += param.assetsIn[i];\n    collateralOut += param.collateralsOut[i];\n    unchecked { ++i; }\n}\n\nrequire(uint256(assetIn) * due.collateral >= uint256(collateralOut) * due.debt, 'E303');\n...\n```"}
{"locs": [["code-423n4/2022-02-foundation", "main", "contracts/mixins/NFTMarketPrivateSale.sol", "L123-L174"]], "vuln": "EIP-712 signatures can be re-used in private sales", "severity": "MEDIUM", "mitigation": "Most contracts utilize nonces when generating EIP-712 signatures to ensure that the contract hasn't been used for. When a nonce is injected into a signature, it makes it impossible for re-use, assuming of course the nonce feature is done correctly."}
{"locs": [["code-423n4/2022-02-foundation", "main", "contracts/mixins/SendValueWithFallbackWithdraw.sol", "L37-L77"]], "vuln": "SendValueWithFallbackWithdraw: withdrawFor function may fail to withdraw ether recorded in pendingWithdrawals", "severity": "MEDIUM", "mitigation": "Add the withdrawTo function as follows:\n\n```\n  function withdrawTo(address payable to) public nonReentrant {\n    uint256 amount = pendingWithdrawals[msg.sneder];\n    if (amount == 0) {\n      revert SendValueWithFallbackWithdraw_No_Funds_Available();\n    }\n    pendingWithdrawals[msg.sneder] = 0;\n    to.sendValue(amount);\n    emit Withdrawal(msg.sneder, amount);\n  }\n```"}
{"locs": [["code-423n4/2022-02-foundation", "4d8c8931baffae31c7506872bf1100e1598f2754", "contracts/FETH.sol", "L212"]], "vuln": "Approve race condition in FETH", "severity": "MEDIUM", "mitigation": "Add increase and decrease allowance."}
{"locs": [["code-423n4/2022-02-foundation", "4d8c8931baffae31c7506872bf1100e1598f2754", "contracts/mixins/NFTMarketFees.sol", "L76-L79"]], "vuln": "Exchange does not split royalty revenue correctly", "severity": "MEDIUM", "mitigation": "Fetch the royalty information during offer creation, cache it for the final transfer, and reject any NFT for which the array size is more than `MAX_ROYALTY_RECIPIENTS_INDEX`"}
{"locs": [["code-423n4/2022-02-foundation", "main", "contracts/mixins/NFTMarketPrivateSale.sol", "L143-L150"]], "vuln": "buyFromPrivateSaleFor() Will Fail if The Buyer Has Insufficient Balance Due to an Open Offer on The Same NFT", "severity": "MEDIUM", "mitigation": "Consider adding a `_cancelBuyersOffer()` call to the `buyFromPrivateSaleFor()` function. This should be added only to the case where insufficient `ETH` was provided to the trade. By cancelling the buyer's offer on the same NFT, we can guarantee that the user has access to the correct amount of funds."}
{"locs": [["code-423n4/2022-02-foundation", "main", "contracts/mixins/NFTMarketCreators.sol", "L49-L251"]], "vuln": "_getCreatorPaymentInfo() is Not Equipped to Handle Reverts on an Unbounded _recipients Array", "severity": "MEDIUM", "mitigation": "Consider bounding the number of iterations to `MAX_ROYALTY_RECIPIENTS_INDEX` as this is already enforced by `_distributeFunds()`. It may be useful to identify other areas where the `try` statement will not handle reverts on internal calls."}
{"locs": [["code-423n4/2022-02-foundation", "4d8c8931baffae31c7506872bf1100e1598f2754", "contracts/libraries/LockedBalance.sol", "L56"]], "vuln": "LockedBalance library should drop parameters to 96/32 bits", "severity": "MEDIUM", "mitigation": "Make sure that there are only 96/32 bits set in `totalAmount` and `expiration` by dropping them to their respective types.\n\n```diff\nfunction set(\n  Lockups storage lockups,\n  uint256 index,\n  uint256 expiration,\n  uint256 totalAmount\n) internal {\n  unchecked {\n-    uint256 lockedBalanceBits = totalAmount | (expiration << 96);\n+    // cast it to uint256 again for the << 96 to work on 256-bits\n+    uint256 lockedBalanceBits = uint256(uint96(totalAmount)) | (uint256(uint32(expiration)) << 96);\n    \n    ...\n  }\n}\n```"}
{"locs": [["code-423n4/2022-02-foundation", "4d8c8931baffae31c7506872bf1100e1598f2754", "contracts/mixins/NFTMarketFees.sol", "L78"]], "vuln": "MAX_ROYALTY_RECIPIENTS_INDEX set too low", "severity": "MEDIUM", "mitigation": "I don't think cases with more than 5 creators / royalty receivers are unlikely.\nIt can and should probably be increased, especially as the transfers are already gas restricted."}
{"locs": [["code-423n4/2022-02-foundation", "4d8c8931baffae31c7506872bf1100e1598f2754", "contracts/mixins/NFTMarketPrivateSale.sol", "L156"]], "vuln": "Private sale spoofing", "severity": "MEDIUM", "mitigation": "This is made possible because private sales do not keep the NFT in escrow.\nConsider escrowing the NFT also for private sales."}
{"locs": [["code-423n4/2022-02-foundation", "main", "contracts/mixins/NFTMarketCore.sol", "L77-L87"]], "vuln": "Escrowed NFT can be stolen by anyone if no active buyPrice or auction exists for it", "severity": "MEDIUM", "mitigation": "Consider adding additional checks to control who can obtain unallocated NFTs from the contract.\n\nProtocol controlled entity can handle such cases manually by initial sender's request."}
{"locs": [["code-423n4/2022-02-anchor", "7af353e3234837979a19ddc8093dc9ad3c63ab6b", "contracts/money-market-contracts/contracts/oracle/src/contract.rs", "L106-L113>"]], "vuln": "`money-market-contracts/oracle#feed_prices()` delayed transaction may disrupt price feeds", "severity": "HIGH", "mitigation": "Change to:\n\n```solidity\npub fn feed_prices(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    prices: Vec<(String, Decimal256, u64)>,\n) -> Result<Response, ContractError> {\n    let mut attributes = vec![attr(\"action\", \"feed_prices\")];\n    let sender_raw = deps.api.addr_canonicalize(info.sender.as_str())?;\n    for price in prices {\n        let asset: String = price.0;\n        let mut updated_time: u64 = price.2;\n        let price: Decimal256 = price.1;\n\n        // Check feeder permission\n        let feeder = read_feeder(deps.storage, &asset)?;\n        if feeder != sender_raw {\n            return Err(ContractError::Unauthorized {});\n        }\n\n        let config: Config = read_config(deps.storage)?;\n        if env.block.time.seconds() > updated_time {\n            // reject stale price\n            if env.block.time.seconds() - updated_time > config.valid_period {\n                return Err(ContractError::InvalidInputs {});\n            }\n        } else {\n            // reject future timestamp, graceFuturePeriod can be set to 3, which means < 3s is allowed\n            if updated_time - env.block.time.seconds() > config.grace_future_period {\n                return Err(ContractError::InvalidInputs {});\n            }\n            updated_time = env.block.time.seconds();\n        }\n\n        attributes.push(attr(\"asset\", asset.to_string()));\n        attributes.push(attr(\"price\", price.to_string()));\n\n        store_price(\n            deps.storage,\n            &asset,\n            &PriceInfo {\n                last_updated_time: updated_time,\n                price,\n            },\n        )?;\n    }\n\n    Ok(Response::new().add_attributes(attributes))\n}\n```"}
{"locs": [["code-423n4/2022-02-anchor", "7af353e3234837979a19ddc8093dc9ad3c63ab6b", "contracts/anchor-bEth-contracts/contracts/anchor_beth_reward/src/user.rs", "L187-L212>"]], "vuln": "`bEth` Rewards May Be Depleted By Flashloans or Whales", "severity": "MEDIUM", "mitigation": "There are multiple possible mitigations to this issue.\n\nFirst, option is to only allow the `global_index` to be updated once per block. In addition to this, cap the amount of rewards that may be paid per block (keeping the remaining rewards for the next block). This would reduce the effectiveness of the attack and limit the amount they may earn per block.\n\nAnother option is to induce a wait time before the user may begin earning rewards. However, this would require a second transaction from the user to begin collection their reward which may hurt UX.\n\n***"}
{"locs": [["code-423n4/2022-02-anchor", "7af353e3234837979a19ddc8093dc9ad3c63ab6b", "contracts%2Fanchor-token-contracts%2Fcontracts%2Fcollector%2Fsrc%2Fcontract.rs", "L130-L137>"]], "vuln": "Sandwich attack on astroport sweep", "severity": "MEDIUM", "mitigation": "Consider setting a ANC/asset `belief_price` from an oracle."}
{"locs": [["code-423n4/2022-02-anchor", "7af353e3234837979a19ddc8093dc9ad3c63ab6b", "contracts%2Fmoney-market-contracts%2Fcontracts%2Fmarket%2Fsrc%2Fborrow.rs", "L304>"]], "vuln": "Simple interest calculation is not exact", "severity": "MEDIUM", "mitigation": "Ensure that the markets are accrued regularly, or switch to a compound interest formula (which has a higher computational cost due to exponentiation, but can be approximated, see Aave)."}
{"locs": [["code-423n4/2022-02-anchor", "7af353e3234837979a19ddc8093dc9ad3c63ab6b", "contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/config.rs", "L90-L97>"]], "vuln": "Updating the hub\u2019s token contract address may lead to incorrect undelegation amount", "severity": "MEDIUM", "mitigation": "Its recommended to remove the ability to update `token_contract` config value, or asserting that `requested_with_fee` is zero before allowing an update of the `token_contract` address."}
{"locs": [["code-423n4/2022-02-anchor", "7af353e3234837979a19ddc8093dc9ad3c63ab6b", "contracts/anchor-bAsset-contracts/contracts/anchor_basset_hub/src/bond.rs", "L15)) a validator can steal rewards and increase their own."]], "vuln": "Unbonding validator random selection can be predicted", "severity": "MEDIUM", "mitigation": "An `unbond` must always remove stake from the validator the stake was originally bonded to, otherwise, it's exploitable by the attack above.<br>\nConsider keeping track of all bonds with a `bond_id` and create a map of `bond_id -> validator`.<br>\nIf a validator's stake decreased due to slashing, take the remaining unstake amount proportionally from all other validators.<br>"}
{"locs": [["code-423n4/2022-02-anchor", "main", "contracts/money-market-contracts/contracts/overseer/src/contract.rs", "L192"]], "vuln": "Possible Wrong bAsset Rewards/Borrow limits Calculation", "severity": "MEDIUM", "mitigation": "Consider calling execute\\_epoch\\_operations function after config update."}
{"locs": [["code-423n4/2022-02-anchor", "7af353e3234837979a19ddc8093dc9ad3c63ab6b", "contracts/anchor-token-contracts/contracts/gov/src/staking.rs", "L88>"]], "vuln": "Staking tokens can be stolen", "severity": "MEDIUM", "mitigation": "The protocol tries to protect against this attack but the `max(., 1)` is not enough mitigation. There are several ways to fix this:\n\n1.  Always round up in `withdraw_share`\n2.  Always recompute the `withdraw_amount` with the new `withdraw_share` even if the `amount` parameter was set.\n3.  Use a `share` parameter (instead of the `amount` parameter) and use it as `withdraw_share`. Rounding down on the resulting `withdraw_amount` is bad for the attacker as burning a share leads to fewer tokens."}
{"locs": [["skalenetwork/ima-c4-audit", "main", "contracts/schain/tokens/EthErc20.sol", "L64-L67>"]], "vuln": "`BURNER_ROLE` can burn any amount of EthErc20 from an arbitrary address", "severity": "MEDIUM", "mitigation": "Update forceBurn function for only owner can burn his tokens."}
{"locs": [["code-423n4/2022-02-hubble", "main", "contracts/VUSD.sol", "L53"]], "vuln": "denial of service", "severity": "HIGH", "mitigation": "set  a minimum amount of withdrawal. e.g. 1 dollar\n\n```\n    function withdraw(uint amount) external {\n        require(amount >= 10 ** 6);\n        burn(amount);\n        withdrawals.push(Withdrawal(msg.sender, amount));\n    }\n```"}
{"locs": [["code-423n4/2022-02-hubble", "main", "contracts/Oracle.sol", "L24-L35"]], "vuln": "Liquidations can be run on the bogus Oracle prices", "severity": "MEDIUM", "mitigation": "Add a non-zero Oracle price check, possibly add an additional Oracle feed information usage to control that the price is fresh. Please consult the Chainlink for that as OCR introduction might have changed the state of the art approach (i.e. whether and how to use latestRoundData returned data):\n\nhttps://docs.chain.link/docs/off-chain-reporting/\n\nRegarding any price spikes it is straightforward to construct a mitigation mechanics for such cases, so the system will be affected by sustainable price movements only.\n\nAs price outrages provide a substantial attack surface for the project it's worth adding some complexity to the implementation.\n\nOne of the approaches is to track both current and TWAP prices, and condition all state changing actions, including liquidations, on the current price being within a threshold of the TWAP one. If the liquidation margin level is conservative enough and TWAP window is small enough this is safe for the overall stability of the system, while providing substantial mitigation mechanics by allowing state changes on the locally calm market only.\n\nAnother approach is to introduce time delay between liquidation request and actual liquidation. Again, conservative enough margin level plus small enough delay keeps the system safe, while requiring that market conditions allow for liquidation both at request time and at execution time provides ample filtration against price feed outbreaks"}
{"locs": [["code-423n4/2022-02-hubble", "8c157f519bc32e552f8cc832ecc75dc381faa91e", "contracts/VUSD.sol", "L11"]], "vuln": "Hidden governance", "severity": "MEDIUM", "mitigation": "Unify governance in only one, VanillaGovernable or role based."}
{"locs": [["code-423n4/2022-02-hubble", "8c157f519bc32e552f8cc832ecc75dc381faa91e", "contracts/Oracle.sol", "L34"]], "vuln": "Oracle.getUnderlyingPrice could have wrong decimals", "severity": "MEDIUM", "mitigation": "While most USD price feeds use 8 decimals, it's better to take the on-chain reported decimals into account by doing `AggregatorV3Interface(chainLinkAggregatorMap[underlying]).decimals()`, see [Chainlink docs](https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination).\nThe price should then be scaled down to 6 decimals."}
{"locs": [["code-423n4/2022-02-hubble", "main", "contracts/ClearingHouse.sol", "L332"]], "vuln": "ClearingHouse margin calculations will break up if an AMM returning non-6 decimals positions be white listed", "severity": "MEDIUM", "mitigation": "If AMM contract is desired to deal with various VAMMs consider removing decimals related hard coding, adding decimals variables and scaling VAMM returned results accordingly, so that position and margin values' decimals of 6, implied by ClearingHouse logic, be ensured."}
{"locs": [["code-423n4/2022-02-hubble", "main", "contracts/VUSD.sol", "L62"]], "vuln": "Blocking of the VUSD withdrawals is possible if the reserve token doesn\u2019t support zero value transfers", "severity": "MEDIUM", "mitigation": "Consider adding a zero amount check, as it doesn\u2019t cost much, while zero transfer doesn't make sense anyway.\n\nNow:\n```\nreserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\nreserve -= withdrawal.amount;\n```\n\nTo be:\n```\nif (withdrawal.amount > 0) {\n\treserveToken.safeTransfer(withdrawal.usr, withdrawal.amount);\n\treserve -= withdrawal.amount;\n}\n```"}
{"locs": [["code-423n4/2022-02-hubble", "main", "contracts/AMM.sol", "L144"]], "vuln": "Liquidation is vulnerable to sandwich attacks", "severity": "MEDIUM", "mitigation": "set quoteAssetLimit in `_reducePosition` to prevent the attack"}
{"locs": [["code-423n4/2022-02-hubble", "main", "contracts/VUSD.sol", "L53-L67"]], "vuln": "USDC blacklisted accounts can DoS the withdrawal system", "severity": "MEDIUM", "mitigation": "Possible solutions:\n1st solution:\nImplement 2-step withdrawals:\n    - In a for loop, increase the user's amount that can be safely withdrawn.\n    - A user himself withdraws his balance\n\n2st solution:\nSkip blacklisted users in a processWithdrawals loop"}
{"locs": [["code-423n4/2022-02-tribe-turbo", "66f27fe51083f49f7935e3fe594ab2380b75dee8", "src/TurboSafe.sol", "L225-L236)"]], "vuln": "Wrong implementation of `TurboSafe.sol#less()` may cause boosted record value in TurboMaster bigger than actual lead to `BoostCapForVault` and `BoostCapForCollateral` to be permanently occupied", "severity": "MEDIUM", "mitigation": "Change to:\n\n```solidity\nfunction less(ERC4626 vault, uint256 feiAmount) external nonReentrant requiresLocalOrMasterAuth {\n    // Update the total Fei deposited into the Vault proportionately.\n    getTotalFeiBoostedForVault[vault] -= feiAmount;\n\n    unchecked {\n        // Decrease the boost total proportionately.\n        // Cannot underflow because the total cannot be less than a single Vault.\n        totalFeiBoosted -= feiAmount;\n    }\n\n    emit VaultLessened(msg.sender, vault, feiAmount);\n\n    // Withdraw the specified amount of Fei from the Vault.\n    vault.withdraw(feiAmount, address(this), address(this));\n\n    // Call the Master to allow it to update its accounting.\n    master.onSafeLess(asset, vault, feiAmount);\n\n    // Get out current amount of Fei debt in the Turbo Fuse Pool.\n    uint256 feiDebt = feiTurboCToken.borrowBalanceCurrent(address(this));\n\n    // If our debt balance decreased, repay the minimum.\n    // The surplus Fei will accrue as fees and can be sweeped.\n    if (feiAmount > feiDebt) feiAmount = feiDebt;\n\n    // Repay Fei debt in the Turbo Fuse Pool, unless we would repay nothing.\n    if (feiAmount != 0) require(feiTurboCToken.repayBorrow(feiAmount) == 0, \"REPAY_FAILED\");\n}\n```"}
{"locs": [["code-423n4/2022-02-tribe-turbo", "66f27fe51083f49f7935e3fe594ab2380b75dee8", "src/TurboSafe.sol", "L335)<br>"]], "vuln": "Gibber can take any amount from safes", "severity": "MEDIUM", "mitigation": "Limit gib to certain collateral ratio."}
{"locs": [["code-423n4/2022-02-redacted-cartel", "main", "contracts/RewardDistributor.sol", "L181)"]], "vuln": "Send ether with call instead of transfer", "severity": "MEDIUM", "mitigation": "(bool result, ) = payable(\\_account).call{value: \\_amount}(\"\");\nrequire(result, \"Failed to send Ether\");"}
{"locs": [["code-423n4/2022-02-redacted-cartel", "main", "contracts/BribeVault.sol", "L296)<br>"]], "vuln": "`SafeERC20.sol` is imported but not used in the `transferBribes()` function", "severity": "MEDIUM", "mitigation": "It's recommended to use OpenZeppelin\u2019s SafeERC20 versions with the safeTransfer and safeTransferFrom functions that handle the return value check as well as non-standard-compliant tokens."}
{"locs": [["code-423n4/2022-02-redacted-cartel", "main", "contracts/BribeVault.sol", "L164-L205)"]], "vuln": "Reentrancy in `depositBribeERC20` function", "severity": "MEDIUM", "mitigation": "Set bribe token before the transfer is made."}
{"locs": [["code-423n4/2022-02-redacted-cartel", "main", "contracts/BribeVault.sol", "L187)<br>"]], "vuln": "`DEPOSITOR_ROLE` can manipulate `b.amount` value", "severity": "MEDIUM", "mitigation": "I recommend to validate that bribe != Address(this)"}
{"locs": [["code-423n4/2022-02-redacted-cartel", "main", "contracts/ThecosomataETH.sol", "L94-L110)<br>"]], "vuln": "ThecosomataETH: Oracle price can be better secured (freshness + tamper-resistance)", "severity": "MEDIUM", "mitigation": "In my opinion, both freshness and tamper-resistance can be better secured.\n\nThis can be done by:\n\n1.  Ensuring that the price was updated within a certain limit.\n\n```jsx\n// eg. last price update / trade must have been executed within the past hour\nuint256 lastPricesTimestamp = ICurveCryptoPool(CURVEPOOL).last_prices_timestamp();\nrequire(block.timestamp - lastPricesTimestamp <= 1 hours, 'stale price');\n```\n\n2.  Checking that the last reported price `pLast` has not deviated too far from the current oracle price `p_old`. One can argue that it would be safer to add liquidity when the market isn\u2019t volatile.\n\n```jsx\nuint256 lastPrice = ICurveCryptoPool(CURVEPOOL).last_prices();\nuint256 oraclePrice = ICurveCryptoPool(CURVEPOOL).price_oracle();\nuint256 percentDiff;\n// eg. require difference in prices to be within 5%\nif (lastPrice > oraclePrice) {\n  percentDiff = (lastPrice - oraclePrice) * 1e18 / oraclePrice;\n} else {\n  percentDiff = (oraclePrice - lastPrice) * 1e18 / oraclePrice;\n}\nrequire(percentDiff <= 5e16, 'volatile market');\n```"}
{"locs": [["code-423n4/2022-02-redacted-cartel", "main", "contracts/RewardDistributor.sol", "L97) using rewardIdentifier X"]], "vuln": "Rewards can be lost", "severity": "MEDIUM", "mitigation": "bribeVault should only make second call to updateRewardsMetadata on same rewardIdentifier when all claimers have made their claims."}
{"locs": [["code-423n4/2022-02-aave-lens", "c1d2de2b0609b7d2734ada2ce45c91a73cc54dd9", "contracts/core/LensHub.sol", "L878-L888"]], "vuln": "Reentrancy allows commenter to overwrite own comments", "severity": "MEDIUM", "mitigation": "Store the new `pubCount` in a variable before the comment is created and use it during the creation rather than choosing it afterwards."}
{"locs": [["code-423n4/2022-02-aave-lens", "main", "contracts/core/modules/collect/FeeCollectModule.sol", "L72"]], "vuln": "Basis points constant BPS_MAX is used as minimal fee amount requirement", "severity": "MEDIUM", "mitigation": "As a simplest solution consider adding a separate constant for minimum fee amount in nominal terms, say 1 or 10"}
{"locs": [["code-423n4/2022-02-aave-lens", "aaf6c116345f3647e11a35010f28e3b90e7b4862", "contracts/libraries/PublishingLogic.sol", "L50"]], "vuln": "Profile creation can be frontrun", "severity": "MEDIUM", "mitigation": "Everyone needs to use flashbots / private transactions but it might not be available on the deployed chain.\nA commit/reveal scheme for the handle and the entire profile creation could mitigate this issue."}
{"locs": [["code-423n4/2022-02-aave-lens", "aaf6c116345f3647e11a35010f28e3b90e7b4862", "contracts/core/LensHub.sol", "L142"]], "vuln": "Name squatting", "severity": "MEDIUM", "mitigation": "Consider auctioning off handles to the highest bidder or at least taking a fee such that the cost of name squatting is not zero."}
{"locs": [["code-423n4/2022-02-aave-lens", "aaf6c116345f3647e11a35010f28e3b90e7b4862", "contracts/core/modules/collect/FeeCollectModule.sol", "L99"]], "vuln": "Cashback on referral", "severity": "MEDIUM", "mitigation": "There's no way to avoid this except by not allowing any profile as a referrer.\nWhitelist certain important infrastructure providers, like different frontends, as referrers and only allow these to be used instead of users submitting their alt profiles."}
{"locs": [["code-423n4/2022-02-aave-lens", "main", "contracts/libraries/InteractionLogic.sol", "L49"]], "vuln": "It\u2019s possible to follow deleted profiles", "severity": "MEDIUM", "mitigation": "change to:\n```\nif (_profileIdByHandleHash[keccak256(bytes(handle))] != profileIds[i])\n\trevert Errors.TokenDoesNotExist();\n```"}
{"locs": [["code-423n4/2022-02-aave-lens", "main", "contracts/core/LensHub.sol", "L929"]], "vuln": "Missing whenNotPaused", "severity": "MEDIUM", "mitigation": "add whenNotPasued to `_beforeTokenTransfer`"}
{"locs": [["code-423n4/2022-02-aave-lens", "main", "contracts/core/modules/collect/FeeCollectModule.sol", "L176"]], "vuln": "Collect modules can fail on zero amount transfers if treasury fee is set to zero", "severity": "MEDIUM", "mitigation": "Consider checking the treasury fee amount and do transfer only when it is positive.\n\nNow:\n```\nIERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n```\n\nTo be:\n```\nif (treasuryAmount > 0)\n\tIERC20(currency).safeTransferFrom(follower, treasury, treasuryAmount);\n```"}
{"locs": [["code-423n4/2022-02-aave-lens", "main", "contracts/core/LensHub.sol", "L128-135"]], "vuln": "Zero collection module can be whitelisted and set to a post, which will then revert all collects and mirrors with `PublicationDoesNotExist", "severity": "MEDIUM", "mitigation": "Consider prohibiting zero collection module to be white listed.\n\nIf rejecting collects/mirrors is desired for a special post type, the corresponding error path can be implemented"}
{"locs": [["code-423n4/2022-02-aave-lens", "aaf6c116345f3647e11a35010f28e3b90e7b4862", "contracts/core/modules/follow/ApprovalFollowModule.sol", "L32"]], "vuln": "Approvals not cleared when transferring profile", "severity": "MEDIUM", "mitigation": "Consider resetting all approvals upon transfer."}
{"locs": [["code-423n4/2022-02-aave-lens", "aaf6c116345f3647e11a35010f28e3b90e7b4862", "contracts/core/LensHub.sol", "L146"]], "vuln": "Ineffective Whitelist", "severity": "MEDIUM", "mitigation": "Consider limiting the number of profile creations per whitelisted user or severely limiting who is allowed to create profiles, basically making profile creation a centralized system."}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/MasterChef.sol", "L86)<br>"]], "vuln": "Wrong reward token calculation in MasterChef contract", "severity": "HIGH", "mitigation": "Update all existing pools before adding new pool. Use the massUdpate() function which is already present ... but unused."}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/ConvexStakingWrapper.sol", "L175-L204)<br>"]], "vuln": "`ConvexStakingWrapper.sol#_calcRewardIntegral` Wrong implementation can disrupt rewards calculation and distribution", "severity": "HIGH", "mitigation": "Consider comparing the `balanceOf` reward token before and after `getReward()` to get the actual rewarded amount, and `reward.remaining` should be removed."}
{"locs": [["code-423n4/2022-02-concur", "shelter-client", "contracts/ConvexStakingWrapper.sol", "L216-L259)"]], "vuln": "`ConvexStakingWrapper._calcRewardIntegral()` Can Be Manipulated To Steal Tokens From Other Pools", "severity": "HIGH", "mitigation": "Consider redesigning this mechanism such that all pools have their `getReward` function called in `_checkpoint`. The `_calcRewardIntegral` function can then ensure that each pool is allocated only a fraction of the total rewards instead of the change in contract balance. Other implementations might be more ideal, so it is important that careful consideration is taken when making these changes."}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/MasterChef.sol", "L170-L172)<br>"]], "vuln": "Masterchef: Improper handling of deposit fee", "severity": "HIGH", "mitigation": "I recommend shifting the deposit fee logic out of the masterchef contract into the depositor contracts themselves, as additional logic would have to be added in the masterchef to update the fee recipient\u2019s state (rewardDebt, send pending concur rewards, update amount), which further complicates matters. As the fee recipient is likely to be the treasury, it is also not desirable for it to accrue concur rewards.\n\n```jsx\nif (pool.depositFeeBP > 0) {\n  uint depositFee = _amount.mul(pool.depositFeeBP).div(_perMille);\n  user.amount = SafeCast.toUint128(user.amount + _amount - depositFee);\n  UserInfo storage feeRecipient = userInfo[_pid][feeRecipient];\n  // TODO: update and send feeRecipient pending concur rewards\n  feeRecipient.amount = SafeCast.toUint128(feeRecipient.amount + depositFee);\n  // TODO: update fee recipient's rewardDebt\n}\n```"}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/MasterChef.sol", "L86-L101)<br>"]], "vuln": "Unconstrained fee", "severity": "MEDIUM", "mitigation": "On setting fee ensure that it is below a set maximum, which is set to no more than 100%."}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/USDMPegRecovery.sol", "L110-L128)<br>"]], "vuln": "`USDMPegRecovery.sol#withdraw()` withdraw may often fail", "severity": "MEDIUM", "mitigation": "Consider calling `usdm3crv.remove_liquidity_one_coin()` when the balance is insufficient for the user's withdrawal."}
{"locs": [["code-423n4/2022-02-concur", "02d286253cd5570d4e595527618366f77627cdaf", "contracts/USDMPegRecovery.sol", "L73-L82)<br>"]], "vuln": "`USDMPegRecovery.sol#provide()` Improper design/implementation make it often unable to add liquidity to the `usdm3crv` pool", "severity": "MEDIUM", "mitigation": "Change to:\n\n```solidity\nfunction provide(uint256 _minimumLP) external onlyGuardian {\n    require(usdm.balanceOf(address(this)) >= totalLiquidity.usdm, \"<liquidity\");\n    uint256 tokenBalance = Math.min(usdm.balanceOf(address(this), pool3.balanceOf(address(this));\n    // truncate amounts under step\n    uint256 addingLiquidity = (tokenBalance / step) * step;\n    // match usdm : pool3 = 1 : 1\n    uint256[2] memory amounts = [addingLiquidity, addingLiquidity];\n    usdm.approve(address(usdm3crv), addingLiquidity);\n    pool3.approve(address(usdm3crv), addingLiquidity);\n    usdm3crv.add_liquidity(amounts, _minimumLP);\n}\n```"}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/StakingRewards.sol", "L166-L176)<br>"]], "vuln": "`StakingRewards.sol` `recoverERC20()` can be used as a backdoor by the `owner` to retrieve `rewardsToken`", "severity": "MEDIUM", "mitigation": "Change to:\n\n```solidity\n function recoverERC20(\n    address tokenAddress,\n    address to,\n    uint256 amount\n) external onlyOwner {\n    require(tokenAddress != address(stakingToken) && tokenAddress != address(rewardsToken), \"20\");\n\n    IERC20(tokenAddress).safeTransfer(to, amount);\n    emit Recovered(tokenAddress, to, amount);\n}\n```"}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/Shelter.sol", "L34)<br>"]], "vuln": "Fee-on-transfer token donations in `Shelter` break withdrawals", "severity": "MEDIUM", "mitigation": "In `donate`, add only the actual transferred amounts (computed by `post-transfer balance - pre-transfer balance`) to `savedTokens[_token]`."}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/StakingRewards.sol", "L154-L158)<br>"]], "vuln": "`StakingRewards.sol#notifyRewardAmount()` Improper reward balance checks can make some users unable to withdraw their rewards", "severity": "MEDIUM", "mitigation": "Consider changing the function `notifyRewardAmount` to `addRward` and use `transferFrom` to transfer rewardsToken into the contract:\n\n```solidity\nfunction addRward(uint256 reward)\n    external\n    updateReward(address(0))\n{\n    require(\n        msg.sender == rewardsDistribution,\n        \"Caller is not RewardsDistribution contract\"\n    );\n\n    if (block.timestamp >= periodFinish) {\n        rewardRate = reward / rewardsDuration;\n    } else {\n        uint256 remaining = periodFinish - block.timestamp;\n        uint256 leftover = remaining * rewardRate;\n        rewardRate = (reward + leftover) / rewardsDuration;\n    }\n\n    rewardsToken.safeTransferFrom(msg.sender, address(this), reward);\n\n    lastUpdateTime = block.timestamp;\n    periodFinish = block.timestamp + rewardsDuration;\n    emit RewardAdded(reward);\n}\n```"}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/USDMPegRecovery.sol", "L73-L82)<br>"]], "vuln": "`USDMPegRecovery.provide()` Will Fail If There Is An Excess Of `usdm` Tokens", "severity": "MEDIUM", "mitigation": "Consider modifying the `provide` function such that a `_steps` argument can be supplied. This will allow guardians to maximise the amount of liquidity provided to the Curve pool."}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/StakingRewards.sol", "L166)<br>"]], "vuln": "`StakingRewards.recoverERC20` allows owner to rug the `rewardsToken`", "severity": "MEDIUM", "mitigation": "Add an additional check\n\n            require(\n                tokenAddress != address(rewardsToken),\n                \"Cannot withdraw the rewards token\"\n            );"}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/MasterChef.sol", "L82-L84)<br>"]], "vuln": "Owner can lock tokens in `MasterChef`", "severity": "MEDIUM", "mitigation": "Remove `onlyDepositor` modifier from the `withdraw` function."}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/Shelter.sol", "L38-L42)<br>"]], "vuln": "Rogue pool in Shelter", "severity": "MEDIUM", "mitigation": "*   Avoid `activate` twice for the same token\n*   `donate` only after the `GRACE_PERIOD`"}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/MasterChef.sol", "L135-L154)"]], "vuln": "`MasterChef.updatePool()` Fails To Update Reward Variables If `block.number >= endBlock`", "severity": "MEDIUM", "mitigation": "Ensure that once the `block.number >= endBlock` statement has been reached, the `pool.accConcurPerShare` is updated to reflect the number of blocks that have passed up until `endBlock`. The number of blocks should be equal to `endBlock - pool.lastRewardBlock`. This will ensure stale pools are not negatively impacted once `endBlock` has been reached by the contract."}
{"locs": [["code-423n4/2022-02-concur", "main", "contracts/ConcurRewardPool.sol", "L34)<br>"]], "vuln": "[ConcurRewardPool Possible reentrancy when claiming rewards", "severity": "MEDIUM", "mitigation": "*   Use a nonReentrant modifier\n*   set balances to 0 first before disbursing the rewards"}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/StakingRewards.sol", "L126)<br>"]], "vuln": "Transfer to treasury can register as succeeded when failing in `_calcRewardIntegral`", "severity": "MEDIUM", "mitigation": "`require(IERC20(reward.token).transfer(treasury, d_reward / 5), \"ERROR_MESSAGE\");`"}
{"locs": [["code-423n4/2022-02-concur", "02d286253cd5570d4e595527618366f77627cdaf", "contracts/ConvexStakingWrapper.sol", "L184-L188)<br>"]], "vuln": "Rewards distribution can be disrupted by a early user", "severity": "MEDIUM", "mitigation": "Consider `wrap` a certain amount of initial totalSupply at deployment, e.g. `1e8`, and never burn it. And consider using uint256 instead of uint128 for `reward.integral`. Also, consider lower `1e20` down to `1e12`."}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/ConvexStakingWrapper.sol", "L228-L250)<br>"]], "vuln": "`ConvexStakingWrapper#deposit()` depositors may lose their funds when the `_amount` is huge", "severity": "MEDIUM", "mitigation": "Consider adding a upper limit for the `_amount` parameter:\n\n```solidity\nrequire(_amount <= type(uint192).max, \"...\");\n```"}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/MasterChef.sol", "L205-L206)<br>"]], "vuln": "During stake or deposit, users would not be rewarded the correct Concur token, when MasterChef has under-supply of it", "severity": "MEDIUM", "mitigation": "Minimal recommended fix:\n\nTo `MasterChef.safeConcurTransfer` function, add the following require statement. This will at least ensure that, when there is zero balance in MasterChef contract, the safeConcurTransfer function will not succeed.\n\n```bash\n    function safeConcurTransfer(address _to, uint _amount) private {\n        uint concurBalance = concur.balanceOf(address(this));\n        require(concurBalance>0, \"safeConcurTransfer: balance is zero.\");\n```"}
{"locs": [["code-423n4/2022-02-concur", "72b5216bfeaa7c52983060ebfc56e72e0aa8e3b0", "contracts/StakingRewards.sol", "L161)<br>"]], "vuln": "`StakingRewards` reward rate can be dragged out and diluted", "severity": "MEDIUM", "mitigation": "Imo, the `rewardRate` should never decrease by a `notifyRewardAmount` call.<br>\nConsider not extending the reward payouts by `rewardsDuration` on every call.<br>\n`periodFinish` probably shouldn't change at all, the `rewardRate` should just increase by `rewardRate += reward / (periodFinish - block.timestamp)`.\n\nAlternatively, consider keeping the `rewardRate` constant but extend `periodFinish` time by `+= reward / rewardRate`."}
{"locs": [["code-423n4/2022-01-yield", "main", "contracts/ConvexYieldWrapper.sol", "L100-L120>"]], "vuln": "Malicious Users Can Transfer Vault Collateral To Other Accounts To Extract Additional Yield From The Protocol", "severity": "HIGH", "mitigation": "Ensure that any change to a vault will correctly checkpoint the previous and new vault owner. The affected actions include but are not limited to; transferring ownership of a vault to a new account, transferring collateral to another vault and adding/removing collateral to/from a vault."}
{"locs": [["code-423n4/2022-01-notional", "main", "contracts/sNOTE.sol", "L100>"]], "vuln": "MAX_SHORTFALL_WITHDRAW limit on BTP extraction is not enforced", "severity": "MEDIUM", "mitigation": "Rewrite the logic and enforce a limit during a time period - i.e. do not allow to withdraw over 50% *per week* (or any time period that is longer than the cooldown period, so that users have time to withdraw their collateral)"}
{"locs": [["code-423n4/2022-01-notional", "main", "contracts/sNOTE.sol", "L99-L129>"]], "vuln": "`sNOTE` Holders Are Not Incetivized To Vote On Proposals To Call `extractTokensForCollateralShortfall`", "severity": "MEDIUM", "mitigation": "Consider redesigning this mechanism to better align stakers with the health of the protocol. It might be useful to allocate a percentage of generated fees to an insurance fund which will be used to cover any collateral shortfall events. This fund can be staked to generate additional yield."}
{"locs": [["code-423n4/2022-01-notional", "main", "contracts/sNOTE.sol", "L271-L293>"]], "vuln": "`getVotingPower` Is Not Equipped To Handle On-Chain Voting", "severity": "MEDIUM", "mitigation": "Consider implementing a `getPriorVotingPower` function which takes in a `blockNumber` argument and returns the correct balance at that specific block."}
{"locs": [["livepeer/arbitrum-lpt-bridge", "ebf68d11879c2798c5ec0735411b08d0bea4f287", "contracts/L1/escrow/L1Escrow.sol", "L21)"]], "vuln": "Admin can rug L2 Escrow tokens leading to reputation risk", "severity": "MEDIUM", "mitigation": "Restrict the power of this `approve` function so that the admin isn't able to steal funds. This can be accomplished by only allowing approvals to other protocol functions (instead of arbitrary approvals)."}
{"locs": [["code-423n4/2022-01-timeswap", "main", "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol", "L177>"]], "vuln": "Important state updates are made after the callback in the mint() function", "severity": "HIGH", "mitigation": "The callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place."}
{"locs": [["code-423n4/2022-01-timeswap", "main", "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol", "L246>"]], "vuln": "In the lend() function state updates are made after the callback", "severity": "HIGH", "mitigation": "The callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place."}
{"locs": [["code-423n4/2022-01-timeswap", "main", "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol", "L322>"]], "vuln": "borrow() function has state updates after a callback to msg.sender", "severity": "HIGH", "mitigation": "The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place."}
{"locs": [["code-423n4/2022-01-timeswap", "main", "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol", "L369>"]], "vuln": "pay() function has callback to msg.sender before important state updates", "severity": "HIGH", "mitigation": "The callback \"if (assetIn > 0) Callback.pay(asset, assetIn, data);\"  should be placed at the end of the pay() function after all state updates have taken place."}
{"locs": [["code-423n4/2022-01-timeswap", "bf50d2a8bb93a5571f35f96bd74af54d9c92a210", "Timeswap/Timeswap-V1-Convenience/contracts/CollateralizedDebt.sol", "L80-L88>"]], "vuln": "`burn()` doesn't call ERC721 `_burn()`", "severity": "MEDIUM", "mitigation": "Include the following line in the `burn()` function\n`_burn(id);`"}
{"locs": [["code-423n4/2022-01-timeswap", "main", "Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol", "L90) to the `NFTSVG.constructSVG` function [here](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTTokenURIScaffold.sol#L102). This function returns a SVG [containing](https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Convenience/contracts/libraries/NFTSVG.sol#L27) the tainted ERC20 symbol."]], "vuln": "XSS via SVG Construction contract", "severity": "MEDIUM", "mitigation": "Creating a SVG file inside of a Solidity contract is novel and thus requires the entity creating a SVG file to sanitize any potential user-input that goes into generating the SVG file.\n\nAs of this time there are no known Solidity libraries that sanitize text to prevent an XSS attack. The easiest solution is to remove all user-input data from the SVG file or not generate the SVG at all."}
{"locs": [["code-423n4/2022-01-timeswap", "main", "Timeswap/Timeswap-V1-Convenience/contracts/libraries/Mint.sol", "L141>"]], "vuln": "users might pay enormous amounts of gas", "severity": "MEDIUM", "mitigation": "If the pair doesn't exist, revert instead of deploying it.\ndeploying a new contract should be the user's choice, since it's so expensive."}
{"locs": [["code-423n4/2022-01-timeswap", "main", "Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol", "L364>"]], "vuln": "DOS pay function", "severity": "MEDIUM", "mitigation": "if `assetsIn[i]` is bigger than `due.debt` set `assetsIn[i]=due.debt` and `due.debt=0`"}
{"locs": [["code-423n4/2021-12-sublime", "main", "contracts/PriceOracle.sol", "L149-L161>"]], "vuln": "`PriceOracle` Does Not Filter Price Feed Outliers", "severity": "HIGH", "mitigation": "Consider querying both the Chainlink oracle and Uniswap pool for latest prices, ensuring that these two values are within some upper/lower bounds of each other. It may also be useful to track historic values and ensure that there are no sharp changes in price. However, the first option provides a level of simplicity as UniswapV3's TWAP implementation is incredibly resistant to flash loan attacks. Hence, the main issue to address is a malfunctioning Chainlink oracle."}
{"locs": [["code-423n4/2021-12-sublime", "9df1b7c4247f8631647c7627a8da9bdc16db8b11", "contracts/CreditLine/CreditLine.sol", "L996>."]], "vuln": "Anyone can liquidate credit line when autoLiquidation is false without supplying borrow tokens", "severity": "HIGH", "mitigation": "Add the following require statement somewhere in the `liquidate` function:\n```solidity\nrequire(\n    creditLineConstants[_id].autoLiquidation || \n    msg.sender == creditLineConstants[_id].lender,\n    \"not autoLiquidation and not lender\");\n```\n\n##"}
{"locs": [["code-423n4/2021-12-sublime", "main", "contracts/yield/NoYield.sol", "L78-L83>"]], "vuln": "Unable To Call `emergencyWithdraw` ETH in `NoYield` Contract", "severity": "HIGH", "mitigation": "Consider handling the case where `_asset` is the zero address, i.e. the asset to be withdrawn under emergency is the ETH token."}
{"locs": [["code-423n4/2021-12-sublime", "main", "contracts/Pool/PoolFactory.sol", "L260-L317)"]], "vuln": "Ether can be locked in the `PoolFactory` contract without a way to retrieve it", "severity": "MEDIUM", "mitigation": "If msg.value is greater than 0, make sure the `_collateralToken` address is set to address(0)."}
{"locs": [["code-423n4/2021-12-sublime", "main", "contracts/CreditLine/CreditLine.sol", "L1015>"]], "vuln": "CreditLine.liquidate doesn't transfer borrowed ETH to a lender", "severity": "MEDIUM", "mitigation": "Add transfer to a lender for ETH case:\n\nNow:\n```solidity\n\nif (_borrowAsset == address(0)) {\n        uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n        if (_returnETH != 0) {\n                (bool success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'Transfer fail');\n        }\n}\n```\nTo be:\n```solidity\n\nif (_borrowAsset == address(0)) {\n        uint256 _returnETH = msg.value.sub(_borrowTokens, 'Insufficient ETH to liquidate');\n        \n        (bool success, ) = _lender.call{value: _borrowTokens}('');\n        require(success, 'liquidate: Transfer failed');\n        \n        if (_returnETH != 0) {\n                (success, ) = msg.sender.call{value: _returnETH}('');\n                require(success, 'liquidate: Return transfer failed');\n        }\n}\n```"}
{"locs": [["code-423n4/2021-12-sublime", "9df1b7c4247f8631647c7627a8da9bdc16db8b11", "contracts/Pool/Pool.sol", "L207>"]], "vuln": "Collateral can be deposited in a finished pool", "severity": "MEDIUM", "mitigation": "Require loan status to be collection or active in the depositCollateral function."}
{"locs": [["code-423n4/2021-12-sublime", "e688bd6cd3df7fefa3be092529b4e2d013219625", "contracts/Verification/Verification.sol", "L129-L154>"]], "vuln": "Unlinked address can link immediately again", "severity": "MEDIUM", "mitigation": "Add something like to following at the end of linkAddress:\n\n```solidity\ndelete pendingLinkAddresses[msg.sender][_masterAddress]; \n```"}
{"locs": [["code-423n4/2021-12-perennial", "main", "protocol/contracts/collateral/types/OptimisticLedger.sol", "L63:#L74)"]], "vuln": "Wrong shortfall calculation", "severity": "HIGH", "mitigation": "Move the setting of `self.shortfall` to inside the if function and change the line to:\n```\n    self.shortfall = shortfall\n```"}
{"locs": [["pooltogether/v4-periphery", "b520faea26bcf60371012f6cb246aa149abd3c7d", "contracts/TwabRewards.sol", "L119-L138>"]], "vuln": "cancelPromotion is too rigorous", "severity": "HIGH", "mitigation": "In the function `cancelPromotion()` lower the `numberOfEpochs` or set a state variable, to allow user to claim their rewards."}
{"locs": [["pooltogether/v4-periphery", "master", "contracts/TwabRewards.sol", "L230-L244) is that the smart contract must implement the `ITicket` interface."]], "vuln": "Malicious tickets can lead to the loss of all tokens", "severity": "HIGH", "mitigation": "Maybe add a whitelist of trusted tickets?"}
{"locs": [["pooltogether/v4-periphery", "b520faea26bcf60371012f6cb246aa149abd3c7d", "contracts/TwabRewards.sol", "L320))."]], "vuln": "Contract does not work with fee-on transfer tokens", "severity": "HIGH", "mitigation": "To disable fee-on transfer tokens for the contract, add the following code in\n`createPromotion` around line 11:\n```solidity\nuint256 oldBalance = _token.balanceOf(address(this));\n_token.safeTransferFrom(msg.sender, address(this), _tokensPerEpoch * _numberOfEpochs);\nuint256 newBalance = _token.balanceOf(address(this));\nrequire(oldBalance + _tokenPerEpoch * _numberOfEpochs == newBalance);\n```"}
{"locs": [["pooltogether/v4-periphery", "b520faea26bcf60371012f6cb246aa149abd3c7d", "contracts/TwabRewards.sol", "L209>"]], "vuln": "getRewardsAmount doesn't check epochs haven't been claimed", "severity": "MEDIUM", "mitigation": "Add a similar check for previously claimed epochs as described above."}
{"locs": [["pooltogether/v4-periphery", "b520faea26bcf60371012f6cb246aa149abd3c7d", "contracts/TwabRewards.sol", "L162-L191>"]], "vuln": "Dust Token Balances Cannot Be Claimed By An `admin` Account", "severity": "MEDIUM", "mitigation": "Consider allowing an `admin` account to skim a promotion's tokens if it has been inactive for a certain length of time. There are several potential implementations, in varying degrees of complexity. However, the solution should attempt to maximise simplicity while minimising the accrual of dust balances."}
{"locs": [["pooltogether/v4-periphery", "b520faea26bcf60371012f6cb246aa149abd3c7d", "contracts/TwabRewards.sol", "L162-L191>"]], "vuln": "Missing Check When Transferring Tokens Out For A Given Promotion", "severity": "MEDIUM", "mitigation": "Consider checking that the total rewards claimed for a given promotion is strictly `<=` than the total allotted balance provided by the promotion creator. This should help prevent a single promotion from affecting the rewards claimable from other promotions."}
{"locs": [["code-423n4/2021-12-defiprotocol", "main", "contracts/contracts/Basket.sol", "L44-L61)"]], "vuln": "Reentrancy vulnerability in `Basket` contract's `initialize()` method.", "severity": "MEDIUM", "mitigation": "Since `Basket` inherits from `ERC20Upgradeable` the `initializer` modifier should be available and therefore used here. It has an `inititializing` variable that would prevent this kind of reentrancy attack."}
{"locs": [["code-423n4/2021-12-defiprotocol", "205d3766044171e325df6a8bf2e79b37856eece1", "contracts/contracts/Auction.sol", "L97-L102)"]], "vuln": "`Auction.sol#settleAuction()` Bonder may not be able to settle a bonded auction, leading to loss of funds", "severity": "MEDIUM", "mitigation": "Move the `minIbRatio` check to `bondForRebalance()`:\n\n```solidity\nfunction bondForRebalance() public override {\nrequire(auctionOngoing);\nrequire(!hasBonded);\n\nbondTimestamp = block.timestamp;\nbondBlock = block.number;\n\nuint256 a = factory.auctionMultiplier() * basket.ibRatio();\nuint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\nuint256 newRatio = a - b;\n\n(address[] memory pendingTokens, uint256[] memory pendingWeights, uint256 minIbRatio) = basket.getPendingWeights();\nrequire(newRatio >= minIbRatio);\n\nIERC20 basketToken = IERC20(address(basket));\nbondAmount = basketToken.totalSupply() / factory.bondPercentDiv();\nbasketToken.safeTransferFrom(msg.sender, address(this), bondAmount);\nhasBonded = true;\nauctionBonder = msg.sender;\n\nemit Bonded(msg.sender, bondAmount);\n}\n```"}
{"locs": [["code-423n4/2021-12-defiprotocol", "main", "contracts/contracts/Basket.sol", "L140:#L145)<br>"]], "vuln": "Lost fees due to precision loss in fees calculation", "severity": "MEDIUM", "mitigation": "We want to firstly do all multiplication and lastly do all the division.\nSo remove the usage of feePct and instead set fee to be:\n```solidity\nuint256 fee = startSupply * licenseFee * timeDiff / ONE_YEAR / (BASE - licenseFee);\n```"}
{"locs": [["code-423n4/2021-12-defiprotocol", "205d3766044171e325df6a8bf2e79b37856eece1", "contracts/contracts/Basket.sol", "L141)"]], "vuln": "`Basket:handleFees():` fees are overcharged", "severity": "MEDIUM", "mitigation": "*   account the fee amount in a storage variable: uint256 feeAmount;\n*   subtract feeAmount from startSupply L141: uint256 fee = (startSupply - feeAmount) \\* feePct / (BASE - feePct); // note the other bug about only dividing by BASE\n*   add the fee to feeAmount after the calculation:  feeAmount += fee;\n*   if publisher/protocol owner burn basket token, reduce the feeAmount etc."}
{"locs": [["code-423n4/2021-11-nested", "5d113967cdf7c9ee29802e1ecb176c656386fe9b", "contracts/NestedFactory.sol", "L89)"]], "vuln": "`setReserve()` can be front-run", "severity": "MEDIUM", "mitigation": "Consider initializing the value for the `reserve` variable in the constructor."}
{"locs": [["OpenZeppelin/openzeppelin-contracts", "e63b09c9ad3a45484b6dc304e0e99640a9dc3036", "contracts/token/ERC20/ERC20.sol", "L229]"]], "vuln": "`UnionToken` should check whitelist on `from`?", "severity": "MEDIUM", "mitigation": "Think about if the whitelist on `msg.sender` is correct or if it should be on `from`."}
{"locs": [["compound-finance/compound-protocol", "master", "contracts/CToken.sol", "L680)."]], "vuln": "Rebalance will fail if a market has high utilization", "severity": "MEDIUM", "mitigation": "Withdraw only what's available and rebalance on that instead of trying to pull all tokens from each market first.\nAdmittedly, this might be hard to compute for some protocols."}
{"locs": [["code-423n4/2021-10-defiprotocol", "main", "contracts/contracts/Auction.sol", "L95:#L105>"]], "vuln": "Auction bonder can steal user funds if bond block is high enough", "severity": "MEDIUM", "mitigation": "Your needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in `settleAuction`:\n```solidity\nrequire (newRatio > basket.ibRatio());\n```\n\nMaybe you would require `newRatio` to be > BASE but not sure."}
{"locs": [["pooltogether/v4-core", "master", "contracts/prize-pool/PrizePool.sol", "L250-L270>"]], "vuln": "`PrizePool.awardExternalERC721()` Erroneously Emits Events", "severity": "MEDIUM", "mitigation": "Consider emitting only successfully transferred tokenIds in the `AwardedExternalERC721` event."}
{"locs": [["sushiswap/trident", "c405f3402a1ed336244053f8186742d2da5975e9", "contracts/pool/concentrated/ConcentratedLiquidityPosition.sol", "L75-L101)"]], "vuln": "`ConcentratedLiquidityPosition.sol#collect()` Users may get double the amount of yield when they call `collect()` before `burn()`", "severity": "HIGH", "mitigation": "Consider making `ConcentratedLiquidityPosition.sol#burn()` call `position.pool.collect()` before `position.pool.burn()`. User will need to call `ConcentratedLiquidityPosition.sol#collect()` to collect unclaimed fees after `burn()`.\n\nOr `ConcentratedLiquidityPosition.sol#collect()` can be changed into a `public` method and `ConcentratedLiquidityPosition.sol#burn()` can call it after `position.pool.burn()`."}
{"locs": [["sushiswap/trident", "c405f3402a1ed336244053f8186742d2da5975e9", "contracts/pool/concentrated/ConcentratedLiquidityPool.sol", "L525-L553)"]], "vuln": "`ConcentratedLiquidityPosition.sol#burn()` Wrong implementation allows attackers to steal yield", "severity": "HIGH", "mitigation": "Consider making `ConcentratedLiquidityPosition.sol#burn()` always use `address(this)` as `recipient` in:\n\n```solidity\nposition.pool.burn(abi.encode(position.lower, position.upper, amount, recipient, unwrapBento));\n```\n\nand transfer proper amounts to the user."}
{"locs": [["sushiswap/trident", "c405f3402a1ed336244053f8186742d2da5975e9", "contracts/pool/concentrated/ConcentratedLiquidityPoolManager.sol", "L94-L95)"]], "vuln": "Users cannot receive rewards from `ConcentratedLiquidityPoolManager` if their liquidity is too large", "severity": "MEDIUM", "mitigation": "Check whether the `rewards` exceeds the `incentive.rewardsUnclaimed`. If so, then send only `incentive.rewardsUnclaimed` amount of rewards to the user."}
{"locs": [["code-423n4/2021-09-defiProtocol", "main", "contracts/contracts/Basket.sol", "L102-L108>"]], "vuln": "`Basket.sol#auctionBurn()` A failed auction will freeze part of the funds", "severity": "HIGH", "mitigation": "Change to:\n\n```solidity\nfunction auctionBurn(uint256 amount) onlyAuction external override {\nhandleFees();\nuint256 startSupply = totalSupply();\n_burn(msg.sender, amount);\n\nuint256 newIbRatio = ibRatio * startSupply / (startSupply - amount);\nibRatio = newIbRatio;\n\nemit NewIBRatio(newIbRatio);\nemit Burned(msg.sender, amount);\n}\n```"}
{"locs": [["code-423n4/2021-09-defiProtocol", "main", "contracts/contracts/Factory.sol", "L106)"]], "vuln": "Fee on transfer tokens can lead to incorrect approval", "severity": "MEDIUM", "mitigation": "It is recommended to find the balance of the current contract before and\nafter the `transferFrom` to see how much tokens were received, and\napprove only what was received."}
{"locs": [["code-423n4/2021-09-defiProtocol", "main", "contracts/contracts/Auction.sol", "L89-L91)"]], "vuln": "No minimum rate in the auction may break the protocol under network failure", "severity": "MEDIUM", "mitigation": "I recommend setting a minimum `ibRatio` when a publisher publishes a new index. The auction should be killed if the `ibRatio` is too low."}
{"locs": [["sushiswap/trident", "9130b10efaf9c653d74dc7a65bde788ec4b354b5", "contracts/pool/IndexPool.sol", "L196-L223)"]], "vuln": "Flash swap call back prior to transferring tokens in `indexPool`", "severity": "HIGH", "mitigation": "```solidity\n_transfer(tokenOut, amountOut, recipient, unwrapBento);\nITridentCallee(msg.sender).tridentSwapCallback(context);\n// @dev Check Trident router has sent `amountIn` for skim into pool.\nunchecked { // @dev This is safe from under/overflow - only logged amounts handled.\n    require(_balance(tokenIn) >= amountIn + inRecord.reserve, \"NOT_RECEIVED\");\n    inRecord.reserve += uint120(amountIn);\n    outRecord.reserve -= uint120(amountOut);\n}\n```"}
{"locs": [["sushiswap/trident", "9130b10efaf9c653d74dc7a65bde788ec4b354b5", "contracts/TridentRouter.sol", "L318-L351)"]], "vuln": "Users are susceptible to back-running when depositing ETH to `TridenRouter`", "severity": "MEDIUM", "mitigation": "Directly push the remaining ETH to the sender to prevent any ETH left in the router."}
{"locs": [["sushiswap/miso", "master", "contracts/Auctions/Crowdsale.sol", "L374>"]], "vuln": "Last person to withdraw his tokens might not be able to do this, in Crowdsale (edge case)", "severity": "HIGH", "mitigation": "In the function _addCommitment, add a check on auctionEnded() or status.finalized\n```"}
